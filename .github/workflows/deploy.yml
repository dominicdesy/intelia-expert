name: Ultra Fast Build and Deploy

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'docs/**'
      - 'README.md'
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: registry.digitalocean.com/${{ secrets.DOCR_NAME }}
  KEEP_IMAGES: "6"  # combien d'images à conserver par repo

jobs:
  # ──────────────────────────────────────────────────────────────────────────────
  # 1) Détection des changements
  # ──────────────────────────────────────────────────────────────────────────────
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      frontend-changed: ${{ steps.changes.outputs.frontend }}
      backend-changed:  ${{ steps.changes.outputs.backend }}
      llm-changed:      ${{ steps.changes.outputs.llm }}
    steps:
      - uses: actions/checkout@v4
      - name: Paths filter
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            frontend:
              - 'frontend/**'
            backend:
              - 'backend/**'
            llm:
              - 'llm/**'

  # ──────────────────────────────────────────────────────────────────────────────
  # 2) Builds parallèles (sans nettoyage local par repo)
  # ──────────────────────────────────────────────────────────────────────────────
  build-frontend:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.frontend-changed == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DOCR_ACCESS_TOKEN }}

      - name: Docker login to DOCR
        run: doctl registry login --expiry-seconds 600

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push Frontend
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          platforms: linux/amd64
          push: true
          provenance: false
          sbom: false
          tags: |
            ${{ env.REGISTRY }}/intelia-frontend:latest
            ${{ env.REGISTRY }}/intelia-frontend:sha-${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/intelia-frontend:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/intelia-frontend:buildcache,mode=max
          build-args: |
            NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
            LLM_BACKEND_URL=${{ secrets.LLM_BACKEND_URL }}

  build-backend:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.backend-changed == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DOCR_ACCESS_TOKEN }}

      - name: Docker login to DOCR
        run: doctl registry login --expiry-seconds 600

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push Backend
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          platforms: linux/amd64
          push: true
          provenance: false
          sbom: false
          tags: |
            ${{ env.REGISTRY }}/intelia-backend:latest
            ${{ env.REGISTRY }}/intelia-backend:sha-${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/intelia-backend:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/intelia-backend:buildcache,mode=max
          build-args: |
            OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
            SUPABASE_URL=${{ secrets.SUPABASE_URL }}
            SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}

  build-llm:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.llm-changed == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DOCR_ACCESS_TOKEN }}

      - name: Docker login to DOCR
        run: doctl registry login --expiry-seconds 600

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push LLM
        uses: docker/build-push-action@v6
        with:
          context: ./llm
          file: ./llm/Dockerfile
          platforms: linux/amd64
          push: true
          provenance: false
          sbom: false
          tags: |
            ${{ env.REGISTRY }}/intelia-llm:latest
            ${{ env.REGISTRY }}/intelia-llm:sha-${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/intelia-llm:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/intelia-llm:buildcache,mode=max

  # ──────────────────────────────────────────────────────────────────────────────
  # 3) PRUNE centralisé (idempotent, re-vérifie la présence des digests)
  # ──────────────────────────────────────────────────────────────────────────────
  prune-docr:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend, build-backend, build-llm]
    if: always()  # on nettoie même si un build a échoué ou a été ignoré
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DOCR_ACCESS_TOKEN }}

      - name: Docker login to DOCR
        run: doctl registry login --expiry-seconds 600

      - name: 🧹 Prune DOCR (centralisé & idempotent)
        shell: bash
        run: |
          set -euo pipefail

          prune_repo() {
            local repo="$1"
            local keep="$2"

            echo "🔎 Prune ${repo} (garder ${keep} images)..."

            # Si le repo n'existe pas, on sort calmement
            if ! doctl registry repository list --no-header 2>/dev/null | awk '{print $1}' | grep -qx "${repo}"; then
              echo "ℹ️ Repo ${repo} inexistant — skip"
              return 0
            fi

            # Récupère: Digest,UpdatedAt,Tags ; tri décroissant date ; ignore lignes vides
            mapfile -t all_lines < <(
              doctl registry repository list-manifests "${repo}" \
                --format Digest,UpdatedAt,Tags --no-header 2>/dev/null \
              | awk 'NF>=2 {print $1"\t"$2"\t"$3}' \
              | sort -rk2,2
            )

            local total="${#all_lines[@]}"
            if (( total == 0 )); then
              echo "✅ Rien à supprimer pour ${repo} (aucune image)"
              return 0
            fi

            if (( total <= keep )); then
              echo "✅ ${repo}: ${total} images (≤ ${keep}) — rien à faire"
              return 0
            fi

            # On garde les "keep" plus récentes ; le reste est à supprimer
            mapfile -t old_digests < <(
              printf "%s\n" "${all_lines[@]}" \
              | tail -n +$((keep+1)) \
              | awk '{print $1}' \
              | sed -n 's/^sha256:[0-9a-f]\{64\}$/&/p' \
              | uniq
            )

            if (( ${#old_digests[@]} == 0 )); then
              echo "✅ ${repo}: rien à supprimer après filtrage"
              return 0
            fi

            local deleted=0 failed=0
            for dg in "${old_digests[@]}"; do
              # Re-vérifie l'existence juste avant suppression (évite "déjà supprimé")
              if doctl registry repository list-manifests "${repo}" --format Digest --no-header 2>/dev/null | grep -qx "${dg}"; then
                echo "🗑️ Suppression: ${dg}"
                # petit retry pour robustesse
                if doctl registry repository delete-manifest "${repo}" "${dg}" --force 2>/dev/null \
                   || (sleep 2 && doctl registry repository delete-manifest "${repo}" "${dg}" --force 2>/dev/null); then
                  ((deleted++))
                else
                  ((failed++))
                  echo "ℹ️ Non supprimé (concurrence/absent/verrou): ${dg} — on continue"
                fi
              else
                echo "ℹ️ Déjà supprimé (ou concurrent): ${dg}"
              fi
            done

            echo "📈 ${repo} — supprimés: ${deleted} | non supprimés (non bloquants): ${failed}"
          }

          # Liste des dépôts à nettoyer
          for r in intelia-frontend intelia-backend intelia-llm; do
            prune_repo "$r" "${KEEP_IMAGES}"
          done

  # ──────────────────────────────────────────────────────────────────────────────
  # 4) (Optionnel) Récapitulatif
  # ──────────────────────────────────────────────────────────────────────────────
  summary:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend, build-backend, build-llm, prune-docr]
    if: always()
    steps:
      - name: Résumé déploiement
        run: |
          echo ""
          echo "🚀 Résumé:"
          echo "FRONTEND:  ${{ needs.detect-changes.outputs.frontend-changed == 'true' && (needs.build-frontend.result == 'success' && '✅ DÉPLOYÉ' || '❌ ÉCHEC') || '⏸️ INCHANGÉ' }}"
          echo "BACKEND:   ${{ needs.detect-changes.outputs.backend-changed == 'true'  && (needs.build-backend.result  == 'success' && '✅ DÉPLOYÉ' || '❌ ÉCHEC') || '⏸️ INCHANGÉ' }}"
          echo "LLM:       ${{ needs.detect-changes.outputs.llm-changed == 'true'      && (needs.build-llm.result      == 'success' && '✅ DÉPLOYÉ' || '❌ ÉCHEC') || '⏸️ INCHANGÉ' }}"
          echo ""
          echo "🧹 PRUNE:   ${{ needs.prune-docr.result == 'success' && '✅ OK' || '⚠️ AVERTISSEMENTS (non bloquant)' }}"
