name: Smart Selective Docker Build and Deploy

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'docs/**'
      - 'README.md'
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ğŸ” DÃ©tecter les changements
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      frontend-changed: ${{ steps.changes.outputs.frontend }}
      backend-changed: ${{ steps.changes.outputs.backend }}
      llm-changed: ${{ steps.changes.outputs.llm }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            frontend:
              - 'frontend/**'
            backend:
              - 'backend/**'
            llm:
              - 'llm/**'

      - name: Show changes
        run: |
          echo "Frontend changed: ${{ steps.changes.outputs.frontend }}"
          echo "Backend changed: ${{ steps.changes.outputs.backend }}"
          echo "LLM changed: ${{ steps.changes.outputs.llm }}"

  # ğŸ§¹ NETTOYAGE PRÃ‰VENTIF - AVANT les builds pour Ã©viter la saturation
  preventive-cleanup:
    runs-on: ubuntu-latest
    needs: detect-changes
    # Se dÃ©clenche si n'importe quel composant a changÃ©
    if: needs.detect-changes.outputs.frontend-changed == 'true' || needs.detect-changes.outputs.backend-changed == 'true' || needs.detect-changes.outputs.llm-changed == 'true'
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DOCR_ACCESS_TOKEN }}

      - name: Preventive registry cleanup (keep 6 latest)
        run: |
          echo "ğŸ§¹ Preventive cleanup - keeping 6 latest images per repository..."
          
          for repo in intelia-frontend intelia-backend intelia-llm; do
            echo "Processing $repo..."
            
            # Obtenir TOUS les manifests avec timestamp, triÃ©s du plus ancien au plus rÃ©cent
            manifests_json=$(doctl registry repository list-manifests "$repo" --format Digest,UpdatedAt --output json 2>/dev/null || echo "[]")
            
            # VÃ©rifier si on a des manifests
            if [ "$manifests_json" = "[]" ] || [ -z "$manifests_json" ]; then
              echo "No manifests found for $repo, skipping..."
              continue
            fi
            
            # Compter les manifests
            manifest_count=$(echo "$manifests_json" | jq '. | length' 2>/dev/null || echo "0")
            echo "Found $manifest_count manifests in $repo"
            
            # Si on a plus de 6 manifests, supprimer les plus anciens
            if [ "$manifest_count" -gt 6 ]; then
              # Calculer combien supprimer
              to_delete=$((manifest_count - 6))
              echo "Need to delete $to_delete old manifests from $repo"
              
              # Trier par date (plus anciens en premier) et prendre les N premiers Ã  supprimer
              old_manifests=$(echo "$manifests_json" | jq -r 'sort_by(.updated_at) | .[0:'$to_delete'] | .[].digest' 2>/dev/null || echo "")
              
              # Supprimer les anciens manifests
              if [ -n "$old_manifests" ]; then
                echo "$old_manifests" | while IFS= read -r digest; do
                  if [ -n "$digest" ] && [ "$digest" != "null" ]; then
                    echo "Deleting old manifest: $digest"
                    doctl registry repository delete-manifest "$repo" "$digest" --force || echo "Failed to delete $digest"
                  fi
                done
              else
                echo "No old manifests to delete for $repo"
              fi
            else
              echo "Only $manifest_count manifests in $repo, no cleanup needed"
            fi
            
            echo "Finished processing $repo"
            echo "---"
          done
          
          echo "âœ… Preventive cleanup completed"

  # ğŸ¯ Build Frontend - SEULEMENT si changÃ©
  build-frontend:
    runs-on: ubuntu-latest
    needs: [detect-changes, preventive-cleanup]
    if: needs.detect-changes.outputs.frontend-changed == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DOCR
        uses: docker/login-action@v3
        with:
          registry: registry.digitalocean.com
          username: doctl
          password: ${{ secrets.DOCR_ACCESS_TOKEN }}

      - name: Build & push frontend (multi-stage optimized)
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          push: true
          tags: |
            registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-frontend:main-${{ github.sha }}
            registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-frontend:main
          # Cache multi-stage avec layers sÃ©parÃ©s
          cache-from: |
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-frontend:buildcache
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-frontend:main
          cache-to: type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-frontend:buildcache,mode=max
          build-args: |
            NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
            LLM_BACKEND_URL=${{ secrets.LLM_BACKEND_URL }}
            BUILDKIT_INLINE_CACHE=1

  # ğŸ¯ Build Backend - Multi-stage optimisÃ©
  build-backend:
    runs-on: ubuntu-latest
    needs: [detect-changes, preventive-cleanup]
    if: needs.detect-changes.outputs.backend-changed == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:buildx-stable-1
            network=host

      - name: Login to DOCR
        uses: docker/login-action@v3
        with:
          registry: registry.digitalocean.com
          username: doctl
          password: ${{ secrets.DOCR_ACCESS_TOKEN }}

      - name: Build & push backend (multi-stage with separated cache)
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          push: true
          tags: |
            registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:main-${{ github.sha }}
            registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:main
          # Cache multi-stage optimisÃ© avec layers sÃ©parÃ©s par stage
          cache-from: |
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:buildcache-system
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:buildcache-core
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:buildcache-ml
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:buildcache
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:main
          cache-to: |
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:buildcache-system,mode=max
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:buildcache-core,mode=max
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:buildcache-ml,mode=max
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-backend:buildcache,mode=max
          build-args: BUILDKIT_INLINE_CACHE=1
          # Optimisations BuildKit
          provenance: false
          sbom: false

  # ğŸ¯ Build LLM - SEULEMENT si changÃ©
  build-llm:
    runs-on: ubuntu-latest
    needs: [detect-changes, preventive-cleanup]
    if: needs.detect-changes.outputs.llm-changed == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DOCR
        uses: docker/login-action@v3
        with:
          registry: registry.digitalocean.com
          username: doctl
          password: ${{ secrets.DOCR_ACCESS_TOKEN }}

      - name: Build & push LLM
        uses: docker/build-push-action@v6
        with:
          context: ./llm
          push: true
          tags: |
            registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-llm:main-${{ github.sha }}
            registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-llm:main
          cache-from: |
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-llm:buildcache
            type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-llm:main
          cache-to: type=registry,ref=registry.digitalocean.com/${{ secrets.DOCR_NAME }}/intelia-llm:buildcache,mode=max
          build-args: BUILDKIT_INLINE_CACHE=1

  # ğŸ—‘ï¸ Garbage collection finale pour libÃ©rer l'espace
  final-garbage-collection:
    runs-on: ubuntu-latest
    needs: [build-frontend, build-backend, build-llm]
    # Se dÃ©clenche si au moins un build a rÃ©ussi
    if: always() && (needs.build-frontend.result == 'success' || needs.build-backend.result == 'success' || needs.build-llm.result == 'success')
    continue-on-error: true
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DOCR_ACCESS_TOKEN }}

      - name: Final cleanup and garbage collection
        run: |
          echo "ğŸ—‘ï¸ Final cleanup - ensuring exactly 6 images per repository..."
          
          # DeuxiÃ¨me pass de nettoyage pour s'assurer qu'on a exactement 6 images
          for repo in intelia-frontend intelia-backend intelia-llm; do
            echo "Final check for $repo..."
            
            manifests_json=$(doctl registry repository list-manifests "$repo" --format Digest,UpdatedAt --output json 2>/dev/null || echo "[]")
            
            if [ "$manifests_json" != "[]" ] && [ -n "$manifests_json" ]; then
              manifest_count=$(echo "$manifests_json" | jq '. | length' 2>/dev/null || echo "0")
              echo "Current count for $repo: $manifest_count"
              
              if [ "$manifest_count" -gt 6 ]; then
                to_delete=$((manifest_count - 6))
                echo "Final cleanup: deleting $to_delete extra manifests from $repo"
                
                old_manifests=$(echo "$manifests_json" | jq -r 'sort_by(.updated_at) | .[0:'$to_delete'] | .[].digest' 2>/dev/null || echo "")
                
                if [ -n "$old_manifests" ]; then
                  echo "$old_manifests" | while IFS= read -r digest; do
                    if [ -n "$digest" ] && [ "$digest" != "null" ]; then
                      echo "Final deletion: $digest"
                      doctl registry repository delete-manifest "$repo" "$digest" --force || true
                    fi
                  done
                fi
              fi
            fi
          done
          
          # Garbage collection pour libÃ©rer l'espace des manifests supprimÃ©s
          echo "ğŸ—‘ï¸ Starting garbage collection to free up space..."
          doctl registry garbage-collection start ${{ secrets.DOCR_NAME }} --force || echo "Garbage collection already running or failed"
          
          echo "âœ… Final cleanup and garbage collection completed"
          echo "ğŸ’¡ Registry space will be freed automatically in 5-30 minutes"

  # ğŸ“Š RÃ©sumÃ© final avec statistiques
  summary:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend, build-backend, build-llm, final-garbage-collection]
    if: always()
    steps:
      - name: Deployment Summary with Registry Stats
        run: |
          echo "ğŸš€ DEPLOYMENT SUMMARY"
          echo "===================="
          
          # Frontend
          if [[ "${{ needs.detect-changes.outputs.frontend-changed }}" == "true" ]]; then
            if [[ "${{ needs.build-frontend.result }}" == "success" ]]; then
              echo "âœ… Frontend: DEPLOYED (multi-stage optimized)"
            else
              echo "âŒ Frontend: FAILED"
            fi
          else
            echo "â¸ï¸ Frontend: SKIPPED (no changes)"
          fi
          
          # Backend  
          if [[ "${{ needs.detect-changes.outputs.backend-changed }}" == "true" ]]; then
            if [[ "${{ needs.build-backend.result }}" == "success" ]]; then
              echo "âœ… Backend: DEPLOYED (multi-stage with ML cache optimization)"
            else
              echo "âŒ Backend: FAILED" 
            fi
          else
            echo "â¸ï¸ Backend: SKIPPED (no changes)"
          fi
          
          # LLM
          if [[ "${{ needs.detect-changes.outputs.llm-changed }}" == "true" ]]; then
            if [[ "${{ needs.build-llm.result }}" == "success" ]]; then
              echo "âœ… LLM: DEPLOYED"
            else
              echo "âŒ LLM: FAILED" 
            fi
          else
            echo "â¸ï¸ LLM: SKIPPED (no changes)"
          fi
          
          echo ""
          echo "ğŸ“Š REGISTRY OPTIMIZATION"
          echo "========================"
          echo "ğŸ§¹ Preventive cleanup: EXECUTED before builds"
          echo "ğŸ—‘ï¸ Final garbage collection: TRIGGERED"
          echo "ğŸ“¦ Max images per repository: 6 (strictly enforced)"
          echo "ğŸ’¾ Space optimization: Multi-stage builds + separated cache layers"
          echo "â±ï¸ Expected export time reduction: 60-80%"