# -*- coding: utf-8 -*-
"""
query_preprocessor.py - Pr√©processeur de requ√™tes avec OpenAI
Version ENRICHIE avec d√©tection patterns calculatoires, temporels, √©conomiques
et am√©lioration de la d√©tection du sexe avec correspondance stricte
üü¢ CORRECTION: Ne plus √©craser "male, female" pour les comparaisons
üü¢ CORRECTION: Validation stricte des entit√©s invalides (breed et metric_type)
"""

import logging
import re
from openai import AsyncOpenAI
import json
from typing import Dict, Any, List, Optional

from .comparative_detector import ComparativeQueryDetector

logger = logging.getLogger(__name__)


class LocalEntityExtractor:
    """Extraction locale sans LLM pour requ√™tes simples"""

    BREED_PATTERNS = {
        r"(?:cobb|500)": "Cobb 500",
        r"(?:ross|308)": "Ross 308",
        r"(?:hubbard|ja87)": "Hubbard JA87",
    }

    METRIC_PATTERNS = {
        r"(?:poids|weight|masse)": "weight",
        r"(?:fcr|conversion|indice)": "fcr",
        r"(?:mortalit√©|mortality)": "mortality",
        r"(?:production|ponte)": "production",
    }

    def extract_entities(self, query: str) -> Dict[str, Any]:
        """Extraction rapide des entit√©s communes"""
        entities = {"sex": "as_hatched"}
        query_lower = query.lower()

        # Breed detection
        for pattern, breed in self.BREED_PATTERNS.items():
            if re.search(pattern, query_lower):
                entities["breed"] = breed
                break

        # Age detection - patterns multiples
        age_patterns = [
            r"(\d+)\s*jours?",
            r"(\d+)\s*j\b",
            r"√† \s+(\d+)\s*jours?",
            r"de\s+(\d+)\s*jours?",
        ]
        for pattern in age_patterns:
            age_match = re.search(pattern, query_lower)
            if age_match:
                entities["age_days"] = int(age_match.group(1))
                break

        # Metric detection
        for pattern, metric in self.METRIC_PATTERNS.items():
            if re.search(pattern, query_lower):
                entities["metric_type"] = metric
                break

        # Sex detection
        if re.search(r"\b(?:male|m√¢le|m)\b", query_lower):
            entities["sex"] = "male"
        elif re.search(r"\b(?:female|femelle|f)\b", query_lower):
            entities["sex"] = "female"

        return entities

    def is_extraction_sufficient(self, entities: Dict) -> bool:
        """V√©rifie si l'extraction locale est suffisante"""
        # Consid√©rer suffisant si on a breed + (age ou metric)
        has_breed = entities.get("breed") is not None
        has_age = entities.get("age_days") is not None
        has_metric = entities.get("metric_type") is not None

        return has_breed and (has_age or has_metric)


class QueryPreprocessor:
    """
    Pr√©processe les requ√™tes utilisateur avec :
    - Correction des fautes de frappe
    - Normalisation de la terminologie
    - Extraction des m√©tadonn√©es structur√©es
    - D√©tection des requ√™tes comparatives
    - D√©tection patterns calculatoires, temporels, optimisation, √©conomiques
    - Am√©lioration de la d√©tection du sexe avec correspondance stricte
    üü¢ CORRECTION: Protection des comparaisons de sexe
    üü¢ CORRECTION: Validation stricte des entit√©s invalides
    üü¢ CORRECTION: Gestion des √¢ges multiples
    üü¢ CORRECTION: Extraction des patterns avanc√©s (projection, poids cible)
    üü¢ CORRECTION: Dictionnaire m√©triques fran√ßaises √©tendu
    """

    # üü¢ NOUVEAU: Constantes pour valeurs invalides
    INVALID_BREED_VALUES = {"as_hatched", "as-hatched", "mixed", "none", "", "null"}
    INVALID_METRIC_VALUES = {
        "as_hatched",
        "as-hatched",
        "mixed",
        "none",
        "",
        "null",
        "male",
        "female",  # Confusion avec sex
    }

    # üü¢ NOUVEAU: Dictionnaire complet des m√©triques fran√ßaises
    FRENCH_METRICS = {
        # Gain de poids (ordre de sp√©cificit√© d√©croissant)
        "gain quotidien moyen": "average_daily_gain",
        "gain moyen quotidien": "average_daily_gain",
        "gain quotidien": "daily_weight_gain",
        "gain de poids quotidien": "daily_weight_gain",
        "gain journalier": "daily_weight_gain",
        "gmq": "average_daily_gain",
        "gmo": "average_daily_gain",
        "adg": "average_daily_gain",
        # Consommation alimentaire
        "consommation cumul√©e": "cumulative_feed_intake",
        "consommation cumulative": "cumulative_feed_intake",
        "consommation totale": "cumulative_feed_intake",
        "aliment total": "cumulative_feed_intake",
        "quantit√© totale d'aliment": "cumulative_feed_intake",
        "combien d'aliment": "cumulative_feed_intake",
        "quantit√© d'aliment": "cumulative_feed_intake",
        "pr√©voir aliment": "cumulative_feed_intake",
        "besoin en aliment": "cumulative_feed_intake",
        "consommation d'aliment": "feed_intake",
        "ingestion": "feed_intake",
        # Conversion alimentaire
        "indice de consommation": "feed_conversion_ratio",
        "indice de conversion": "feed_conversion_ratio",
        "conversion alimentaire": "feed_conversion_ratio",
        "taux de conversion": "feed_conversion_ratio",
        "ic": "feed_conversion_ratio",
        "fcr": "feed_conversion_ratio",
        # Poids
        "poids vif": "body_weight",
        "poids corporel": "body_weight",
        "masse corporelle": "body_weight",
        "poids": "body_weight",
        "weight": "body_weight",
        # Mortalit√©
        "taux de mortalit√©": "mortality",
        "mortalit√©": "mortality",
        "mortality": "mortality",
        "pertes": "mortality",
        "d√©c√®s": "mortality",
        # Production (pondeuses)
        "taux de ponte": "egg_production",
        "production d'≈ìufs": "egg_production",
        "production": "egg_production",
        "ponte": "egg_production",
        # Efficacit√©
        "efficacit√© alimentaire": "feed_efficiency",
        "efficience alimentaire": "feed_efficiency",
        "rendement": "feed_efficiency",
    }

    # üü¢ NOUVEAU: Patterns pour extraction avanc√©e
    PROJECTION_PATTERNS = [
        r"si (?:je|on) pars? (?:de|d\') (\d+)",
        r"en partant de (\d+)",
        r"√† partir de (\d+)",
        r"starting from (\d+)",
        r"from age (\d+)",
    ]

    WEIGHT_PATTERNS = [
        r"√† (\d+\.?\d*)\s*kg",
        r"√† (\d+)\s*grammes?",
        r"(\d+\.?\d*)\s*kg",
        r"(\d+)\s*g\b",
        r"at (\d+\.?\d*)\s*kg",
        r"at (\d+)\s*grams?",
    ]

    def __init__(self, openai_client: AsyncOpenAI):
        self.client = openai_client
        self._is_initialized = False
        self.comparative_detector = ComparativeQueryDetector()
        self.local_extractor = LocalEntityExtractor()
        self._cache = {}  # Cache pour √©viter reprocessing

    async def initialize(self):
        """Initialisation et validation du preprocessor"""
        if not self.client:
            raise ValueError("OpenAI client is required for QueryPreprocessor")

        try:
            logger.info(
                "Initialisation du Query Preprocessor avec d√©tection enrichie..."
            )
            self._is_initialized = True
            logger.info("Query Preprocessor initialis√© avec succ√®s")
            return self
        except Exception as e:
            logger.error(f"Erreur initialisation QueryPreprocessor: {e}")
            raise

    async def close(self):
        """Fermeture propre du preprocessor"""
        self._is_initialized = False
        self._cache.clear()  # Nettoyer le cache
        logger.debug("Query Preprocessor ferm√©")

    def extract_local_entities(self, query: str) -> Dict[str, Any]:
        """Extraction d'entit√©s avec d√©tection de sexe explicite am√©lior√©e"""

        entities = {}

        # Extraction du sexe avec d√©tection explicite
        sex_info = self._extract_sex_with_explicit_detection(query)
        entities.update(sex_info)

        # Extraction de la race
        breed = self._extract_breed(query)
        if breed:
            entities["breed"] = breed

        # Extraction de l'√¢ge
        age = self._extract_age_days(query)
        if age:
            entities["age_days"] = age

        # Extraction du type de m√©trique
        metric_type = self._extract_metric_type(query)
        if metric_type:
            entities["metric_type"] = metric_type

        return entities

    def _extract_sex_with_explicit_detection(self, query: str) -> Dict[str, Any]:
        """Extraction du sexe avec d√©tection des demandes explicites"""

        result = {}
        query_lower = query.lower()

        # Patterns pour d√©tection explicite
        explicit_female_patterns = [
            r"\bfemelle\b",
            r"\bfemale\b",
            r"\bpoule\b",
            r"\bpoulette\b",
        ]
        explicit_male_patterns = [r"\bm√¢le\b", r"\bmale\b", r"\bcoq\b", r"\bcockerel\b"]

        # V√©rification des patterns explicites
        is_explicit_female = any(
            re.search(pattern, query_lower) for pattern in explicit_female_patterns
        )
        is_explicit_male = any(
            re.search(pattern, query_lower) for pattern in explicit_male_patterns
        )

        if is_explicit_female:
            result["sex"] = "female"
            result["explicit_sex_request"] = True
            logger.debug(f"Sexe femelle d√©tect√© explicitement dans: {query}")
        elif is_explicit_male:
            result["sex"] = "male"
            result["explicit_sex_request"] = True
            logger.debug(f"Sexe m√¢le d√©tect√© explicitement dans: {query}")
        else:
            # Patterns implicites plus faibles
            if re.search(r"\bof?\s+female\b|\bfemelle?\b", query_lower):
                result["sex"] = "female"
                result["explicit_sex_request"] = False
            elif re.search(r"\bof?\s+male\b|\bm√¢le?\b", query_lower):
                result["sex"] = "male"
                result["explicit_sex_request"] = False
            else:
                result["sex"] = "as_hatched"
                result["explicit_sex_request"] = False

        return result

    def _extract_breed(self, query: str) -> Optional[str]:
        """Extraction de la race/souche"""
        query_lower = query.lower()

        for pattern, breed in self.local_extractor.BREED_PATTERNS.items():
            if re.search(pattern, query_lower):
                return breed
        return None

    def _extract_age_days(self, query: str) -> Optional[int]:
        """Extraction de l'√¢ge en jours"""
        query_lower = query.lower()

        age_patterns = [
            r"(\d+)\s*jours?",
            r"(\d+)\s*j\b",
            r"√† \s+(\d+)\s*jours?",
            r"de\s+(\d+)\s*jours?",
            r"day\s+(\d+)",
            r"(\d+)\s+days?",
        ]

        for pattern in age_patterns:
            age_match = re.search(pattern, query_lower)
            if age_match:
                try:
                    age = int(age_match.group(1))
                    if 0 <= age <= 150:  # Validation range
                        return age
                except ValueError:
                    continue
        return None

    def _extract_metric_type(self, query: str) -> Optional[str]:
        """Extraction du type de m√©trique"""
        query_lower = query.lower()

        for pattern, metric in self.local_extractor.METRIC_PATTERNS.items():
            if re.search(pattern, query_lower):
                return metric
        return None

    async def preprocess_query(
        self, query: str, language: str = "fr"
    ) -> Dict[str, Any]:
        """
        AM√âLIOR√â: Preprocessing avec cache, extraction locale et classification am√©lior√©e
        avec gestion des demandes strictes et validation des entit√©s invalides

        Returns:
            {
                "normalized_query": str,
                "query_type": str,
                "entities": Dict,
                "routing": str,
                "confidence": float,
                "is_comparative": bool,
                "is_temporal_range": bool,
                "comparative_info": Dict,
                "requires_calculation": bool,
                "comparison_entities": List[Dict],
                "query_patterns": Dict,
                "strict_requirements": Dict
            }
        """

        # Cache check
        if query in self._cache:
            logger.debug(f"Cache hit pour: {query}")
            return self._cache[query]

        # Stocker la requ√™te pour utilisation dans les corrections
        self._current_query = query

        try:
            # 1. Classification d√©taill√©e du type de requ√™te (priorit√© haute)
            detailed_query_type = self._classify_detailed_query_type(query)
            logger.debug(f"Type de requ√™te classifi√©: {detailed_query_type}")

            # 2. Essayer extraction locale d'abord (rapide) - NOUVELLE VERSION
            local_entities = self.extract_local_entities(query)
            logger.debug(f"Entit√©s locales extraites: {local_entities}")

            # 3. D√©tection comparative (bas√©e sur la classification)
            comparative_info = self.comparative_detector.detect(query)
            # Override si classification d√©tecte comparaison
            if detailed_query_type == "comparative":
                comparative_info["is_comparative"] = True
                comparative_info["type"] = "comparative_detected"
            logger.debug(f"D√©tection comparative: {comparative_info}")

            # 4. D√©tection des patterns sp√©ciaux
            query_patterns = self._detect_query_patterns(query)
            logger.debug(f"Patterns d√©tect√©s: {query_patterns}")

            # 5. NOUVEAU: Analyser les demandes strictes
            strict_requirements = self._analyze_strict_requirements(
                query, local_entities
            )
            logger.debug(f"Exigences strictes: {strict_requirements}")

            # 6. Si extraction locale suffisante ET requ√™te simple, utiliser directement
            if (
                self.local_extractor.is_extraction_sufficient(local_entities)
                and detailed_query_type in ["standard", "metric"]
                and not comparative_info["is_comparative"]
            ):

                logger.info(f"Utilisation extraction locale pour: {query}")
                result = self._build_local_result(
                    query,
                    local_entities,
                    query_patterns,
                    comparative_info,
                    detailed_query_type,
                    strict_requirements,
                )
                self._cache[query] = result
                return result

            # 7. Sinon, utiliser OpenAI pour cas complexes
            system_prompt = self._get_system_prompt(
                language, comparative_info["is_comparative"]
            )

            try:
                response = await self.client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": query},
                    ],
                    temperature=0.1,
                    max_tokens=300,
                    response_format={"type": "json_object"},
                )

                result = json.loads(response.choices[0].message.content)

                # Validation
                if "normalized_query" not in result:
                    logger.warning(
                        "Preprocessing incomplet, utilisation query originale"
                    )
                    result["normalized_query"] = query

                if "entities" not in result:
                    result["entities"] = {}

                # Post-traitement intelligent
                enhanced_result = self._enhance_openai_result(
                    result, query, comparative_info
                )

            except Exception as e:
                logger.warning(f"OpenAI normalization failed: {e}")
                enhanced_result = self._fallback_preprocessing(
                    query, comparative_info, query_patterns, strict_requirements
                )

            # 8. üü¢ CORRECTION: Validation et correction des entit√©s avec filtrage des valeurs invalides
            enhanced_result["entities"] = self._validate_and_fix_entities(
                enhanced_result["entities"],
                is_comparative=comparative_info.get("is_comparative", False),
            )
            logger.debug(f"Entit√©s apr√®s validation: {enhanced_result['entities']}")

            # 8a. üü¢ NOUVEAU: D√©tection am√©lior√©e des m√©triques fran√ßaises
            enhanced_result["entities"] = self._enhance_metric_detection(
                query, enhanced_result["entities"]
            )
            logger.debug(
                f"Entit√©s apr√®s d√©tection m√©triques: {enhanced_result['entities']}"
            )

            # 8b. üü¢ NOUVEAU: Extraction des patterns avanc√©s
            enhanced_result["entities"] = self._extract_advanced_patterns(
                query, enhanced_result["entities"]
            )
            logger.debug(
                f"Entit√©s apr√®s patterns avanc√©s: {enhanced_result['entities']}"
            )

            # 9. Enrichir avec les informations de classification
            enhanced_result["query_type"] = detailed_query_type
            enhanced_result["routing"] = self._determine_routing(
                detailed_query_type, enhanced_result.get("routing")
            )
            enhanced_result["is_comparative"] = comparative_info["is_comparative"]
            enhanced_result["is_temporal_range"] = (
                detailed_query_type == "temporal_range"
            )
            enhanced_result["comparative_info"] = comparative_info
            enhanced_result["requires_calculation"] = (
                comparative_info["is_comparative"]
                or detailed_query_type == "temporal_range"
            )

            # 10. Ajouter les patterns d√©tect√©s et les exigences strictes
            enhanced_result["query_patterns"] = query_patterns
            enhanced_result["strict_requirements"] = strict_requirements

            # 11. Si comparaison d√©tect√©e, cr√©er les entit√©s multiples
            if comparative_info["is_comparative"]:
                enhanced_result["comparison_entities"] = (
                    self._build_comparison_entities(
                        comparative_info, enhanced_result["entities"]
                    )
                )
                logger.info(
                    f"Requ√™te comparative d√©tect√©e: {comparative_info['type']}, "
                    f"{len(enhanced_result['comparison_entities'])} jeux d'entit√©s √† rechercher"
                )
            else:
                # üü¢ NOUVEAU: M√™me pour les non-comparatives, essayer le split automatique
                enhanced_result["comparison_entities"] = (
                    self._build_comparison_entities_from_base(
                        enhanced_result["entities"]
                    )
                )
                if len(enhanced_result["comparison_entities"]) > 1:
                    logger.info(
                        f"Split automatique d√©tect√©: {len(enhanced_result['comparison_entities'])} entit√©s"
                    )

            # 12. Cache du r√©sultat
            self._cache[query] = enhanced_result

            logger.info(
                f"Query preprocessed: '{query}' -> '{enhanced_result['normalized_query']}' (type: {detailed_query_type})"
            )
            logger.debug(f"Routing suggestion: {enhanced_result.get('routing')}")
            logger.debug(f"Entities detected: {enhanced_result['entities']}")
            logger.debug(f"Patterns: {query_patterns}")

            return enhanced_result

        except json.JSONDecodeError as e:
            logger.error(f"Erreur parsing JSON OpenAI: {e}")
            return self._fallback_preprocessing(
                query, comparative_info, query_patterns, strict_requirements
            )

        except Exception as e:
            logger.error(f"Erreur preprocessing OpenAI: {e}")
            return self._fallback_preprocessing(
                query, comparative_info, query_patterns, strict_requirements
            )
        finally:
            # Nettoyer la variable temporaire
            self._current_query = ""

    def _analyze_strict_requirements(
        self, query: str, entities: Dict[str, Any]
    ) -> Dict[str, bool]:
        """Analyse si la requ√™te n√©cessite des correspondances strictes"""

        strict_requirements = {
            "strict_sex_match": False,
            "strict_age_match": False,
            "strict_breed_match": False,
            "exclude_imperial_units": True,  # Par d√©faut, exclure les unit√©s imp√©riales
        }

        # D√©tection de demande de sexe stricte
        if entities.get("explicit_sex_request", False):
            strict_requirements["strict_sex_match"] = True
            logger.debug("Demande de correspondance sexe stricte d√©tect√©e")

        # Mots-cl√©s indiquant une demande pr√©cise
        precision_keywords = [
            "exactement",
            "pr√©cis√©ment",
            "sp√©cifiquement",
            "uniquement",
            "seulement",
            "exactly",
            "specifically",
            "only",
            "precisely",
        ]

        query_lower = query.lower()
        if any(keyword in query_lower for keyword in precision_keywords):
            strict_requirements.update(
                {
                    "strict_sex_match": True,
                    "strict_age_match": True,
                    "strict_breed_match": True,
                }
            )
            logger.debug("Demande de correspondance stricte d√©tect√©e via mots-cl√©s")

        # D√©tection d'√¢ge pr√©cis (ex: "√† 28 jours" vs "vers 28 jours")
        precise_age_patterns = [
            r"√† \s+(\d+)\s+jours?",
            r"at\s+(\d+)\s+days?",
            r"day\s+(\d+)",
            r"jour\s+(\d+)",
        ]

        if any(re.search(pattern, query_lower) for pattern in precise_age_patterns):
            strict_requirements["strict_age_match"] = True
            logger.debug("Demande d'√¢ge pr√©cis d√©tect√©e")

        return strict_requirements

    def _normalize_query_text(self, query: str) -> str:
        """Normalise le texte de la requ√™te"""

        # Corrections orthographiques communes
        corrections = {
            "IC": "conversion alimentaire",
            "FCR": "conversion alimentaire",
            "poid": "poids",
            "convertion": "conversion",
            "aliment": "alimentaire",
        }

        normalized = query
        for wrong, correct in corrections.items():
            normalized = re.sub(
                rf"\b{re.escape(wrong)}\b", correct, normalized, flags=re.IGNORECASE
            )

        # Nettoyage basique
        normalized = re.sub(r"\s+", " ", normalized).strip()

        return normalized

    def should_use_strict_matching(self, preprocessing_result: Dict[str, Any]) -> bool:
        """D√©termine si les requ√™tes doivent utiliser la correspondance stricte"""

        strict_reqs = preprocessing_result.get("strict_requirements", {})

        # Si une demande stricte est d√©tect√©e
        if any(strict_reqs.values()):
            return True

        # Si c'est une requ√™te comparative, moins strict par d√©faut
        if preprocessing_result.get("comparative_info", {}).get(
            "is_comparative", False
        ):
            return False

        # Par d√©faut, mod√©r√©ment strict
        return preprocessing_result.get("entities", {}).get(
            "explicit_sex_request", False
        )

    # ========================================================================
    # M√âTHODE MODIFI√âE: Classification d√©taill√©e des requ√™tes
    # ========================================================================

    def _classify_detailed_query_type(self, query: str) -> str:
        """
        Classification d√©taill√©e des types de requ√™tes avec priorit√© hi√©rarchique
        MODIFICATION: "meilleur" d√©plac√© vers optimization au lieu de comparative

        Returns:
            - "temporal_range": requ√™tes d'√©volution temporelle (entre X et Y jours)
            - "comparative": requ√™tes de comparaison (vs, diff√©rence explicite)
            - "recommendation": requ√™tes de conseil/recommandation
            - "calculation": requ√™tes de calcul/projection
            - "optimization": requ√™tes d'optimisation (inclut "meilleur")
            - "standard": requ√™tes m√©triques simples
            - "document": requ√™tes documentaires/explicatives
            - "general": requ√™tes g√©n√©rales
        """
        query_lower = query.lower()

        # 1. PRIORIT√â HAUTE: Requ√™tes temporelles (√©volution dans le temps)
        temporal_patterns = [
            r"√©volu\w*",  # √©volution, √©volue
            r"entre\s+\d+\s+et\s+\d+",  # "entre 21 et 42 jours"
            r"de\s+\d+\s+√†\s+\d+",  # "de 21 √† 42 jours"
            r"from\s+\d+\s+to\s+\d+",  # "from 21 to 42 days"
            r"progression",  # progression
            r"courbe",  # courbe de croissance
            r"suivi",  # suivi dans le temps
        ]
        if any(re.search(pattern, query_lower) for pattern in temporal_patterns):
            return "temporal_range"

        # 2. PRIORIT√â HAUTE: Requ√™tes comparatives (mots-cl√©s EXPLICITES uniquement)
        # MODIFICATION: Retrait de "meilleur" qui est une requ√™te d'optimization
        comparative_patterns = [
            r"\bdiff√©rence\b",  # diff√©rence
            r"\bcompare\w*\b",  # compare, comparaison
            r"\bversus\b|\bvs\b",  # versus, vs
            r"\bentre\s+\w+\s+et\s+\w+\b",  # "entre Cobb et Ross"
            r"\bmieux\b",  # mieux
            r"\bplus\s+\w+\s+que\b",  # "plus lourd que"
            r"\bmoins\s+\w+\s+que\b",  # "moins que"
        ]
        if any(re.search(pattern, query_lower) for pattern in comparative_patterns):
            return "comparative"

        # 3. Requ√™tes de recommandation/conseil
        recommendation_patterns = [
            r"\brecommande\w*\b",  # recommande, recommandation
            r"\bconseil\w*\b",  # conseil, conseille
            r"\bsugg√®re\w*\b",  # sugg√®re, suggestion
            r"\bchoisir\b",  # choisir
            r"\bquel\w*\s+\w+\s+choisir\b",  # "quelle souche choisir"
            r"\bque\s+me\s+\w+\b",  # "que me conseillez"
        ]
        if any(re.search(pattern, query_lower) for pattern in recommendation_patterns):
            return "recommendation"

        # 4. Requ√™tes de calcul/projection
        calculation_patterns = [
            r"\bcalcul\w*\b",  # calcul, calculer
            r"\bprojection\b",  # projection
            r"\bprojette\w*\b",  # projette
            r"\bestim\w*\b",  # estime, estimation
            r"\btotal\w*\b",  # total, totaux
            r"\bsomme\b",  # somme
            r"\bcombien\b",  # combien
        ]
        if any(re.search(pattern, query_lower) for pattern in calculation_patterns):
            return "calculation"

        # 5. Requ√™tes d'optimisation
        # MODIFICATION: Ajout de "meilleur", "choisir", "recommande"
        optimization_patterns = [
            r"\boptimal\w*\b",  # optimal, optimiser
            r"\bid√©al\w*\b",  # id√©al, id√©ale
            r"\bmeilleur\w*\b",  # meilleur, meilleure (D√âPLAC√â ICI)
            r"\bchoisir\b",  # choisir (AJOUT√â)
            r"\brecommande\w*\b",  # recommande (AJOUT√â pour renforcer)
            r"\bperfect\w*\b",  # perfect, perfection
            r"\bmaximis\w*\b",  # maximiser
            r"\bminimiis\w*\b",  # minimiser
            r"\bam√©liorer\b",  # am√©liorer
        ]
        if any(re.search(pattern, query_lower) for pattern in optimization_patterns):
            return "optimization"

        # 6. Requ√™tes documentaires/explicatives
        document_patterns = [
            r"\bcomment\b",  # comment
            r"\bpourquoi\b",  # pourquoi
            r"\bexplique\w*\b",  # explique, explication
            r"\bqu'?est-ce\s+que\b",  # qu'est-ce que
            r"\bmaladie\w*\b",  # maladie, maladies
            r"\bsympt√¥me\w*\b",  # sympt√¥me, sympt√¥mes
            r"\btraitement\w*\b",  # traitement
            r"\bguide\b",  # guide
            r"\bproc√©dure\w*\b",  # proc√©dure
        ]
        if any(re.search(pattern, query_lower) for pattern in document_patterns):
            return "document"

        # 7. Requ√™tes m√©triques standard (avec entit√©s sp√©cifiques)
        metric_patterns = [
            r"\b(?:poids|weight|fcr|conversion|mortalit√©|mortality)\b",
            r"\b(?:cobb|ross|hubbard)\b",  # Breeds mentionn√©es
            r"\b\d+\s*(?:jours?|days?|j)\b",  # √Çges mentionn√©s
        ]
        if any(re.search(pattern, query_lower) for pattern in metric_patterns):
            return "standard"

        # 8. Par d√©faut: requ√™te g√©n√©rale
        return "general"

    def _determine_routing(
        self, query_type: str, existing_routing: Optional[str] = None
    ) -> str:
        """
        D√©termine le routage optimal bas√© sur le type de requ√™te classifi√©
        """
        # Si un routage existe d√©j√† et semble appropri√©, le conserver
        if existing_routing in ["postgresql", "weaviate"]:
            return existing_routing

        # Routage bas√© sur la classification
        routing_map = {
            "temporal_range": "postgresql",  # Donn√©es temporelles ‚Üí DB
            "comparative": "postgresql",  # Comparaisons ‚Üí DB
            "recommendation": "postgresql",  # Recommandations bas√©es sur donn√©es
            "calculation": "postgresql",  # Calculs ‚Üí DB
            "optimization": "postgresql",  # Optimisation ‚Üí DB
            "standard": "postgresql",  # M√©triques ‚Üí DB
            "document": "weaviate",  # Documents ‚Üí Vector DB
            "general": "weaviate",  # G√©n√©ral ‚Üí Vector DB
        }

        return routing_map.get(query_type, "postgresql")  # PostgreSQL par d√©faut

    # ========================================================================
    # M√âTHODE MISE √Ä JOUR: Construction de r√©sultat local
    # ========================================================================

    def _build_local_result(
        self,
        query: str,
        local_entities: Dict,
        query_patterns: Dict,
        comparative_info: Dict,
        query_type: str,
        strict_requirements: Dict,
    ) -> Dict[str, Any]:
        """
        Construit un r√©sultat complet √† partir de l'extraction locale avec classification
        üü¢ AM√âLIOR√â: Inclut extraction des patterns avanc√©s et m√©triques fran√ßaises
        """
        # Validation et enrichissement des entit√©s locales
        validated_entities = self._validate_and_fix_entities(
            local_entities, is_comparative=comparative_info.get("is_comparative", False)
        )

        # üü¢ NOUVEAU: D√©tection am√©lior√©e des m√©triques fran√ßaises
        validated_entities = self._enhance_metric_detection(query, validated_entities)

        # üü¢ NOUVEAU: Extraction des patterns avanc√©s
        validated_entities = self._extract_advanced_patterns(query, validated_entities)

        # Routage intelligent bas√© sur le type de requ√™te
        routing = self._determine_routing(query_type)

        # Normalisation du texte de la requ√™te
        normalized_query = self._normalize_query_text(query)

        # üü¢ NOUVEAU: Construire les entit√©s de comparaison
        if comparative_info["is_comparative"]:
            comparison_entities = self._build_comparison_entities(
                comparative_info, validated_entities
            )
        else:
            comparison_entities = self._build_comparison_entities_from_base(
                validated_entities
            )

        return {
            "normalized_query": normalized_query,
            "query_type": query_type,
            "entities": validated_entities,
            "routing": routing,
            "confidence": 0.8,  # Confiance √©lev√©e pour extraction locale r√©ussie
            "is_comparative": comparative_info["is_comparative"]
            or query_type == "comparative",
            "is_temporal_range": query_type == "temporal_range",
            "comparative_info": comparative_info,
            "requires_calculation": (
                comparative_info["is_comparative"]
                or query_type in ["temporal_range", "calculation", "comparative"]
            ),
            "comparison_entities": comparison_entities,
            "query_patterns": query_patterns,
            "strict_requirements": strict_requirements,
            "preprocessing_method": "local_extraction",
            "processing_time_saved": True,
        }

    # ========================================================================
    # NOUVELLES M√âTHODES: Post-traitement et enrichissement
    # ========================================================================

    def _enhance_openai_result(
        self, openai_result: Dict, original_query: str, comparative_info: Dict
    ) -> Dict:
        """
        NOUVEAU: Post-traitement pour enrichir le r√©sultat OpenAI
        """
        enhanced = openai_result.copy()

        # Enrichir pour requ√™tes de recommandation
        if any(
            word in original_query.lower()
            for word in ["meilleur", "recommande", "conseil"]
        ):
            if not enhanced.get("entities", {}).get("breed"):
                # Sugg√©rer breeds populaires pour recommandations
                enhanced.setdefault("entities", {})[
                    "breed"
                ] = "Cobb 500, Ross 308, Hubbard JA87"
                enhanced["query_type"] = "recommendation"

        # Enrichir pour requ√™tes de comparaison
        if comparative_info["is_comparative"] and not enhanced.get("entities", {}).get(
            "breed"
        ):
            # Pour les comparaisons sans breed sp√©cifique
            enhanced.setdefault("entities", {})["breed"] = "Cobb 500, Ross 308"
            enhanced["routing"] = "postgresql"  # Forcer PostgreSQL pour comparaisons

        # Enrichir le routage
        if not enhanced.get("routing"):
            # Routage intelligent bas√© sur le contenu
            if any(
                word in original_query.lower()
                for word in ["poids", "fcr", "conversion", "mortalit√©", "production"]
            ):
                enhanced["routing"] = "postgresql"
            elif any(
                word in original_query.lower()
                for word in ["comment", "pourquoi", "explique", "maladie"]
            ):
                enhanced["routing"] = "weaviate"
            else:
                # D√©faut: PostgreSQL pour donn√©es num√©riques
                enhanced["routing"] = "postgresql"

        return enhanced

    # ========================================================================
    # üü¢ M√âTHODE CORRIG√âE: Validation des entit√©s avec filtrage des valeurs invalides
    # ========================================================================

    def _validate_and_fix_entities(
        self, entities: Dict[str, Any], is_comparative: bool = False
    ) -> Dict[str, Any]:
        """
        üü¢ CORRECTION CRITIQUE:
        1. Ne pas √©craser les valeurs multiples pour les comparaisons
        2. Filtrer les valeurs invalides pour breed et metric_type
        3. G√©rer age_days comme string, int ou liste

        Args:
            entities: Entit√©s √† valider
            is_comparative: True si c'est une requ√™te comparative

        Returns:
            Entit√©s valid√©es
        """
        if not entities:
            entities = {}

        corrected = {}
        corrections_applied = []

        # ========================================================================
        # üü¢ VALIDATION BREED - FILTRAGE DES VALEURS INVALIDES
        # ========================================================================
        breed_value = entities.get("breed")

        if breed_value:
            breed_str = str(breed_value).strip()
            breed_lower = breed_str.lower()

            # V√©rifier si c'est une valeur invalide
            if breed_lower in self.INVALID_BREED_VALUES:
                logger.warning(f"‚ùå Breed invalide d√©tect√©: '{breed_value}' ‚Üí None")
                corrected["breed"] = None
                corrections_applied.append(
                    f"breed '{breed_value}' ‚Üí None (valeur invalide)"
                )
            else:
                # Valeur valide, la conserver
                corrected["breed"] = breed_str
        else:
            # NOUVEAU: Pour requ√™tes g√©n√©rales, sugg√©rer breeds populaires
            query_context = getattr(self, "_current_query", "").lower()
            if any(
                word in query_context
                for word in ["meilleur", "recommande", "compare", "diff√©rence"]
            ):
                # Pour requ√™tes comparatives/recommandations, sugg√©rer plusieurs races
                corrected["breed"] = "Cobb 500, Ross 308"  # Breeds les plus populaires
                corrections_applied.append("breed sugg√©r√© pour requ√™te g√©n√©rale")
            else:
                corrected["breed"] = None

        # ========================================================================
        # üü¢ VALIDATION METRIC_TYPE - FILTRAGE DES VALEURS INVALIDES
        # ========================================================================
        metric_value = entities.get("metric_type")

        if metric_value:
            metric_str = str(metric_value).strip()
            metric_lower = metric_str.lower()

            # V√©rifier si c'est une valeur invalide
            if metric_lower in self.INVALID_METRIC_VALUES:
                logger.warning(
                    f"‚ùå metric_type invalide d√©tect√©: '{metric_value}' ‚Üí None"
                )
                corrected["metric_type"] = None
                corrections_applied.append(
                    f"metric_type '{metric_value}' ‚Üí None (valeur invalide)"
                )
            else:
                # üü¢ AM√âLIOR√â: Normaliser avec le dictionnaire fran√ßais √©tendu
                # D'abord essayer le dictionnaire fran√ßais
                normalized = None
                for french_term, english_metric in self.FRENCH_METRICS.items():
                    if french_term == metric_lower or french_term in metric_lower:
                        normalized = english_metric
                        break

                # Si pas trouv√©, utiliser le mapping basique
                if not normalized:
                    metric_mapping = {
                        "poids": "body_weight",
                        "weight": "body_weight",
                        "masse": "body_weight",
                        "fcr": "feed_conversion_ratio",
                        "conversion": "feed_conversion_ratio",
                        "ic": "feed_conversion_ratio",
                        "indice": "feed_conversion_ratio",
                        "mortalit√©": "mortality",
                        "mortality": "mortality",
                        "production": "egg_production",
                        "ponte": "egg_production",
                        "≈ìuf": "egg_production",
                        "alimentation": "feed_intake",
                        "feed": "feed_intake",
                    }
                    normalized = metric_mapping.get(metric_lower, metric_str)

                corrected["metric_type"] = normalized
                if normalized != metric_str:
                    corrections_applied.append(
                        f"metric_type '{metric_str}' ‚Üí '{normalized}'"
                    )
        else:
            # NOUVEAU: D√©tecter m√©trique depuis le contexte de la requ√™te
            query_context = getattr(self, "_current_query", "").lower()
            if any(word in query_context for word in ["poids", "weight", "masse"]):
                corrected["metric_type"] = "body_weight"
                corrections_applied.append("metric_type d√©tect√©: body_weight")
            elif any(word in query_context for word in ["fcr", "conversion", "indice"]):
                corrected["metric_type"] = "feed_conversion_ratio"
                corrections_applied.append("metric_type d√©tect√©: feed_conversion_ratio")
            elif any(word in query_context for word in ["mortalit√©", "mortality"]):
                corrected["metric_type"] = "mortality"
                corrections_applied.append("metric_type d√©tect√©: mortality")
            else:
                corrected["metric_type"] = None

        # ========================================================================
        # VALIDATION SEX
        # ========================================================================
        sex_value = entities.get("sex")

        if is_comparative and isinstance(sex_value, str) and "," in sex_value:
            # GARDER les valeurs multiples pour les comparaisons
            corrected["sex"] = sex_value
            logger.debug(f"‚úÖ Comparaison de sexe pr√©serv√©e: {sex_value}")
        elif sex_value is None or str(sex_value).lower() == "none":
            corrected["sex"] = "as_hatched"
            corrections_applied.append("sex 'None' ‚Üí 'as_hatched'")
        else:
            # Normaliser les valeurs de sexe simples
            sex_lower = str(sex_value).lower()
            if sex_lower in ["m", "male", "m√¢le", "males"]:
                corrected["sex"] = "male"
            elif sex_lower in ["f", "female", "femelle", "females"]:
                corrected["sex"] = "female"
            elif sex_lower in ["as_hatched", "as-hatched", "mixed", "mixte"]:
                corrected["sex"] = "as_hatched"
            else:
                corrected["sex"] = "as_hatched"
                corrections_applied.append(f"sex '{sex_value}' ‚Üí 'as_hatched'")

        # Pr√©server l'information explicit_sex_request si elle existe
        if entities.get("explicit_sex_request") is not None:
            corrected["explicit_sex_request"] = entities["explicit_sex_request"]

        # ========================================================================
        # üü¢ VALIDATION AGE_DAYS - GESTION DES √ÇGES MULTIPLES
        # ========================================================================
        if entities.get("age_days"):
            age_val = entities["age_days"]

            # Si string avec virgule (ex: "28, 35")
            if isinstance(age_val, str):
                if age_val.lower() in ["as_hatched", "none"]:
                    corrected["age_days"] = None
                    corrected["is_age_range"] = False
                    corrections_applied.append(f"age_days '{age_val}' ‚Üí None")
                elif "," in age_val:
                    try:
                        ages = [int(x.strip()) for x in age_val.split(",")]
                        corrected["age_days"] = ages
                        corrected["is_age_range"] = True
                        corrections_applied.append(f"‚úÖ Plage d'√¢ges d√©tect√©e: {ages}")
                        logger.debug(f"‚úÖ Plage d'√¢ges d√©tect√©e: {ages}")
                    except ValueError:
                        logger.warning(f"‚ö†Ô∏è Impossible de parser age_days: '{age_val}'")
                        corrected["age_days"] = None
                        corrected["is_age_range"] = False
                        corrections_applied.append(
                            f"age_days '{age_val}' ‚Üí None (parse error)"
                        )
                else:
                    try:
                        corrected["age_days"] = int(age_val)
                        corrected["is_age_range"] = False
                    except (ValueError, TypeError):
                        corrected["age_days"] = None
                        corrected["is_age_range"] = False
                        corrections_applied.append(
                            f"age_days '{age_val}' ‚Üí None (invalid)"
                        )

            # Si d√©j√† une liste
            elif isinstance(age_val, list):
                try:
                    corrected["age_days"] = [int(x) for x in age_val]
                    corrected["is_age_range"] = True
                    logger.debug(f"‚úÖ Liste d'√¢ges pr√©serv√©e: {corrected['age_days']}")
                except (ValueError, TypeError):
                    corrected["age_days"] = None
                    corrected["is_age_range"] = False
                    corrections_applied.append("age_days list invalid ‚Üí None")

            # Si entier
            else:
                try:
                    corrected["age_days"] = int(age_val)
                    corrected["is_age_range"] = False
                except (ValueError, TypeError):
                    corrected["age_days"] = None
                    corrected["is_age_range"] = False
                    corrections_applied.append(f"age_days '{age_val}' ‚Üí None (invalid)")
        else:
            # NOUVEAU: Suggestion d'√¢ge pour certains contextes
            query_context = getattr(self, "_current_query", "").lower()
            if any(word in query_context for word in ["abattage", "finition", "final"]):
                corrected["age_days"] = 42  # √Çge d'abattage standard
                corrected["is_age_range"] = False
                corrections_applied.append("age_days sugg√©r√© (42j pour finition)")
            elif any(
                word in query_context for word in ["d√©marrage", "starter", "d√©but"]
            ):
                corrected["age_days"] = 21  # Phase d√©marrage
                corrected["is_age_range"] = False
                corrections_applied.append("age_days sugg√©r√© (21j pour d√©marrage)")
            else:
                corrected["age_days"] = None
                corrected["is_age_range"] = False

        # Copier autres entit√©s non modifi√©es
        for key, value in entities.items():
            if key not in corrected:
                corrected[key] = value

        # Log des corrections
        if corrections_applied:
            original_keys = list(entities.keys()) if entities else []
            corrected_keys = list(corrected.keys())
            logger.info(f"Entit√©s corrig√©es: {original_keys} ‚Üí {corrected_keys}")
            for correction in corrections_applied:
                logger.debug(f"Correction: {correction}")

        return corrected

    # ========================================================================
    # M√âTHODES CORRIG√âES: D√©tection de patterns sp√©ciaux
    # ========================================================================

    def _detect_query_patterns(self, query: str) -> Dict[str, Any]:
        """
        Version corrig√©e avec patterns d'√¢ge robustes

        D√©tecte les patterns sp√©ciaux dans la requ√™te

        Returns:
            {
                "is_calculation": bool,
                "is_temporal_reverse": bool,
                "is_optimization": bool,
                "is_economic": bool,
                "is_planning": bool,
                "extracted_age": int,
                "calculation_type": str,
                "flock_size": int,
                "target_value": float
            }
        """

        # NOUVEAUX patterns d'√¢ge plus robustes
        age_patterns = [
            r"√† \s+(\d+)\s+jours?",  # "√† 42 jours"
            r"(\d+)\s+jours?",  # "42 jours"
            r"de\s+(\d+)\s+jours?",  # "de 42 jours"
            r"(\d+)\s*j\b",  # "42j"
            r"day\s+(\d+)",  # "day 42"
            r"(\d+)\s+days?",  # "42 days"
            r"(\d+)-?jours?",  # "42-jours"
            r"(\d+)\s+semaines?",  # "6 semaines" ‚Üí *7
        ]

        query_lower = query.lower()
        extracted_age = None

        for pattern in age_patterns:
            match = re.search(pattern, query_lower)
            if match:
                try:
                    age = int(match.group(1))
                    # Conversion semaines ‚Üí jours si n√©cessaire
                    if "semaine" in pattern:
                        age = age * 7
                    if 0 <= age <= 150:  # Validation range
                        extracted_age = age
                        logger.debug(
                            f"Age d√©tect√©: {age} jours via pattern '{pattern}'"
                        )
                        break
                except ValueError:
                    continue

        patterns = {
            "is_calculation": self._is_calculation_query(query_lower),
            "is_temporal_reverse": self._is_temporal_reverse_query(query_lower),
            "is_optimization": self._is_optimization_query(query_lower),
            "is_economic": self._is_economic_query(query_lower),
            "is_planning": self._is_planning_query(query_lower),
            "extracted_age": extracted_age,
        }

        # Extraire informations additionnelles
        if patterns["is_calculation"]:
            patterns["calculation_type"] = self._identify_calculation_type(query_lower)

        if patterns["is_planning"]:
            patterns["flock_size"] = self._extract_flock_size(query)

        if patterns["is_temporal_reverse"]:
            patterns["target_value"] = self._extract_target_value(query)

        return patterns

    def _is_calculation_query(self, query_lower: str) -> bool:
        """D√©tecte requ√™tes n√©cessitant des calculs"""
        calculation_keywords = [
            "projette",
            "projection",
            "calcul",
            "calculer",
            "total",
            "totaux",
            "somme",
            "entre",
            "de X √† Y",
            "from X to Y",
            "combien",
            "how much",
            "how many",
        ]
        return any(keyword in query_lower for keyword in calculation_keywords)

    def _is_temporal_reverse_query(self, query_lower: str) -> bool:
        """D√©tecte requ√™tes de recherche invers√©e (valeur ‚Üí √¢ge)"""
        reverse_patterns = [
            "quel √¢ge",
            "√† quel √¢ge",
            "combien de jours",
            "quand atteint",
            "when reach",
            "at what age",
            "pour atteindre",
            "to reach",
        ]
        return any(pattern in query_lower for pattern in reverse_patterns)

    def _is_optimization_query(self, query_lower: str) -> bool:
        """D√©tecte requ√™tes d'optimisation"""
        optimization_keywords = [
            "optimal",
            "optimis",
            "meilleur",
            "best",
            "maximis",
            "minimis",
            "maximize",
            "minimize",
            "id√©al",
            "ideal",
        ]
        return any(keyword in query_lower for keyword in optimization_keywords)

    def _is_economic_query(self, query_lower: str) -> bool:
        """D√©tecte requ√™tes √©conomiques"""
        economic_keywords = [
            "co√ªt",
            "cout",
            "cost",
            "prix",
            "price",
            "rentabilit√©",
            "rentabilite",
            "profitability",
            "marge",
            "margin",
            "roi",
            "‚Ç¨",
            "$",
            "dollar",
            "euro",
        ]
        return any(keyword in query_lower for keyword in economic_keywords)

    def _is_planning_query(self, query_lower: str) -> bool:
        """D√©tecte requ√™tes de planification de troupeau"""
        planning_patterns = [
            r"\d+[\s,]?\d{3}.*poulet",
            r"\d+[\s,]?\d{3}.*bird",
            r"pour \d+.*oiseaux",
            r"for \d+.*chickens",
        ]
        return any(re.search(pattern, query_lower) for pattern in planning_patterns)

    def _identify_calculation_type(self, query_lower: str) -> str:
        """Identifie le type de calcul demand√©"""
        if "projection" in query_lower or "projette" in query_lower:
            return "projection"
        elif "total" in query_lower or "somme" in query_lower:
            return "total"
        elif "entre" in query_lower or "from" in query_lower:
            return "range_calculation"
        elif "taux" in query_lower or "rate" in query_lower:
            return "rate_calculation"
        else:
            return "general_calculation"

    def _extract_flock_size(self, query: str) -> Optional[int]:
        """Extrait la taille du troupeau"""
        numbers = re.findall(r"\b(\d{1,3}(?:[,\s]\d{3})*|\d+)\b", query)
        for num_str in numbers:
            num = int(num_str.replace(",", "").replace(" ", ""))
            if num > 100:  # Probablement taille de troupeau
                return num
        return None

    def _extract_target_value(self, query: str) -> Optional[float]:
        """Extrait valeur cible pour recherche invers√©e"""
        # Chercher patterns comme "2000g", "3kg", "1.5"
        patterns = [
            r"(\d+(?:\.\d+)?)\s*(?:kg|g|grammes?|kilos?)",
            r"(\d+(?:\.\d+)?)\s*(?=\s|$)",
        ]

        for pattern in patterns:
            match = re.search(pattern, query.lower())
            if match:
                try:
                    return float(match.group(1))
                except ValueError:
                    continue
        return None

    # ========================================================================
    # üü¢ NOUVELLE M√âTHODE: D√©tection am√©lior√©e des m√©triques fran√ßaises
    # ========================================================================

    def _enhance_metric_detection(
        self, query: str, entities: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        üü¢ NOUVEAU: D√©tecter les m√©triques fran√ßaises dans la requ√™te

        Utilise le dictionnaire FRENCH_METRICS pour identifier des expressions
        comme "gain quotidien", "consommation cumul√©e", "IC", etc.

        Args:
            query: Requ√™te utilisateur
            entities: Entit√©s existantes

        Returns:
            Entit√©s enrichies avec metric_type d√©tect√©
        """
        # Si metric_type d√©j√† d√©tect√© et valide, ne pas √©craser
        if (
            entities.get("metric_type")
            and entities["metric_type"] not in self.INVALID_METRIC_VALUES
        ):
            logger.debug(f"metric_type d√©j√† d√©tect√©: {entities['metric_type']}")
            return entities

        query_lower = query.lower()

        # Chercher par ordre de sp√©cificit√© (expressions les plus longues d'abord)
        # Cela √©vite que "gain" ne match avant "gain quotidien moyen"
        for pattern in sorted(self.FRENCH_METRICS.keys(), key=len, reverse=True):
            if pattern in query_lower:
                detected = self.FRENCH_METRICS[pattern]
                logger.debug(f"‚úÖ M√©trique FR d√©tect√©e: '{pattern}' ‚Üí {detected}")
                entities["metric_type"] = detected
                entities["metric_detection_method"] = "french_dictionary"
                break

        # Si toujours pas de m√©trique d√©tect√©e, essayer patterns basiques
        if not entities.get("metric_type"):
            # Fallback sur les patterns de base
            basic_patterns = {
                r"\bpoids\b": "body_weight",
                r"\bweight\b": "body_weight",
                r"\bfcr\b": "feed_conversion_ratio",
                r"\bic\b": "feed_conversion_ratio",
                r"\bmortalit[e√©]\b": "mortality",
            }

            for pattern, metric in basic_patterns.items():
                if re.search(pattern, query_lower):
                    logger.debug(
                        f"‚úÖ M√©trique basique d√©tect√©e: pattern '{pattern}' ‚Üí {metric}"
                    )
                    entities["metric_type"] = metric
                    entities["metric_detection_method"] = "regex_fallback"
                    break

        return entities

    # ========================================================================
    # üü¢ NOUVELLE M√âTHODE: Extraction des patterns avanc√©s
    # ========================================================================

    def _extract_advanced_patterns(
        self, query: str, entities: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        üü¢ NOUVEAU: Extraire les patterns avanc√©s (projection, poids cible)

        Patterns d√©tect√©s:
        - Projection: "si je pars de 35 jours", "en partant de 21j"
        - Poids cible: "√† 2.4 kg", "√† 2500 grammes"

        Args:
            query: Requ√™te utilisateur
            entities: Entit√©s existantes

        Returns:
            Entit√©s enrichies avec start_age, target_weight, is_projection
        """
        query_lower = query.lower()

        # D√©tecter projection (√¢ge de d√©part)
        for pattern in self.PROJECTION_PATTERNS:
            match = re.search(pattern, query_lower)
            if match:
                try:
                    start_age = int(match.group(1))
                    if 0 <= start_age <= 150:  # Validation
                        entities["start_age"] = start_age
                        entities["is_projection"] = True
                        logger.debug(f"‚úÖ Projection d√©tect√©e: start_age={start_age}")
                        break
                except (ValueError, IndexError):
                    continue

        # Extraire poids de r√©f√©rence/cible
        for pattern in self.WEIGHT_PATTERNS:
            match = re.search(pattern, query_lower)
            if match:
                try:
                    weight_value = float(match.group(1))

                    # Convertir en grammes si kg d√©tect√© dans le pattern
                    if "kg" in pattern:
                        weight_value *= 1000
                    # Si le nombre est petit (<50), probablement kg
                    elif weight_value < 50:
                        weight_value *= 1000

                    # Validation range (100g - 10kg)
                    if 100 <= weight_value <= 10000:
                        entities["target_weight"] = weight_value
                        logger.debug(f"‚úÖ Poids cible d√©tect√©: {weight_value}g")
                        break
                except (ValueError, IndexError):
                    continue

        return entities

    # ========================================================================
    # üü¢ NOUVELLE M√âTHODE: Splitter les entit√©s comparatives
    # ========================================================================

    def _build_comparison_entities_from_base(
        self, base_entities: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        üü¢ NOUVEAU: Construire les entit√©s individuelles pour comparaison
        en splittant les valeurs multiples (ex: "male, female" ‚Üí 2 entit√©s)

        Args:
            base_entities: Entit√©s de base contenant potentiellement des valeurs multiples

        Returns:
            Liste d'entit√©s individuelles pour chaque comparaison
        """
        entities_list = []

        # Splitter le sexe si multiple
        if "sex" in base_entities:
            sex_str = str(base_entities.get("sex", ""))
            if "," in sex_str:
                sexes = [s.strip() for s in sex_str.split(",")]
                for sex in sexes:
                    entity = base_entities.copy()
                    entity["sex"] = sex
                    entity["explicit_sex_request"] = True
                    entities_list.append(entity)

                logger.info(
                    f"‚úÖ Comparaison sexes splitt√©e: {len(entities_list)} entit√©s"
                )
                return entities_list

        # Splitter breed si multiple
        if "breed" in base_entities:
            breed_str = str(base_entities.get("breed", ""))
            if breed_str and "," in breed_str:
                breeds = [b.strip() for b in breed_str.split(",")]
                for breed in breeds:
                    entity = base_entities.copy()
                    entity["breed"] = breed
                    entities_list.append(entity)

                logger.info(
                    f"‚úÖ Comparaison breeds splitt√©e: {len(entities_list)} entit√©s"
                )
                return entities_list

        # Splitter age_days si liste
        if "age_days" in base_entities:
            age_val = base_entities.get("age_days")
            if isinstance(age_val, list) and len(age_val) > 1:
                for age in age_val:
                    entity = base_entities.copy()
                    entity["age_days"] = age
                    entity["is_age_range"] = False
                    entities_list.append(entity)

                logger.info(
                    f"‚úÖ Comparaison √¢ges splitt√©e: {len(entities_list)} entit√©s"
                )
                return entities_list

        # Pas de split n√©cessaire
        return [base_entities]

    # ========================================================================
    # M√âTHODE CORRIG√âE: Construction des entit√©s de comparaison
    # ========================================================================

    def _build_comparison_entities(
        self, comparative_info: Dict[str, Any], base_entities: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Construit les jeux d'entit√©s pour comparaisons"""

        entity_sets = []

        if not comparative_info.get("entities"):
            logger.debug(
                "Aucune entit√© comparative d√©tect√©e, utilisation entit√©s de base"
            )
            return [base_entities]

        # Traiter chaque dimension de comparaison
        for comp_entity in comparative_info["entities"]:
            dimension = comp_entity.get("dimension")
            values = comp_entity.get("values", [])

            logger.debug(f"Traitement dimension {dimension} avec valeurs: {values}")

            # CORRECTION: Pour les comparaisons de sexe, cr√©er des entit√©s s√©par√©es
            if dimension == "sex" and len(values) >= 2:
                for sex_value in values:
                    entity_set = base_entities.copy()
                    entity_set["sex"] = sex_value
                    # IMPORTANT: Marquer comme demande explicite de sexe
                    entity_set["explicit_sex_request"] = True
                    entity_sets.append(entity_set)
                    logger.debug(f"Entit√© cr√©√©e pour sexe: {sex_value}")

            # Pour les autres dimensions (breed, age, etc.)
            elif dimension == "breed" and len(values) >= 2:
                for breed_value in values:
                    entity_set = base_entities.copy()
                    entity_set["breed"] = breed_value.strip()
                    entity_sets.append(entity_set)
                    logger.debug(f"Entit√© cr√©√©e pour race: {breed_value}")

            elif dimension == "age_days" and len(values) >= 2:
                for age_value in values:
                    entity_set = base_entities.copy()
                    try:
                        entity_set["age_days"] = int(age_value)
                        entity_sets.append(entity_set)
                        logger.debug(f"Entit√© cr√©√©e pour √¢ge: {age_value}")
                    except (ValueError, TypeError):
                        logger.warning(f"√Çge invalide ignor√©: {age_value}")

        # Si aucune entit√© de comparaison n'a √©t√© cr√©√©e, retourner les entit√©s de base
        if not entity_sets:
            logger.warning(
                "Aucune entit√© de comparaison valide, utilisation entit√©s de base"
            )
            entity_sets = [base_entities]

        logger.info(f"Jeux d'entit√©s construits: {len(entity_sets)}")
        return entity_sets

    # ========================================================================
    # M√âTHODE CORRIG√âE: Prompts syst√®me am√©lior√©s
    # ========================================================================

    def _get_system_prompt(self, language: str, is_comparative: bool) -> str:
        """Prompts sp√©cialis√©s selon le type de requ√™te"""

        comparative_instructions = ""
        if is_comparative:
            comparative_instructions = """
ATTENTION: Cette requ√™te demande une COMPARAISON ou un CALCUL.
- Extrais TOUTES les valeurs √† comparer (ex: m√¢le ET femelle, Ross ET Cobb)
- Identifie les dimensions de comparaison (sexe, √¢ge, souche)
- Pour "Ross 308 vs Cobb 500" ‚Üí breed: "Ross 308, Cobb 500"
- Pour "m√¢le vs femelle" ‚Üí sex: "male, female"  
- Pour "21 jours vs 42 jours" ‚Üí age_days: "21, 42"
- Ne privil√©gie pas une valeur par rapport √† l'autre
"""

        if language == "fr":
            return f"""Tu es un assistant expert en aviculture qui normalise les requ√™tes utilisateur.

{comparative_instructions}

T√¢ches:
1. Corriger les fautes de frappe et orthographe
2. Normaliser la terminologie avicole (ex: "conversion aliment" ‚Üí "conversion alimentaire")
3. Extraire les entit√©s structur√©es:
   - breed: race/souche (ex: "Cobb 500", "Ross 308", "Cobb 500, Ross 308" pour comparaisons)
     ‚ö†Ô∏è IMPORTANT: NE JAMAIS mettre "as_hatched" ou "None" pour breed
   - sex: sexe ("male", "female", "male, female" pour comparaisons, ou "as_hatched" si non sp√©cifi√©)
   - age_days: √¢ge en jours (nombre entier ou "21, 42" pour comparaisons)
   - metric_type: type de m√©trique (ex: "feed_conversion", "body_weight", "mortality")
     ‚ö†Ô∏è IMPORTANT: NE JAMAIS mettre "as_hatched", "male" ou "female" pour metric_type
4. Sugg√©rer le routage optimal:
   - "postgresql" pour m√©triques chiffr√©es
   - "weaviate" pour documents/guides
5. D√©terminer le type de requ√™te:
   - "metric" pour donn√©es chiffr√©es
   - "document" pour guides/docs
   - "general" pour questions g√©n√©rales

R√àGLES CRITIQUES:
- Si le sexe n'est PAS explicitement mentionn√©, utiliser "as_hatched"
- Pour les comparaisons, extraire TOUTES les entit√©s mentionn√©es
- Pour "√† 42 jours", extraire age_days: 42
- Pour "Ross vs Cobb", extraire breed: "Ross 308, Cobb 500"
- Si breed n'est pas mentionn√©, laisser breed vide ou null (PAS "as_hatched")
- Si metric_type n'est pas clair, laisser vide ou null (PAS "as_hatched")

R√©ponds en JSON:
{{
    "normalized_query": "requ√™te corrig√©e",
    "query_type": "metric|document|general",
    "entities": {{
        "breed": "...",
        "sex": "male|female|as_hatched|male, female",
        "age_days": 17,
        "metric_type": "..."
    }},
    "routing": "postgresql|weaviate",
    "confidence": 0.95
}}"""

        else:  # English
            return f"""You are a poultry expert assistant that normalizes user queries.

{comparative_instructions}

Tasks:
1. Fix typos and spelling errors
2. Normalize poultry terminology
3. Extract structured entities:
   - breed: breed/strain name (ex: "Cobb 500, Ross 308" for comparisons)
     ‚ö†Ô∏è IMPORTANT: NEVER use "as_hatched" or "None" for breed
   - sex: "male", "female", "male, female" for comparisons, or "as_hatched" if not specified
   - age_days: age in days (integer or "21, 42" for comparisons)
   - metric_type: metric type
     ‚ö†Ô∏è IMPORTANT: NEVER use "as_hatched", "male" or "female" for metric_type
4. Suggest optimal routing:
   - "postgresql" for numeric metrics
   - "weaviate" for documents/guides
5. Determine query type

CRITICAL RULES:
- If sex is NOT explicitly mentioned, use "as_hatched"
- For comparisons, extract ALL mentioned entities
- For "at 42 days", extract age_days: 42
- For "Ross vs Cobb", extract breed: "Ross 308, Cobb 500"
- If breed is not mentioned, leave breed empty or null (NOT "as_hatched")
- If metric_type is not clear, leave empty or null (NOT "as_hatched")

Respond in JSON:
{{
    "normalized_query": "corrected query",
    "query_type": "metric|document|general",
    "entities": {{...}},
    "routing": "postgresql|weaviate",
    "confidence": 0.95
}}"""

    def _fallback_preprocessing(
        self,
        query: str,
        comparative_info: Dict,
        query_patterns: Dict,
        strict_requirements: Dict,
    ) -> Dict[str, Any]:
        """
        AM√âLIOR√â: Preprocessing de secours avec d√©tection locale
        """
        logger.warning("Utilisation du preprocessing de secours")

        # D√©tection locale de base
        detected_entities = {"sex": "as_hatched"}

        query_lower = query.lower()

        # D√©tection breed locale
        if any(word in query_lower for word in ["cobb", "500"]):
            detected_entities["breed"] = "Cobb 500"
        elif any(word in query_lower for word in ["ross", "308"]):
            detected_entities["breed"] = "Ross 308"
        elif any(word in query_lower for word in ["hubbard", "ja87"]):
            detected_entities["breed"] = "Hubbard JA87"

        # D√©tection √¢ge locale
        import re

        age_match = re.search(r"(\d+)\s*(?:jours?|days?|j)", query_lower)
        if age_match:
            detected_entities["age_days"] = int(age_match.group(1))

        # D√©tection m√©trique locale
        if any(word in query_lower for word in ["poids", "weight"]):
            detected_entities["metric_type"] = "weight"
        elif any(word in query_lower for word in ["fcr", "conversion"]):
            detected_entities["metric_type"] = "fcr"

        # Routage local
        routing = "postgresql" if detected_entities.get("breed") else "weaviate"

        # CORRECTION: Construction des entit√©s de comparaison dans le fallback
        comparison_entities = []
        if comparative_info.get("is_comparative", False):
            comparison_entities = self._build_comparison_entities(
                comparative_info, detected_entities
            )

        return {
            "normalized_query": self._normalize_query_text(query),
            "query_type": "general",
            "entities": detected_entities,
            "routing": routing,
            "confidence": 0.5,  # Confidence r√©duite pour fallback
            "is_comparative": comparative_info["is_comparative"],
            "comparative_info": comparative_info,
            "requires_calculation": comparative_info["is_comparative"],
            "comparison_entities": comparison_entities,
            "query_patterns": query_patterns,
            "strict_requirements": strict_requirements,
            "preprocessing_fallback": True,
        }

    def get_status(self) -> Dict[str, Any]:
        """Status du preprocessor"""
        return {
            "initialized": self._is_initialized,
            "comparative_detection": True,
            "pattern_detection": True,
            "local_extraction": True,
            "cache_enabled": True,
            "cache_size": len(self._cache),
            "strict_matching_support": True,
            "sex_explicit_detection": True,
            "entity_validation": True,
            "invalid_breed_filtering": True,
            "invalid_metric_filtering": True,
            "multi_age_support": True,
            "automatic_entity_splitting": True,
            "advanced_pattern_extraction": True,
            "projection_detection": True,
            "weight_target_extraction": True,
            "french_metrics_dictionary": True,
            "enhanced_metric_detection": True,
            "supported_french_metrics": len(self.FRENCH_METRICS),
            "supported_comparisons": list(
                self.comparative_detector.COMPARATIVE_PATTERNS.keys()
            ),
            "supported_patterns": [
                "calculation",
                "temporal_reverse",
                "optimization",
                "economic",
                "planning",
                "projection",
                "weight_target",
            ],
            "client_available": self.client is not None,
        }
