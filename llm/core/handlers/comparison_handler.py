# -*- coding: utf-8 -*-
"""
comparison_handler.py - Wrapper de compatibilit√© vers ComparisonEngine
VERSION REFACTORIS√âE: D√©l√®gue toute la logique au nouveau ComparisonEngine unifi√©

CHANGEMENTS:
- Supprim√©: ~700 lignes de logique m√©tier dupliqu√©e
- Ajout√©: Wrapper simple de ~100 lignes vers ComparisonEngine
- Conservation: Compatibilit√© totale avec l'API existante
"""

import logging
from utils.types import Dict, List, Any

# Import du nouveau moteur unifi√©
from ..comparison_engine import ComparisonEngine, ComparisonResult

logger = logging.getLogger(__name__)


class ComparisonHandler:
    """
    Wrapper legacy pour compatibilit√© avec le code existant

    D√©l√®gue toute la logique m√©tier au ComparisonEngine unifi√© qui centralise:
    - comparison_handler.py (orchestration)
    - comparison_utils.py (extraction et parsing)
    - comparison_response_generator.py (g√©n√©ration r√©ponses)

    Le MetricCalculator reste s√©par√© pour les calculs math√©matiques purs.
    """

    def __init__(self, postgresql_system):
        """
        Initialise le wrapper avec le moteur unifi√©

        Args:
            postgresql_system: Instance PostgreSQLSystem pour r√©cup√©ration donn√©es
        """
        # D√©l√©gation au moteur unifi√©
        self.engine = ComparisonEngine(postgresql_system)

        # Conserver r√©f√©rence pour compatibilit√©
        self.postgresql_system = postgresql_system

        logger.info("‚úÖ ComparisonHandler initialis√© (wrapper ‚Üí ComparisonEngine)")

    async def handle_comparison_query(
        self, preprocessed_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Point d'entr√©e principal - D√âL√àGUE au ComparisonEngine

        Args:
            preprocessed_data: Donn√©es preprocess√©es avec:
                - comparison_entities: List[Dict]
                - entities: Dict
                - normalized_query: str

        Returns:
            Dict au format harmonis√© attendu par rag_engine_handlers:
            {
                "success": bool,
                "comparison": Dict,
                "results": List[Dict],
                "context": Dict,
                "metadata": Dict,
                "error": Optional[str],
                "fallback_used": bool,
            }
        """
        logger.debug("üéØ ComparisonHandler.handle_comparison_query() appel√©")

        # D√©l√©gation au moteur
        result = await self.engine.compare(preprocessed_data)

        # Conversion ComparisonResult ‚Üí format Dict attendu par les handlers
        return {
            "success": result.success,
            "comparison": result.comparison_data,
            "results": self._format_results_for_handlers(result),
            "context": (
                result.comparison_data.get("context", {})
                if result.comparison_data
                else {}
            ),
            "metadata": {
                "query_type": "comparative",
                "entities_compared": len(result.entities_compared),
                "preprocessing_applied": True,
                "dimension": result.dimension.value if result.dimension else None,
                "fallback_used": result.fallback_used,
            },
            "error": result.error,
            "fallback_used": result.fallback_used,
        }

    def _format_results_for_handlers(self, result: ComparisonResult) -> List[Dict]:
        """
        Formate les r√©sultats pour compatibilit√© avec rag_engine_handlers.py

        Args:
            result: ComparisonResult du moteur

        Returns:
            Liste au format attendu: [{"entity": str, "data": List[Dict]}]
        """
        if not result.success or not result.comparison_data:
            return []

        # Format attendu par ComparativeQueryHandler dans rag_engine_handlers.py
        formatted = []

        # Pour chaque entit√© compar√©e, cr√©er une structure document
        for i, entity_label in enumerate(result.entities_compared):
            # Extraire les donn√©es de cette entit√© depuis comparison_data
            value_key = f"value{i+1}"

            if value_key in result.comparison_data:
                formatted.append(
                    {
                        "entity": entity_label,
                        "data": [
                            {
                                "metric_name": result.comparison_data.get(
                                    "metric_name"
                                ),
                                "value_numeric": result.comparison_data.get(value_key),
                                "unit": result.comparison_data.get("unit", "g"),
                                "age_days": result.comparison_data.get("age_days"),
                                "sex": result.comparison_data.get("sex"),
                                "breed": (
                                    entity_label.split()[0]
                                    if " " in entity_label
                                    else entity_label
                                ),
                            }
                        ],
                    }
                )

        logger.debug(f"üìä Results format√©s: {len(formatted)} entit√©s")
        return formatted

    async def handle_comparative_query(
        self, query: str, preprocessed: Dict[str, Any], top_k: int = 12
    ) -> Dict[str, Any]:
        """
        Version alternative pour compatibilit√© - REDIRIGE vers handle_comparison_query

        Maintient la compatibilit√© avec l'ancien code tout en utilisant
        la nouvelle structure harmonis√©e.

        Args:
            query: Requ√™te utilisateur
            preprocessed: Donn√©es preprocess√©es
            top_k: Nombre de r√©sultats (unused, pour compatibilit√©)

        Returns:
            Dict au format harmonis√©
        """
        logger.info("üîÑ Redirecting handle_comparative_query ‚Üí handle_comparison_query")

        # Construire preprocessed_data au format attendu
        preprocessed_data = {
            "normalized_query": query,
            "original_query": query,
            "entities": preprocessed.get("entities", {}),
            "comparison_entities": preprocessed.get("comparison_entities", []),
            "routing_hint": "postgresql",
            "is_comparative": True,
        }

        # Appeler la m√©thode principale harmonis√©e
        return await self.handle_comparison_query(preprocessed_data)

    async def generate_comparative_response(
        self,
        query: str,
        comparison_result: Dict[str, Any],
        language: str = "fr",
    ) -> str:
        """
        G√©n√©ration de r√©ponse - D√âL√àGUE au ComparisonEngine

        Args:
            query: Question originale
            comparison_result: R√©sultat de comparaison (format Dict legacy)
            language: Langue de r√©ponse ('fr' ou 'en')

        Returns:
            Texte de r√©ponse format√©
        """
        logger.debug(f"üìù G√©n√©ration r√©ponse comparative (langue={language})")

        # Convertir Dict legacy ‚Üí ComparisonResult pour le moteur
        from .comparison_engine import ComparisonStatus

        # D√©terminer le status
        if comparison_result.get("success"):
            status = ComparisonStatus.SUCCESS
        elif "insufficient" in comparison_result.get("error", "").lower():
            status = ComparisonStatus.INSUFFICIENT_DATA
        else:
            status = ComparisonStatus.ERROR

        engine_result = ComparisonResult(
            success=comparison_result.get("success", False),
            status=status,
            comparison_data=comparison_result.get("comparison"),
            entities_compared=self._extract_entity_labels(comparison_result),
            error=comparison_result.get("error"),
            metadata=comparison_result.get("metadata", {}),
            fallback_used=comparison_result.get("fallback_used", False),
        )

        # D√©l√©gation au moteur pour g√©n√©ration
        return await self.engine.generate_response(
            query,
            engine_result,
            language,
            use_openai=True,
        )

    def _extract_entity_labels(self, comparison_result: Dict) -> List[str]:
        """Extrait les labels des entit√©s depuis le r√©sultat legacy"""
        comparison = comparison_result.get("comparison", {})

        # Essayer d'extraire depuis comparison
        if "entity1" in comparison and "entity2" in comparison:
            return [comparison["entity1"], comparison["entity2"]]

        # Essayer d'extraire depuis label1/label2
        if "label1" in comparison and "label2" in comparison:
            return [comparison["label1"], comparison["label2"]]

        # Fallback
        return ["Entit√© 1", "Entit√© 2"]

    async def handle_temporal_comparison(
        self, query: str, age_start: int, age_end: int, entities: Dict
    ) -> Dict:
        """
        G√®re les comparaisons temporelles entre deux √¢ges

        NOTE: Cette m√©thode pourrait aussi √™tre d√©l√©gu√©e au ComparisonEngine
        Pour l'instant, conserv√©e pour compatibilit√© maximale

        Args:
            query: Requ√™te utilisateur
            age_start: √Çge de d√©but (jours)
            age_end: √Çge de fin (jours)
            entities: Entit√©s de base

        Returns:
            Dict avec r√©sultat de comparaison temporelle
        """
        logger.info(f"‚è±Ô∏è Comparaison temporelle: {age_start}j ‚Üí {age_end}j")

        # Cr√©er les entit√©s pour chaque √¢ge
        comparison_entities = [
            {**entities, "age_days": age_start, "_comparison_label": f"{age_start}j"},
            {**entities, "age_days": age_end, "_comparison_label": f"{age_end}j"},
        ]

        # Utiliser le moteur standard avec ces entit√©s
        preprocessed_data = {
            "normalized_query": query,
            "original_query": query,
            "entities": entities,
            "comparison_entities": comparison_entities,
            "is_comparative": True,
            "query_type": "temporal_range",
        }

        result = await self.handle_comparison_query(preprocessed_data)

        # Enrichir avec m√©tadonn√©es temporelles
        if result.get("success"):
            comparison = result.get("comparison", {})
            result["comparison_type"] = "temporal"
            result["start_age"] = age_start
            result["end_age"] = age_end
            result["evolution"] = self._determine_evolution(comparison)

        return result

    def _determine_evolution(self, comparison: Dict) -> str:
        """D√©termine le type d'√©volution (croissance/diminution/stable)"""
        if not comparison:
            return "unknown"

        difference = comparison.get("difference_absolute", 0)
        percent_change = comparison.get("difference_percent", 0)

        if abs(percent_change) < 1:
            return "stable"
        elif difference > 0:
            return "croissance"
        else:
            return "diminution"


# ============================================================================
# FONCTIONS SUPPRIM√âES (d√©plac√©es dans comparison_engine.py)
# ============================================================================

# Les fonctions suivantes ont √©t√© SUPPRIM√âES de ce fichier et d√©plac√©es
# dans comparison_engine.py pour centralisation:
#
# ‚ùå _preserve_critical_fields() ‚Üí dans ComparisonEngine
# ‚ùå _build_results_structure() ‚Üí dans ComparisonEngine._format_results()
# ‚ùå _fallback_relaxed_search() ‚Üí dans ComparisonEngine._compare_with_fallback()
# ‚ùå _compare_entities() ‚Üí dans ComparisonEngine._calculate_comparison()
# ‚ùå _extract_best_metric_with_units() ‚Üí dans ComparisonEngine._extract_best_metric()
# ‚ùå _compare_metrics_with_unit_handling() ‚Üí fusionn√© dans _calculate_comparison()
# ‚ùå _extract_context_from_entities() ‚Üí dans ComparisonEngine._calculate_comparison()
# ‚ùå _create_error_response() ‚Üí gestion directe dans ComparisonResult
#
# GAIN: ~700 lignes supprim√©es, logique centralis√©e, plus de duplication


# ============================================================================
# COMPATIBILIT√â ET MIGRATION
# ============================================================================

"""
GUIDE DE MIGRATION:

1. Code existant utilisant ComparisonHandler:
   - ‚úÖ Aucun changement n√©cessaire
   - ‚úÖ Toutes les m√©thodes publiques conserv√©es
   - ‚úÖ Signatures identiques

2. Avantages de la refactorisation:
   - ‚úÖ Code 8x plus simple (~100 lignes vs ~800)
   - ‚úÖ Logique centralis√©e dans ComparisonEngine
   - ‚úÖ Plus de duplication avec comparison_utils/comparison_response_generator
   - ‚úÖ Tests plus faciles (tester ComparisonEngine directement)
   - ‚úÖ Maintenance simplifi√©e (un seul endroit pour bugs/features)

3. Modules supprim√©s apr√®s refactorisation:
   - ‚ùå comparison_utils.py ‚Üí fusionn√© dans comparison_engine.py
   - ‚ùå comparison_response_generator.py ‚Üí fusionn√© dans comparison_engine.py

4. Module conserv√©:
   - ‚úÖ metric_calculator.py ‚Üí calculs math√©matiques purs
"""
