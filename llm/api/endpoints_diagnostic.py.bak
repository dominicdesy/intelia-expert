# -*- coding: utf-8 -*-
"""
api/endpoints_diagnostic.py - Endpoints de diagnostic Weaviate et RAG
Nouveaux endpoints pour diagnostiquer les problèmes de récupération
VERSION CORRIGÉE - Problèmes de collections résolus
"""

import os
import time
import asyncio
import logging
from typing import Dict, Any, Optional
from fastapi import APIRouter, Query
from fastapi.responses import JSONResponse

from config.config import BASE_PATH
from utils.utilities import safe_get_attribute
from .endpoints_utils import safe_serialize_for_json

logger = logging.getLogger(__name__)


def create_diagnostic_endpoints(services: Dict[str, Any]) -> APIRouter:
    """Crée les endpoints de diagnostic pour Weaviate et RAG"""

    router = APIRouter()

    def get_service(name: str) -> Any:
        """Helper pour récupérer un service"""
        return services.get(name)

    def get_collection_safely(weaviate_client, collection_name: str):
        """Récupère une collection de manière sécurisée"""
        try:
            if hasattr(weaviate_client, "collections"):
                return weaviate_client.collections.get(collection_name)
            return None
        except Exception as e:
            logger.warning(f"Erreur récupération collection {collection_name}: {e}")
            return None

    async def get_collections_info(weaviate_client) -> Dict[str, Any]:
        """Récupère les informations des collections de manière robuste"""
        collections_info = {}
        collection_names = []

        try:
            if not hasattr(weaviate_client, "collections"):
                return {"error": "Weaviate v3 non supporté"}

            # Récupérer la liste des collections
            collections_data = await asyncio.get_event_loop().run_in_executor(
                None, lambda: weaviate_client.collections.list_all()
            )

            # Traiter selon le type de retour
            if isinstance(collections_data, dict):
                collection_names = list(collections_data.keys())
            else:
                collection_names = list(collections_data)

            # Récupérer les infos de chaque collection
            for collection_name in collection_names:
                try:
                    collection = weaviate_client.collections.get(collection_name)
                    count_result = await asyncio.get_event_loop().run_in_executor(
                        None,
                        lambda c=collection: c.aggregate.over_all(total_count=True),
                    )
                    doc_count = getattr(count_result, "total_count", 0)

                    collections_info[collection_name] = {
                        "document_count": doc_count,
                        "name": collection_name,
                        "accessible": True,
                    }

                except Exception as e:
                    collections_info[collection_name] = {
                        "error": str(e),
                        "document_count": 0,
                        "accessible": False,
                    }

        except Exception as e:
            return {"error": f"Erreur récupération collections: {e}"}

        return collections_info

    # ========================================================================
    # DIAGNOSTICS WEAVIATE CORRIGÉS
    # ========================================================================

    @router.get(f"{BASE_PATH}/diagnostic/weaviate-status")
    async def weaviate_status():
        """Statut détaillé de Weaviate avec comptage documents et collections"""
        try:
            health_monitor = get_service("health_monitor")
            if not health_monitor:
                return {
                    "error": "Health monitor non disponible",
                    "timestamp": time.time(),
                }

            rag_engine = health_monitor.get_service("rag_engine_enhanced")
            if not rag_engine:
                return {"error": "RAG Engine non disponible", "timestamp": time.time()}

            weaviate_client = safe_get_attribute(rag_engine, "weaviate_client")
            if not weaviate_client:
                return {
                    "error": "Client Weaviate non disponible",
                    "timestamp": time.time(),
                }

            result = {
                "timestamp": time.time(),
                "client_available": True,
                "collections": {},
                "total_documents": 0,
                "weaviate_version": "unknown",
                "issues": [],
            }

            try:
                # Tester la connexion
                is_ready = await asyncio.get_event_loop().run_in_executor(
                    None, weaviate_client.is_ready
                )
                result["is_ready"] = is_ready

                if not is_ready:
                    result["issues"].append("Weaviate n'est pas ready")
                    return safe_serialize_for_json(result)

                # Récupérer les collections avec la fonction corrigée
                result["weaviate_version"] = "v4"
                collections_info = await get_collections_info(weaviate_client)

                if "error" in collections_info:
                    result["issues"].append(collections_info["error"])
                    result["weaviate_version"] = "v4-error"
                else:
                    result["collections"] = collections_info
                    result["total_documents"] = sum(
                        info.get("document_count", 0)
                        for info in collections_info.values()
                    )

                # Vérifications de santé
                if result["total_documents"] == 0:
                    result["issues"].append(
                        "CRITIQUE: Aucun document trouvé dans Weaviate"
                    )
                elif result["total_documents"] < 100:
                    result["issues"].append(
                        f"ATTENTION: Peu de documents ({result['total_documents']})"
                    )

                result["status"] = (
                    "healthy" if len(result["issues"]) == 0 else "issues_detected"
                )

            except Exception as e:
                result["error"] = str(e)
                result["issues"].append(f"Erreur diagnostic Weaviate: {e}")
                result["status"] = "error"

            return safe_serialize_for_json(result)

        except Exception as e:
            logger.error(f"Erreur weaviate_status: {e}")
            return {"error": str(e), "timestamp": time.time(), "status": "error"}

    @router.get(f"{BASE_PATH}/diagnostic/search-documents")
    async def search_documents(
        query: str = Query(..., description="Terme de recherche"),
        limit: int = Query(10, description="Nombre max de résultats"),
    ):
        """Recherche directe dans Weaviate pour tester la récupération"""
        try:
            health_monitor = get_service("health_monitor")
            if not health_monitor:
                return {"error": "Health monitor non disponible"}

            rag_engine = health_monitor.get_service("rag_engine_enhanced")
            if not rag_engine:
                return {"error": "RAG Engine non disponible"}

            retriever = safe_get_attribute(rag_engine, "retriever")
            embedder = safe_get_attribute(rag_engine, "embedder")

            if not retriever or not embedder:
                return {"error": "Retriever ou Embedder non disponible"}

            result = {
                "query": query,
                "timestamp": time.time(),
                "documents_found": 0,
                "search_results": [],
                "embedding_info": {},
                "issues": [],
            }

            try:
                # Générer embedding
                embedding = await embedder.get_embedding(query)
                if embedding:
                    result["embedding_info"] = {
                        "dimension": len(embedding),
                        "has_values": bool(embedding),
                        "first_3_values": (
                            embedding[:3] if len(embedding) >= 3 else embedding
                        ),
                    }
                else:
                    result["issues"].append("Échec génération embedding")
                    return safe_serialize_for_json(result)

                # Recherche hybride sans filtre WHERE
                documents = await retriever.hybrid_search(
                    query_vector=embedding,
                    query_text=query,
                    top_k=limit,
                    where_filter=None,
                    alpha=0.5,
                )

                result["documents_found"] = len(documents)

                for i, doc in enumerate(documents):
                    doc_info = {
                        "index": i,
                        "score": getattr(doc, "score", 0),
                        "title": getattr(doc, "metadata", {}).get(
                            "title", "Sans titre"
                        ),
                        "genetic_line": getattr(doc, "metadata", {}).get(
                            "geneticLine", "unknown"
                        ),
                        "document_type": getattr(doc, "metadata", {}).get(
                            "documentType", "unknown"
                        ),
                        "content_preview": (
                            getattr(doc, "content", "")[:200] + "..."
                            if getattr(doc, "content", "")
                            else "Pas de contenu"
                        ),
                        "metadata": getattr(doc, "metadata", {}),
                    }
                    result["search_results"].append(doc_info)

                # Vérifications spécifiques
                ross_docs = [
                    doc
                    for doc in result["search_results"]
                    if "ross" in doc.get("genetic_line", "").lower()
                ]

                performance_docs = [
                    doc
                    for doc in result["search_results"]
                    if "performance" in doc.get("title", "").lower()
                    or "performance" in doc.get("content_preview", "").lower()
                ]

                result["analysis"] = {
                    "contains_ross_308": len(ross_docs) > 0,
                    "contains_performance_data": len(performance_docs) > 0,
                    "ross_documents_count": len(ross_docs),
                    "performance_documents_count": len(performance_docs),
                    "average_score": (
                        sum(doc["score"] for doc in result["search_results"])
                        / len(result["search_results"])
                        if result["search_results"]
                        else 0
                    ),
                }

                if not ross_docs and "ross" in query.lower():
                    result["issues"].append(
                        "PROBLÈME: Aucun document Ross trouvé malgré la recherche"
                    )

                if not performance_docs and "performance" in query.lower():
                    result["issues"].append(
                        "PROBLÈME: Aucun document de performance trouvé"
                    )

            except Exception as e:
                result["error"] = str(e)
                result["issues"].append(f"Erreur recherche: {e}")

            return safe_serialize_for_json(result)

        except Exception as e:
            logger.error(f"Erreur search_documents: {e}")
            return {"error": str(e), "timestamp": time.time()}

    @router.get(f"{BASE_PATH}/diagnostic/document-metadata")
    async def document_metadata(
        limit: int = Query(20, description="Nombre d'échantillons"),
        collection_name: Optional[str] = Query(
            None, description="Collection spécifique"
        ),
    ):
        """Analyse des métadonnées des documents pour diagnostiquer l'indexation - VERSION CORRIGÉE"""
        try:
            health_monitor = get_service("health_monitor")
            if not health_monitor:
                return {"error": "Health monitor non disponible"}

            rag_engine = health_monitor.get_service("rag_engine_enhanced")
            if not rag_engine:
                return {"error": "RAG Engine non disponible"}

            weaviate_client = safe_get_attribute(rag_engine, "weaviate_client")
            if not weaviate_client:
                return {"error": "Client Weaviate non disponible"}

            result = {
                "timestamp": time.time(),
                "sample_documents": [],
                "genetic_lines_found": [],
                "document_types_found": [],
                "metadata_analysis": {},
                "issues": [],
                "collection_used": None,
            }

            try:
                if hasattr(weaviate_client, "collections"):
                    # Récupérer les informations des collections
                    collections_info = await get_collections_info(weaviate_client)

                    if "error" in collections_info:
                        result["issues"].append(collections_info["error"])
                        return safe_serialize_for_json(result)

                    # Choisir la collection à analyser
                    target_collection = None
                    target_collection_name = None

                    if collection_name:
                        # Collection spécifiée par l'utilisateur
                        target_collection = get_collection_safely(
                            weaviate_client, collection_name
                        )
                        target_collection_name = collection_name
                    else:
                        # Trouver la collection avec le plus de documents
                        best_collection_name = None
                        max_docs = 0

                        for coll_name, coll_info in collections_info.items():
                            doc_count = coll_info.get("document_count", 0)
                            if doc_count > max_docs:
                                max_docs = doc_count
                                best_collection_name = coll_name

                        if best_collection_name and max_docs > 0:
                            target_collection = get_collection_safely(
                                weaviate_client, best_collection_name
                            )
                            target_collection_name = best_collection_name

                    result["collection_used"] = target_collection_name

                    if target_collection:
                        # Échantillonner des documents
                        try:
                            sample_docs = (
                                await asyncio.get_event_loop().run_in_executor(
                                    None,
                                    lambda: target_collection.query.fetch_objects(
                                        limit=limit
                                    ),
                                )
                            )

                            if sample_docs and sample_docs.objects:
                                for obj in sample_docs.objects:
                                    props = obj.properties or {}

                                    doc_analysis = {
                                        "uuid": (
                                            str(obj.uuid)
                                            if hasattr(obj, "uuid")
                                            else "unknown"
                                        ),
                                        "genetic_line": props.get(
                                            "geneticLine", "NOT_SET"
                                        ),
                                        "title": props.get("title", "NOT_SET"),
                                        "document_type": props.get(
                                            "documentType", "NOT_SET"
                                        ),
                                        "category": props.get("category", "NOT_SET"),
                                        "language": props.get("language", "NOT_SET"),
                                        "has_performance_data": props.get(
                                            "hasPerformanceData", False
                                        ),
                                        "content_length": len(props.get("content", "")),
                                        "all_properties": list(props.keys()),
                                    }

                                    result["sample_documents"].append(doc_analysis)

                                    # Collecter les valeurs uniques
                                    gl = props.get("geneticLine")
                                    if gl and gl not in result["genetic_lines_found"]:
                                        result["genetic_lines_found"].append(gl)

                                    dt = props.get("documentType")
                                    if dt and dt not in result["document_types_found"]:
                                        result["document_types_found"].append(dt)

                                # Analyse des métadonnées
                                result["metadata_analysis"] = {
                                    "total_samples": len(result["sample_documents"]),
                                    "genetic_lines_variety": len(
                                        result["genetic_lines_found"]
                                    ),
                                    "document_types_variety": len(
                                        result["document_types_found"]
                                    ),
                                    "has_ross_308": any(
                                        "ross" in str(gl).lower()
                                        and "308" in str(gl).lower()
                                        for gl in result["genetic_lines_found"]
                                    ),
                                    "has_performance_docs": any(
                                        doc.get("has_performance_data", False)
                                        for doc in result["sample_documents"]
                                    ),
                                    "missing_genetic_line": sum(
                                        1
                                        for doc in result["sample_documents"]
                                        if doc["genetic_line"] == "NOT_SET"
                                    ),
                                    "empty_titles": sum(
                                        1
                                        for doc in result["sample_documents"]
                                        if doc["title"] == "NOT_SET" or not doc["title"]
                                    ),
                                    "average_content_length": (
                                        sum(
                                            doc["content_length"]
                                            for doc in result["sample_documents"]
                                        )
                                        / len(result["sample_documents"])
                                        if result["sample_documents"]
                                        else 0
                                    ),
                                }

                                # Diagnostics spécifiques
                                analysis = result["metadata_analysis"]

                                if not analysis["has_ross_308"]:
                                    result["issues"].append(
                                        "CRITIQUE: Aucun document Ross 308 trouvé dans l'échantillon"
                                    )

                                if not analysis["has_performance_docs"]:
                                    result["issues"].append(
                                        "ATTENTION: Aucun document de performance trouvé"
                                    )

                                if (
                                    analysis["missing_genetic_line"]
                                    > len(result["sample_documents"]) * 0.1
                                ):
                                    result["issues"].append(
                                        f"PROBLÈME: {analysis['missing_genetic_line']} documents sans geneticLine"
                                    )

                                if (
                                    analysis["empty_titles"]
                                    > len(result["sample_documents"]) * 0.1
                                ):
                                    result["issues"].append(
                                        f"PROBLÈME: {analysis['empty_titles']} documents sans titre"
                                    )

                                if analysis["average_content_length"] < 100:
                                    result["issues"].append(
                                        "ATTENTION: Contenu des documents très court en moyenne"
                                    )

                            else:
                                result["issues"].append(
                                    "Impossible de récupérer des échantillons de documents"
                                )

                        except Exception as e:
                            result["issues"].append(
                                f"Erreur échantillonnage documents: {e}"
                            )

                    else:
                        result["issues"].append("Aucune collection accessible trouvée")

                else:
                    result["issues"].append(
                        "API Weaviate v3 non supportée pour cette analyse"
                    )

            except Exception as e:
                result["error"] = str(e)
                result["issues"].append(f"Erreur analyse métadonnées: {e}")

            return safe_serialize_for_json(result)

        except Exception as e:
            logger.error(f"Erreur document_metadata: {e}")
            return {"error": str(e), "timestamp": time.time()}

    @router.get(f"{BASE_PATH}/diagnostic/search-specific")
    async def search_specific_document(
        document: str = Query(..., description="Terme spécifique à chercher")
    ):
        """Recherche un document spécifique pour diagnostiquer pourquoi il n'est pas trouvé - VERSION CORRIGÉE"""
        try:
            health_monitor = get_service("health_monitor")
            if not health_monitor:
                return {"error": "Health monitor non disponible"}

            rag_engine = health_monitor.get_service("rag_engine_enhanced")
            if not rag_engine:
                return {"error": "RAG Engine non disponible"}

            result = {
                "search_term": document,
                "timestamp": time.time(),
                "tests_performed": [],
                "results": {},
                "recommendations": [],
            }

            # Test 1: Recherche par embedding
            try:
                retriever = safe_get_attribute(rag_engine, "retriever")
                embedder = safe_get_attribute(rag_engine, "embedder")

                if retriever and embedder:
                    embedding = await embedder.get_embedding(document)
                    if embedding:
                        docs = await retriever.hybrid_search(
                            query_vector=embedding,
                            query_text=document,
                            top_k=10,
                            where_filter=None,
                            alpha=0.3,
                        )

                        result["tests_performed"].append("embedding_search")
                        result["results"]["embedding_search"] = {
                            "documents_found": len(docs),
                            "top_3_scores": [
                                getattr(doc, "score", 0) for doc in docs[:3]
                            ],
                            "contains_search_term": any(
                                document.lower() in getattr(doc, "content", "").lower()
                                or document.lower()
                                in str(getattr(doc, "metadata", {})).lower()
                                for doc in docs[:5]
                            ),
                        }
            except Exception as e:
                result["results"]["embedding_search"] = {"error": str(e)}

            # Test 2: Recherche BM25 pure
            try:
                if retriever:
                    dummy_embedding = [0.0] * 1536
                    docs = await retriever.hybrid_search(
                        query_vector=dummy_embedding,
                        query_text=document,
                        top_k=10,
                        where_filter=None,
                        alpha=1.0,
                    )

                    result["tests_performed"].append("bm25_search")
                    result["results"]["bm25_search"] = {
                        "documents_found": len(docs),
                        "contains_search_term": any(
                            document.lower() in getattr(doc, "content", "").lower()
                            for doc in docs[:5]
                        ),
                    }
            except Exception as e:
                result["results"]["bm25_search"] = {"error": str(e)}

            # Test 3: Recherche directe Weaviate avec Where - VERSION CORRIGÉE
            try:
                weaviate_client = safe_get_attribute(rag_engine, "weaviate_client")
                if weaviate_client and hasattr(weaviate_client, "collections"):
                    collections_info = await get_collections_info(weaviate_client)

                    if "error" not in collections_info and collections_info:
                        # Prendre la première collection accessible
                        collection_name = next(
                            (
                                name
                                for name, info in collections_info.items()
                                if info.get("accessible", False)
                                and info.get("document_count", 0) > 0
                            ),
                            None,
                        )

                        if collection_name:
                            collection = get_collection_safely(
                                weaviate_client, collection_name
                            )
                            if collection:
                                try:
                                    # Utiliser bm25 search au lieu de fetch_objects avec where
                                    docs = (
                                        await asyncio.get_event_loop().run_in_executor(
                                            None,
                                            lambda: collection.query.bm25(
                                                query=document, limit=5
                                            ),
                                        )
                                    )

                                    result["tests_performed"].append(
                                        "weaviate_where_search"
                                    )
                                    result["results"]["weaviate_where_search"] = {
                                        "documents_found": (
                                            len(docs.objects)
                                            if docs and hasattr(docs, "objects")
                                            else 0
                                        ),
                                        "direct_match": (
                                            len(docs.objects) > 0
                                            if docs and hasattr(docs, "objects")
                                            else False
                                        ),
                                        "collection_used": collection_name,
                                        "search_method": "bm25_direct",
                                    }
                                except Exception as e:
                                    result["results"]["weaviate_where_search"] = {
                                        "error": str(e)
                                    }
                            else:
                                result["results"]["weaviate_where_search"] = {
                                    "error": "Collection inaccessible"
                                }
                        else:
                            result["results"]["weaviate_where_search"] = {
                                "error": "Aucune collection utilisable trouvée"
                            }
                    else:
                        result["results"]["weaviate_where_search"] = {
                            "error": "Erreur récupération collections"
                        }

            except Exception as e:
                result["results"]["weaviate_where_search"] = {"error": str(e)}

            # Analyse et recommandations
            embedding_found = (
                result["results"].get("embedding_search", {}).get("documents_found", 0)
            )
            bm25_found = (
                result["results"].get("bm25_search", {}).get("documents_found", 0)
            )
            where_found = (
                result["results"]
                .get("weaviate_where_search", {})
                .get("documents_found", 0)
            )

            if embedding_found == 0 and bm25_found == 0 and where_found == 0:
                result["recommendations"].append(
                    "CRITIQUE: Document introuvable par toutes les méthodes - possiblement absent"
                )
            elif where_found > 0 and embedding_found == 0:
                result["recommendations"].append(
                    "Document présent mais problème d'embedding - vérifier la vectorisation"
                )
            elif bm25_found > 0 and embedding_found == 0:
                result["recommendations"].append(
                    "Document présent mais embedding ne matche pas - vérifier la qualité des embeddings"
                )
            elif embedding_found > 0:
                result["recommendations"].append(
                    "Document trouvé par embedding - problème possible dans les filtres ou seuils"
                )

            return safe_serialize_for_json(result)

        except Exception as e:
            logger.error(f"Erreur search_specific_document: {e}")
            return {"error": str(e), "timestamp": time.time()}

    # ========================================================================
    # AUTRES ENDPOINTS INCHANGÉS
    # ========================================================================

    @router.get(f"{BASE_PATH}/diagnostic/rag")
    async def rag_diagnostic():
        """Diagnostic complet du système RAG - Version async optimisée"""
        start_time = time.time()

        result = {
            "diagnostic_version": "2.2.0-modular-fixed",
            "timestamp": time.time(),
            "tests": [],
            "summary": {},
            "issues": [],
            "recommendations": [],
        }

        try:
            test_tasks = [
                _test_weaviate_basic(services),
                _test_embedding_basic(services),
                _test_search_ross308(services),
            ]

            test_results = await asyncio.gather(*test_tasks, return_exceptions=True)

            for i, test_result in enumerate(test_results):
                if isinstance(test_result, Exception):
                    result["tests"].append(
                        {
                            "name": f"test_{i+1}",
                            "success": False,
                            "error": str(test_result),
                        }
                    )
                else:
                    result["tests"].append(test_result)

            successful_tests = sum(
                1 for test in result["tests"] if test.get("success", False)
            )
            total_tests = len(result["tests"])

            result["summary"] = {
                "total_tests": total_tests,
                "successful_tests": successful_tests,
                "success_rate": (
                    successful_tests / total_tests if total_tests > 0 else 0
                ),
                "total_duration": time.time() - start_time,
                "overall_status": (
                    "healthy" if successful_tests >= total_tests * 0.8 else "degraded"
                ),
            }

            for test in result["tests"]:
                if "issues" in test:
                    result["issues"].extend(test["issues"])

            if result["summary"]["success_rate"] < 0.5:
                result["recommendations"].append(
                    "CRITIQUE: Taux de réussite faible - vérifier la configuration Weaviate"
                )

            return safe_serialize_for_json(result)

        except Exception as e:
            logger.error(f"Erreur diagnostic RAG: {e}")
            result.update(
                {
                    "status": "error",
                    "error": str(e),
                    "total_duration": time.time() - start_time,
                }
            )
            return JSONResponse(
                status_code=500, content=safe_serialize_for_json(result)
            )

    @router.get(f"{BASE_PATH}/diagnostic/quick-test")
    async def quick_rag_test():
        """Test rapide pour vérifier si le RAG fonctionne"""
        try:
            health_monitor = get_service("health_monitor")
            if not health_monitor:
                return {"status": "error", "message": "Health monitor non disponible"}

            rag_engine = health_monitor.get_service("rag_engine_enhanced")
            if not rag_engine:
                return {"status": "error", "message": "RAG engine non disponible"}

            result = await rag_engine.generate_response(
                query="poids Ross 308", tenant_id="quick_test"
            )

            return {
                "status": "success",
                "query": "poids Ross 308",
                "source": (
                    result.source.value
                    if hasattr(result.source, "value")
                    else str(result.source)
                ),
                "confidence": result.confidence,
                "documents_used": result.metadata.get("documents_used", 0),
                "has_response": bool(
                    getattr(result, "answer", "") or getattr(result, "response", "")
                ),
                "timestamp": time.time(),
            }

        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "error_type": type(e).__name__,
                "timestamp": time.time(),
            }

    # AJOUTEZ CE CODE À LA FIN DE endpoints_diagnostic.py
    # Juste avant "return router" (ligne 795 environ)

    # ========================================================================
    # DIAGNOSTIC DIGITAL OCEAN WEAVIATE
    # ========================================================================

    @router.get(f"{BASE_PATH}/diagnostic/weaviate-digitalocean")
    async def weaviate_digitalocean_diagnostic():
        """Diagnostic complet Weaviate pour Digital Ocean App Platform"""

        diagnostic_results = {
            "timestamp": time.time(),
            "platform": "Digital Ocean App Platform",
            "diagnostic_version": "1.0",
            "steps": {},
            "summary": {},
            "recommendations": [],
        }

        try:
            # 1. Variables d'environnement
            diagnostic_results["steps"]["environment_vars"] = {
                "weaviate_url": os.getenv("WEAVIATE_URL", "NON DÉFINIE"),
                "weaviate_api_key_present": bool(os.getenv("WEAVIATE_API_KEY")),
                "weaviate_api_key_length": len(os.getenv("WEAVIATE_API_KEY", "")),
                "openai_api_key_present": bool(os.getenv("OPENAI_API_KEY")),
                "openai_api_key_length": len(os.getenv("OPENAI_API_KEY", "")),
            }

            weaviate_url = os.getenv("WEAVIATE_URL")

            if not weaviate_url:
                diagnostic_results["summary"][
                    "critical_error"
                ] = "WEAVIATE_URL non définie"
                diagnostic_results["recommendations"].append(
                    "Configurer WEAVIATE_URL dans les variables d'environnement Digital Ocean"
                )
                return safe_serialize_for_json(diagnostic_results)

            # 2. Parse de l'URL
            try:
                from urllib.parse import urlparse

                parsed_url = urlparse(weaviate_url)
                diagnostic_results["steps"]["url_parsing"] = {
                    "scheme": parsed_url.scheme,
                    "hostname": parsed_url.hostname,
                    "port": parsed_url.port
                    or (443 if parsed_url.scheme == "https" else 80),
                    "path": parsed_url.path,
                    "is_cloud": "weaviate.network" in weaviate_url
                    or "weaviate.cloud" in weaviate_url,
                }
            except Exception as e:
                diagnostic_results["steps"]["url_parsing"] = {"error": str(e)}

            # 3. Test de résolution DNS
            try:
                import socket

                hostname = parsed_url.hostname
                if hostname:
                    start_time = time.time()
                    ip_address = socket.gethostbyname(hostname)
                    dns_time = time.time() - start_time
                    diagnostic_results["steps"]["dns_resolution"] = {
                        "status": "success",
                        "hostname": hostname,
                        "ip_address": ip_address,
                        "resolution_time_ms": round(dns_time * 1000, 2),
                    }
                else:
                    diagnostic_results["steps"]["dns_resolution"] = {
                        "error": "Hostname non trouvé dans l'URL"
                    }
            except Exception as e:
                diagnostic_results["steps"]["dns_resolution"] = {
                    "status": "failed",
                    "error": str(e),
                }

            # 4. Test de connectivité TCP
            try:
                import socket

                hostname = parsed_url.hostname
                port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)

                start_time = time.time()
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(10)
                result = sock.connect_ex((hostname, port))
                sock.close()
                tcp_time = time.time() - start_time

                diagnostic_results["steps"]["tcp_connectivity"] = {
                    "status": "success" if result == 0 else "failed",
                    "hostname": hostname,
                    "port": port,
                    "connection_time_ms": round(tcp_time * 1000, 2),
                    "error_code": result if result != 0 else None,
                }
            except Exception as e:
                diagnostic_results["steps"]["tcp_connectivity"] = {
                    "status": "failed",
                    "error": str(e),
                }

            # 5. Test de connexion Python Weaviate
            try:
                # Utiliser le client existant du service si disponible
                health_monitor = get_service("health_monitor")
                existing_client = None

                if health_monitor:
                    rag_engine = health_monitor.get_service("rag_engine_enhanced")
                    if rag_engine:
                        existing_client = safe_get_attribute(
                            rag_engine, "weaviate_client"
                        )

                if existing_client:
                    # Test avec le client existant
                    try:
                        is_ready = await asyncio.wait_for(
                            asyncio.to_thread(lambda: existing_client.is_ready()),
                            timeout=15.0,
                        )

                        diagnostic_results["steps"]["python_weaviate_connection"] = {
                            "status": "success" if is_ready else "failed",
                            "client_type": "existing_service_client",
                            "is_ready": is_ready,
                            "test_method": "service_client",
                        }

                        # Test des capacités si connecté
                        if is_ready:
                            try:
                                if hasattr(existing_client, "collections"):
                                    collections = await asyncio.to_thread(
                                        lambda: list(
                                            existing_client.collections.list_all()
                                        )
                                    )
                                    diagnostic_results["steps"][
                                        "python_weaviate_connection"
                                    ]["collections_count"] = len(collections)
                                    diagnostic_results["steps"][
                                        "python_weaviate_connection"
                                    ]["collections_accessible"] = True
                                else:
                                    diagnostic_results["steps"][
                                        "python_weaviate_connection"
                                    ]["weaviate_version"] = "v3_or_older"
                            except Exception as collections_error:
                                diagnostic_results["steps"][
                                    "python_weaviate_connection"
                                ]["collections_error"] = str(collections_error)

                    except asyncio.TimeoutError:
                        diagnostic_results["steps"]["python_weaviate_connection"] = {
                            "status": "timeout",
                            "error": "Timeout de 15 secondes dépassé",
                            "test_method": "service_client",
                        }
                    except Exception as e:
                        diagnostic_results["steps"]["python_weaviate_connection"] = {
                            "status": "failed",
                            "error": str(e),
                            "error_type": type(e).__name__,
                            "test_method": "service_client",
                        }

                else:
                    diagnostic_results["steps"]["python_weaviate_connection"] = {
                        "status": "skipped",
                        "reason": "Aucun client Weaviate disponible dans les services",
                    }

            except Exception as e:
                diagnostic_results["steps"]["python_weaviate_connection"] = {
                    "status": "failed",
                    "error": str(e),
                    "error_type": type(e).__name__,
                }

            # 6. Analyse des résultats et recommandations
            diagnostic_results["summary"] = _analyze_do_diagnostic_results(
                diagnostic_results["steps"]
            )
            diagnostic_results["recommendations"] = _generate_do_recommendations(
                diagnostic_results["steps"], diagnostic_results["summary"]
            )

        except Exception as e:
            diagnostic_results["critical_error"] = {
                "error": str(e),
                "error_type": type(e).__name__,
            }

        return safe_serialize_for_json(diagnostic_results)

    # ========================================================================
    # FONCTIONS D'AIDE POUR LE DIAGNOSTIC DIGITAL OCEAN
    # ========================================================================

    def _analyze_do_diagnostic_results(steps: dict) -> dict:
        """Analyse les résultats du diagnostic Digital Ocean"""
        summary = {
            "overall_status": "unknown",
            "critical_issues": [],
            "warnings": [],
            "working_components": [],
        }

        # Analyse des variables d'environnement
        env_vars = steps.get("environment_vars", {})
        if (
            not env_vars.get("weaviate_url")
            or env_vars.get("weaviate_url") == "NON DÉFINIE"
        ):
            summary["critical_issues"].append("WEAVIATE_URL non configurée")
        else:
            summary["working_components"].append("WEAVIATE_URL configurée")

        if not env_vars.get("weaviate_api_key_present"):
            summary["critical_issues"].append("WEAVIATE_API_KEY non configurée")
        else:
            summary["working_components"].append("WEAVIATE_API_KEY présente")

        # Analyse de la connectivité
        dns = steps.get("dns_resolution", {})
        if dns.get("status") == "success":
            summary["working_components"].append("Résolution DNS")
        elif dns.get("status") == "failed":
            summary["critical_issues"].append("Résolution DNS échouée")

        tcp = steps.get("tcp_connectivity", {})
        if tcp.get("status") == "success":
            summary["working_components"].append("Connectivité TCP")
        elif tcp.get("status") == "failed":
            summary["critical_issues"].append("Connectivité TCP échouée")

        python_conn = steps.get("python_weaviate_connection", {})
        if python_conn.get("status") == "success" and python_conn.get("is_ready"):
            summary["working_components"].append(
                "Connexion Python Weaviate fonctionnelle"
            )
        elif python_conn.get("status") == "failed":
            summary["critical_issues"].append("Connexion Python Weaviate échouée")
        elif python_conn.get("status") == "timeout":
            summary["critical_issues"].append("Timeout connexion Python Weaviate")

        # Détermination du statut global
        if summary["critical_issues"]:
            summary["overall_status"] = "critical"
        elif summary["warnings"]:
            summary["overall_status"] = "warning"
        elif summary["working_components"]:
            summary["overall_status"] = "healthy"
        else:
            summary["overall_status"] = "unknown"

        return summary

    def _generate_do_recommendations(steps: dict, summary: dict) -> list:
        """Génère des recommandations basées sur les résultats"""
        recommendations = []

        env_vars = steps.get("environment_vars", {})

        if (
            not env_vars.get("weaviate_url")
            or env_vars.get("weaviate_url") == "NON DÉFINIE"
        ):
            recommendations.append(
                {
                    "priority": "critical",
                    "action": "Configurer WEAVIATE_URL",
                    "details": "Ajouter WEAVIATE_URL dans les variables d'environnement Digital Ocean App Platform",
                    "example": "https://votre-cluster.weaviate.network",
                }
            )

        if not env_vars.get("weaviate_api_key_present"):
            recommendations.append(
                {
                    "priority": "critical",
                    "action": "Configurer WEAVIATE_API_KEY",
                    "details": "Ajouter WEAVIATE_API_KEY dans les variables d'environnement Digital Ocean",
                    "note": "Clé API disponible dans votre console Weaviate Cloud",
                }
            )

        dns = steps.get("dns_resolution", {})
        if dns.get("status") == "failed":
            recommendations.append(
                {
                    "priority": "high",
                    "action": "Vérifier la connectivité réseau",
                    "details": "Le serveur Digital Ocean ne peut pas résoudre le hostname Weaviate",
                    "solutions": [
                        "Vérifier que l'URL Weaviate est correcte",
                        "Vérifier la configuration réseau Digital Ocean",
                        "Tester depuis un autre environnement",
                    ],
                }
            )

        tcp = steps.get("tcp_connectivity", {})
        if tcp.get("status") == "failed":
            recommendations.append(
                {
                    "priority": "high",
                    "action": "Résoudre le problème de connectivité TCP",
                    "details": f"Impossible de se connecter au port {tcp.get('port', 'inconnu')}",
                    "solutions": [
                        "Vérifier que Weaviate est accessible depuis Internet",
                        "Vérifier les règles de firewall",
                        "Vérifier la configuration réseau Digital Ocean",
                    ],
                }
            )

        python_conn = steps.get("python_weaviate_connection", {})
        if python_conn.get("status") == "timeout":
            recommendations.append(
                {
                    "priority": "medium",
                    "action": "Optimiser les timeouts",
                    "details": "La connexion Python Weaviate dépasse le timeout de 15s",
                    "solutions": [
                        "Vérifier la latence réseau",
                        "Augmenter les timeouts dans la configuration",
                        "Vérifier les performances de l'instance Weaviate",
                    ],
                }
            )

        return recommendations

    return router


# ============================================================================
# FONCTIONS D'AIDE POUR LES TESTS - VERSIONS CORRIGÉES
# ============================================================================


async def _test_weaviate_basic(services: Dict) -> Dict:
    """Test basique de connexion Weaviate - VERSION CORRIGÉE"""
    result = {
        "name": "weaviate_connection",
        "success": False,
        "details": {},
        "issues": [],
    }

    try:
        health_monitor = services.get("health_monitor")
        if not health_monitor:
            result["issues"].append("Health Monitor manquant")
            return result

        rag_engine = health_monitor.get_service("rag_engine_enhanced")
        if not rag_engine:
            result["issues"].append("RAG Engine manquant")
            return result

        weaviate_client = safe_get_attribute(rag_engine, "weaviate_client")
        if not weaviate_client:
            result["issues"].append("Client Weaviate manquant")
            return result

        is_ready = await asyncio.get_event_loop().run_in_executor(
            None, weaviate_client.is_ready
        )

        if is_ready:
            result["success"] = True
            result["details"]["is_ready"] = True

            try:
                if hasattr(weaviate_client, "collections"):
                    collections_data = await asyncio.get_event_loop().run_in_executor(
                        None, lambda: weaviate_client.collections.list_all()
                    )

                    if isinstance(collections_data, dict):
                        collection_names = list(collections_data.keys())
                    else:
                        collection_names = list(collections_data)

                    total_docs = 0
                    for collection_name in collection_names:
                        try:
                            collection = weaviate_client.collections.get(
                                collection_name
                            )
                            count = await asyncio.get_event_loop().run_in_executor(
                                None,
                                lambda c=collection: c.aggregate.over_all(
                                    total_count=True
                                ),
                            )
                            total_docs += getattr(count, "total_count", 0)
                        except Exception:
                            pass

                    result["details"]["total_documents"] = total_docs
                    if total_docs == 0:
                        result["issues"].append("Aucun document dans Weaviate")

            except Exception as e:
                result["issues"].append(f"Erreur comptage documents: {e}")
        else:
            result["issues"].append("Weaviate pas ready")

    except Exception as e:
        result["issues"].append(f"Erreur test Weaviate: {e}")

    return result


async def _test_embedding_basic(services: Dict) -> Dict:
    """Test basique de génération d'embeddings"""
    result = {
        "name": "embedding_generation",
        "success": False,
        "details": {},
        "issues": [],
    }

    try:
        health_monitor = services.get("health_monitor")
        if not health_monitor:
            result["issues"].append("Health Monitor manquant")
            return result

        rag_engine = health_monitor.get_service("rag_engine_enhanced")
        if not rag_engine:
            result["issues"].append("RAG Engine manquant")
            return result

        embedder = safe_get_attribute(rag_engine, "embedder")
        if not embedder:
            result["issues"].append("Embedder manquant")
            return result

        embedding = await embedder.get_embedding("test Ross 308")
        if embedding and len(embedding) > 0:
            result["success"] = True
            result["details"] = {
                "dimension": len(embedding),
                "has_numeric_values": all(
                    isinstance(x, (int, float)) for x in embedding[:5]
                ),
            }
        else:
            result["issues"].append("Embedding vide ou invalide")

    except Exception as e:
        result["issues"].append(f"Erreur test embedding: {e}")

    return result


async def _test_search_ross308(services: Dict) -> Dict:
    """Test spécifique de recherche Ross 308"""
    result = {"name": "search_ross308", "success": False, "details": {}, "issues": []}

    try:
        health_monitor = services.get("health_monitor")
        if not health_monitor:
            result["issues"].append("Health Monitor manquant")
            return result

        rag_engine = health_monitor.get_service("rag_engine_enhanced")
        if not rag_engine:
            result["issues"].append("RAG Engine manquant")
            return result

        retriever = safe_get_attribute(rag_engine, "retriever")
        embedder = safe_get_attribute(rag_engine, "embedder")

        if not retriever or not embedder:
            result["issues"].append("Retriever ou Embedder manquant")
            return result

        test_queries = [
            "Ross 308 performance objectives",
            "Ross 308 broiler weight table",
            "RossxRoss308 BroilerPerformanceObjectives",
        ]

        found_documents = 0
        has_performance_doc = False

        for query in test_queries:
            try:
                embedding = await embedder.get_embedding(query)
                if embedding:
                    docs = await retriever.hybrid_search(
                        query_vector=embedding,
                        query_text=query,
                        top_k=5,
                        where_filter=None,
                        alpha=0.5,
                    )

                    found_documents += len(docs)

                    for doc in docs:
                        title = getattr(doc, "metadata", {}).get("title", "")
                        content = getattr(doc, "content", "")
                        if (
                            "performance" in title.lower()
                            or "performance" in content.lower()
                        ) and "ross" in content.lower():
                            has_performance_doc = True
                            break

            except Exception as e:
                result["issues"].append(f"Erreur recherche '{query}': {e}")

        result["details"] = {
            "total_documents_found": found_documents,
            "has_performance_document": has_performance_doc,
            "queries_tested": len(test_queries),
        }

        if found_documents > 0:
            result["success"] = True
            if not has_performance_doc:
                result["issues"].append(
                    "Documents Ross 308 trouvés mais pas de données de performance"
                )
        else:
            result["issues"].append("CRITIQUE: Aucun document Ross 308 trouvé")

    except Exception as e:
        result["issues"].append(f"Erreur test Ross 308: {e}")

    return result
