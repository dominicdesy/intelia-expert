# -*- coding: utf-8 -*-
"""
post_processor.py - Response post-processing utilities
Version: 1.4.1
Last modified: 2025-10-27
Migrated from ai-service to llm service
"""
"""
Post-processor for LLM-generated responses.

This module provides methods to:
- Clean and format responses
- Add veterinary disclaimers when appropriate
- Remove unwanted formatting artifacts
"""

import logging
import re
from typing import List, Dict, Optional

logger = logging.getLogger(__name__)


class ResponsePostProcessor:
    """
    Post-processor for LLM-generated responses.

    This class provides methods to:
    - Clean and format responses
    - Add veterinary disclaimers when appropriate
    - Remove unwanted formatting artifacts
    """

    def __init__(self, veterinary_terms: Optional[Dict] = None, language_messages: Optional[Dict] = None):
        """
        Initialize post-processor

        Args:
            veterinary_terms: Dictionary of veterinary terms by language
            language_messages: Dictionary of system messages by language
        """
        self.veterinary_terms = veterinary_terms or {}
        self.language_messages = language_messages or {}

        # Flatten veterinary keywords for detection
        self.veterinary_keywords = self._load_veterinary_keywords()

        logger.info(f"✅ ResponsePostProcessor initialized with {len(self.veterinary_keywords)} veterinary terms")

    def _load_veterinary_keywords(self) -> List[str]:
        """
        Extract all veterinary keywords from config

        Returns:
            List of lowercase keywords
        """
        keywords = []

        # Extract all categories (diseases, symptoms, treatments, etc.)
        for category_name, category_data in self.veterinary_terms.items():
            if category_name == "metadata":
                continue

            # Each category has language keys (fr, en, de, etc.)
            if isinstance(category_data, dict):
                for lang_code, terms_list in category_data.items():
                    if isinstance(terms_list, list):
                        keywords.extend(terms_list)

        # Remove duplicates and convert to lowercase
        keywords = list(set([kw.lower() for kw in keywords]))

        return keywords

    def post_process_response(
        self,
        response: str,
        query: str = "",
        language: str = "en",
        context_docs: Optional[List[Dict]] = None,
    ) -> str:
        """
        Post-processes response with automatic veterinary disclaimer addition.

        This method performs several operations:
        1. Cleans formatting artifacts (bold headers, orphan asterisks, etc.)
        2. Normalizes whitespace and line breaks
        3. Adds veterinary disclaimers if the query is health-related

        Args:
            response: Response generated by the LLM
            query: Original user question
            language: Response language code
            context_docs: Context documents used for generation

        Returns:
            Post-processed response with disclaimer if necessary

        Examples:
            >>> processor = ResponsePostProcessor()
            >>> response = "**Header:** Some text\\n\\n1. First item\\n2. Second item"
            >>> processor.post_process_response(response, "", "en")
            'Some text\\n\\n- First item\\n- Second item'
        """
        response = response.strip()

        # ✅ IMPROVED FORMATTING CLEANUP

        # 1. Remove markdown headers (##, ###, ####, etc.) - converts "## Title" to "Title"
        response = re.sub(r"^#{1,6}\s+", "", response, flags=re.MULTILINE)

        # 2. Remove list numbers (1., 2., etc.)
        response = re.sub(r"^\d+\.\s+", "", response, flags=re.MULTILINE)

        # 3. Clean orphan asterisks (lines with just ** or **)
        response = re.sub(r"^\*\*\s*$", "", response, flags=re.MULTILINE)

        # 4. COMPLETELY REMOVE bold headers (**Title:** or **Title**)
        # This rule replaces the old rules that tried to "fix" headers
        response = re.sub(r"\*\*([^*]+?):\*\*\s*", "", response)
        response = re.sub(r"\*\*([^*]+?)\*\*\s*:", "", response)

        # 5. Clean orphan colons on isolated lines
        response = re.sub(r"^\s*:\s*$", "", response, flags=re.MULTILINE)

        # 6. Fix broken titles - join short lines (titles) that are split across multiple lines
        # Pattern: Short line ending with lowercase + newline + lowercase start = broken title
        # Example: "Standardisation des\nprocédures" -> "Standardisation des procédures"
        response = re.sub(
            r"^([A-ZÀ-Ý][^\n]{5,60}[a-zà-ÿ])\n([a-zà-ÿ])",
            r"\1 \2",
            response,
            flags=re.MULTILINE
        )

        # 7. Clean multiple empty lines (3+ → 2)
        response = re.sub(r"\n{3,}", "\n\n", response)

        # 8. Remove trailing spaces
        response = re.sub(r" +$", "", response, flags=re.MULTILINE)

        # 9. Ensure space after bullet points
        response = re.sub(r"^-([^ ])", r"- \1", response, flags=re.MULTILINE)

        # Add veterinary disclaimer if the question concerns health/disease
        if query and self.is_veterinary_query(query, context_docs):
            disclaimer = self.get_veterinary_disclaimer(language)
            if disclaimer:  # Only if disclaimer is not empty
                response = response + disclaimer
                logger.info(f"🏥 Veterinary disclaimer added (language: {language})")

        return response

    def is_veterinary_query(self, query: str, context_docs: Optional[List[Dict]] = None) -> bool:
        """
        Detects if the question concerns a veterinary topic.

        Args:
            query: User's question
            context_docs: Retrieved context documents (optional)

        Returns:
            True if the query is veterinary-related
        """
        if not query:
            return False

        query_lower = query.lower()

        # Check query for veterinary keywords
        for keyword in self.veterinary_keywords:
            if keyword in query_lower:
                logger.debug(f"Veterinary keyword detected in query: '{keyword}'")
                return True

        # Check context documents if provided
        if context_docs:
            for doc in context_docs:
                # Handle dict format
                if isinstance(doc, dict):
                    content = doc.get("page_content", "") or doc.get("content", "")
                    metadata = doc.get("metadata", {})
                else:
                    # Handle Document object
                    content = getattr(doc, "page_content", "")
                    metadata = getattr(doc, "metadata", {})

                # Check document category
                category = metadata.get("category", "").lower()
                if category in ["health", "santé", "disease", "maladie", "veterinary"]:
                    logger.debug(f"Veterinary category detected in context: '{category}'")
                    return True

                # Check document content
                content_lower = content.lower()
                for keyword in self.veterinary_keywords[:20]:  # Check first 20 keywords in content
                    if keyword in content_lower:
                        logger.debug(f"Veterinary keyword detected in context: '{keyword}'")
                        return True

        return False

    def get_veterinary_disclaimer(self, language: str = "en") -> str:
        """
        Get veterinary disclaimer in specified language

        Args:
            language: Language code (e.g., "fr", "en", "es")

        Returns:
            Veterinary disclaimer string with formatting
        """
        # Get messages for language
        messages = self.language_messages.get("messages", {})
        language_messages = messages.get(language, messages.get("en", {}))

        disclaimer_text = language_messages.get("veterinary_disclaimer", "")

        if disclaimer_text:
            # Add spacing around disclaimer
            return f"\n\n{disclaimer_text}"

        return ""


# Factory function for easy instantiation
def create_post_processor(veterinary_terms: Optional[Dict] = None,
                         language_messages: Optional[Dict] = None) -> ResponsePostProcessor:
    """
    Create a ResponsePostProcessor instance

    Args:
        veterinary_terms: Dictionary of veterinary terms by language
        language_messages: Dictionary of system messages by language

    Returns:
        Configured ResponsePostProcessor instance
    """
    return ResponsePostProcessor(veterinary_terms, language_messages)
