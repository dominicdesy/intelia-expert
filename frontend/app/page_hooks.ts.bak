// page_hooks.ts - Version avec correction dÃ©finitive du re-render + RememberMe intÃ©grÃ©
import { useState, useEffect, useMemo, useRef, useCallback } from 'react'
import type { Country } from './page_types'

// Fallback countries
const fallbackCountries: Country[] = [
  { value: 'CA', label: 'Canada', phoneCode: '+1', flag: 'ğŸ‡¨ğŸ‡¦' },
  { value: 'US', label: 'Ã‰tats-Unis', phoneCode: '+1', flag: 'ğŸ‡ºğŸ‡¸' },
  { value: 'FR', label: 'France', phoneCode: '+33', flag: 'ğŸ‡«ğŸ‡·' },
  { value: 'GB', label: 'Royaume-Uni', phoneCode: '+44', flag: 'ğŸ‡¬ğŸ‡§' },
  { value: 'DE', label: 'Allemagne', phoneCode: '+49', flag: 'ğŸ‡©ğŸ‡ª' },
  { value: 'IT', label: 'Italie', phoneCode: '+39', flag: 'ğŸ‡®ğŸ‡¹' },
  { value: 'ES', label: 'Espagne', phoneCode: '+34', flag: 'ğŸ‡ªğŸ‡¸' },
  { value: 'BE', label: 'Belgique', phoneCode: '+32', flag: 'ğŸ‡§ğŸ‡ª' },
  { value: 'CH', label: 'Suisse', phoneCode: '+41', flag: 'ğŸ‡¨ğŸ‡­' },
  { value: 'MX', label: 'Mexique', phoneCode: '+52', flag: 'ğŸ‡²ğŸ‡½' },
  { value: 'BR', label: 'BrÃ©sil', phoneCode: '+55', flag: 'ğŸ‡§ğŸ‡·' },
  { value: 'AU', label: 'Australie', phoneCode: '+61', flag: 'ğŸ‡¦ğŸ‡º' },
  { value: 'JP', label: 'Japon', phoneCode: '+81', flag: 'ğŸ‡¯ğŸ‡µ' },
  { value: 'CN', label: 'Chine', phoneCode: '+86', flag: 'ğŸ‡¨ğŸ‡³' },
  { value: 'IN', label: 'Inde', phoneCode: '+91', flag: 'ğŸ‡®ğŸ‡³' },
  { value: 'NL', label: 'Pays-Bas', phoneCode: '+31', flag: 'ğŸ‡³ğŸ‡±' },
  { value: 'SE', label: 'SuÃ¨de', phoneCode: '+46', flag: 'ğŸ‡¸ğŸ‡ª' },
  { value: 'NO', label: 'NorvÃ¨ge', phoneCode: '+47', flag: 'ğŸ‡³ğŸ‡´' },
  { value: 'DK', label: 'Danemark', phoneCode: '+45', flag: 'ğŸ‡©ğŸ‡°' },
  { value: 'FI', label: 'Finlande', phoneCode: '+358', flag: 'ğŸ‡«ğŸ‡®' }
]

// Cache global pour Ã©viter les multiples appels API
let countriesCache: Country[] | null = null
let isLoadingGlobal = false
let loadingPromise: Promise<Country[]> | null = null

// Version optimisÃ©e des logs pour rÃ©duire le "bruit"
const DEBUG_MODE = process.env.NODE_ENV === 'development'

const debugLog = (category: string, message: string, data?: any) => {
  if (!DEBUG_MODE) return
  
  const emoji = {
    form: 'ğŸ“',
    auth: 'ğŸ”', 
    storage: 'ğŸ’¾',
    error: 'âŒ',
    success: 'âœ…',
    countries: 'ğŸŒ'
  }
  
  console.log(`${emoji[category] || 'ğŸ”'} [${category}] ${message}`, data ? data : '')
}

// CORRECTION CRITIQUE : Fonction de fetch hors du hook pour Ã©viter les re-crÃ©ations
const fetchCountriesGlobal = async (): Promise<Country[]> => {
  // Si on a dÃ©jÃ  les donnÃ©es en cache, les retourner
  if (countriesCache) {
    debugLog('countries', 'DonnÃ©es dÃ©jÃ  en cache')
    return countriesCache
  }

  // Si un chargement est dÃ©jÃ  en cours, attendre sa fin
  if (loadingPromise) {
    debugLog('countries', 'Chargement en cours, attente...')
    return loadingPromise
  }

  // CrÃ©er une nouvelle promesse de chargement
  loadingPromise = new Promise(async (resolve) => {
    try {
      debugLog('countries', 'DÃ©but du chargement depuis l\'API REST Countries...')
      
      isLoadingGlobal = true
      
      const controller = new AbortController()
      const timeoutId = setTimeout(() => {
        debugLog('countries', 'Timeout atteint (10s)')
        controller.abort()
      }, 10000)
      
      const response = await fetch('https://restcountries.com/v3.1/all?fields=cca2,name,idd,flag,translations', {
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'Mozilla/5.0 (compatible; Intelia/1.0)',
          'Cache-Control': 'no-cache'
        },
        signal: controller.signal
      })
      
      clearTimeout(timeoutId)
      debugLog('countries', `Statut HTTP: ${response.status} ${response.statusText}`)
      
      if (!response.ok) {
        throw new Error(`API indisponible: ${response.status}`)
      }
      
      const data = await response.json()
      debugLog('countries', `DonnÃ©es reÃ§ues: ${data.length} pays bruts`)
      
      if (!Array.isArray(data)) {
        debugLog('error', 'Format invalide - pas un array')
        throw new Error('Format de donnÃ©es invalide')
      }
      
      const formattedCountries = data
        .map((country: any) => {
          let phoneCode = ''
          if (country.idd?.root) {
            phoneCode = country.idd.root
            if (country.idd.suffixes && country.idd.suffixes[0]) {
              phoneCode += country.idd.suffixes[0]
            }
          }
          
          return {
            value: country.cca2,
            label: country.translations?.fra?.common || country.name?.common || country.cca2,
            phoneCode: phoneCode,
            flag: country.flag || ''
          }
        })
        .filter((country: Country) => {
          const hasValidCode = country.phoneCode && 
                              country.phoneCode !== 'undefined' && 
                              country.phoneCode !== 'null' &&
                              country.phoneCode.length > 1 &&
                              country.phoneCode.startsWith('+') &&
                              /^\+\d+$/.test(country.phoneCode)
          
          const hasValidInfo = country.value && 
                              country.value.length === 2 &&
                              country.label && 
                              country.label.length > 1
          
          return hasValidCode && hasValidInfo
        })
        .sort((a: Country, b: Country) => a.label.localeCompare(b.label, 'fr', { numeric: true }))
      
      debugLog('countries', `Pays valides aprÃ¨s filtrage: ${formattedCountries.length}`)
      
      if (formattedCountries.length >= 50) {
        debugLog('success', 'API validÃ©e! Utilisation des donnÃ©es complÃ¨tes')
        
        // Mise en cache globale
        countriesCache = formattedCountries
        resolve(formattedCountries)
      } else {
        debugLog('error', `Pas assez de pays valides: ${formattedCountries.length}/50`)
        throw new Error(`QualitÃ© insuffisante: ${formattedCountries.length}/50 pays`)
      }
      
    } catch (err: any) {
      debugLog('error', 'ERREUR:', err)
      debugLog('countries', 'Passage en mode fallback')
      
      // MÃªme le fallback va en cache pour Ã©viter les re-fetch
      countriesCache = fallbackCountries
      resolve(fallbackCountries)
    } finally {
      debugLog('countries', 'Chargement terminÃ©')
      isLoadingGlobal = false
      // Nettoyer la promesse aprÃ¨s utilisation
      loadingPromise = null
    }
  })

  return loadingPromise
}

// Hook pour charger les pays depuis l'API REST Countries - VERSION DÃ‰FINITIVEMENT CORRIGÃ‰E
export const useCountries = () => {
  debugLog('countries', 'Hook useCountries appelÃ©!')
  
  // Ã‰tat initial basÃ© sur le cache
  const [countries, setCountries] = useState<Country[]>(() => 
    countriesCache || fallbackCountries
  )
  const [loading, setLoading] = useState(() => countriesCache === null)
  const [usingFallback, setUsingFallback] = useState(() => countriesCache === null)
  
  // RÃ©fÃ©rences pour Ã©viter les re-renders
  const hasFetched = useRef(false)
  const isMounted = useRef(true)

  // CORRECTION CRITIQUE : useEffect sans dÃ©pendances pour Ã©viter les re-dÃ©clenchements
  useEffect(() => {
    // Ã‰viter les doubles appels en mode strict
    if (hasFetched.current) {
      debugLog('countries', 'Fetch dÃ©jÃ  effectuÃ©, skip')
      return
    }
    
    hasFetched.current = true
    debugLog('countries', 'DÃ‰MARRAGE du processus de chargement des pays')
    
    // Si on a dÃ©jÃ  les donnÃ©es en cache, les utiliser immÃ©diatement
    if (countriesCache) {
      debugLog('countries', 'Utilisation du cache existant')
      setCountries(countriesCache)
      setUsingFallback(false)
      setLoading(false)
      return
    }
    
    // DÃ©lai pour Ã©viter les conflits avec l'hydratation
    const timer = setTimeout(async () => {
      if (isMounted.current) {
        debugLog('countries', 'DÃ©marrage aprÃ¨s dÃ©lai de 100ms')
        try {
          const result = await fetchCountriesGlobal()
          if (isMounted.current) {
            setCountries(result)
            setUsingFallback(result === fallbackCountries)
            setLoading(false)
          }
        } catch (error) {
          debugLog('error', 'Erreur dans le timer:', error)
          if (isMounted.current) {
            setCountries(fallbackCountries)
            setUsingFallback(true)
            setLoading(false)
          }
        }
      }
    }, 100)
    
    // Cleanup function
    return () => {
      clearTimeout(timer)
      isMounted.current = false
    }
  }, []) // CORRECTION CRITIQUE : Aucune dÃ©pendance pour Ã©viter les re-dÃ©clenchements

  // Cleanup au dÃ©montage
  useEffect(() => {
    return () => {
      isMounted.current = false
    }
  }, [])

  debugLog('countries', `Render - ${countries.length} pays, loading:${loading}, fallback:${usingFallback}`)
  
  // MÃ©moisation du retour pour Ã©viter les re-renders des composants parents
  return useMemo(() => ({
    countries,
    loading,
    usingFallback
  }), [countries, loading, usingFallback])
}

// Hook pour crÃ©er le mapping des codes tÃ©lÃ©phoniques - OPTIMISÃ‰
export const useCountryCodeMap = (countries: Country[]) => {
  return useMemo(() => {
    const mapping = countries.reduce((acc, country) => {
      acc[country.value] = country.phoneCode
      return acc
    }, {} as Record<string, string>)
    
    debugLog('countries', `Mapping crÃ©Ã© avec ${Object.keys(mapping).length} entrÃ©es`)
    
    return mapping
  }, [countries])
}

// Fonctions de validation - INCHANGÃ‰ES
export const validateEmail = (email: string): boolean => {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
}

export const validatePassword = (password: string): { isValid: boolean; errors: string[] } => {
  const errors: string[] = []
  
  if (password.length < 8) {
    errors.push('Au moins 8 caractÃ¨res')
  }
  if (!/[A-Z]/.test(password)) {
    errors.push('Une majuscule')
  }
  if (!/[0-9]/.test(password)) {
    errors.push('Un chiffre')
  }
  
  return {
    isValid: errors.length === 0,
    errors
  }
}

export const validatePhone = (countryCode: string, areaCode: string, phoneNumber: string): boolean => {
  if (!countryCode.trim() && !areaCode.trim() && !phoneNumber.trim()) {
    return true
  }
  
  if (countryCode.trim() || areaCode.trim() || phoneNumber.trim()) {
    if (!countryCode.trim() || !/^\+[1-9]\d{0,3}$/.test(countryCode.trim())) {
      return false
    }
    
    if (!areaCode.trim() || !/^\d{3}$/.test(areaCode.trim())) {
      return false
    }
    
    if (!phoneNumber.trim() || !/^\d{7}$/.test(phoneNumber.trim())) {
      return false
    }
  }
  
  return true
}

// Nouvelles fonctions de validation ajoutÃ©es du backup - INCHANGÃ‰ES
export const validateLinkedIn = (url: string): boolean => {
  if (!url.trim()) return true
  return /^(https?:\/\/)?(www\.)?linkedin\.com\/(in|company)\/[\w\-]+\/?$/.test(url)
}

export const validateWebsite = (url: string): boolean => {
  if (!url.trim()) return true
  return /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/.test(url)
}

// ===== NOUVELLE SECTION: RememberMe Utils avec prÃ©servation lors de la dÃ©connexion =====

export const rememberMeUtils = {
  // ClÃ© de stockage spÃ©cifique pour Ã©viter la suppression lors du logout
  STORAGE_KEY: 'intelia-remember-me-persist',

  // Sauvegarder les donnÃ©es remember me
  save: (email: string, rememberMe: boolean): void => {
    try {
      if (!rememberMe || !email.trim()) {
        localStorage.removeItem(rememberMeUtils.STORAGE_KEY)
        debugLog('storage', 'localStorage nettoyÃ©')
        return
      }

      const data = {
        email: email.trim(),
        rememberMe: true,
        timestamp: Date.now(),
        version: '1.0'
      }

      localStorage.setItem(rememberMeUtils.STORAGE_KEY, JSON.stringify(data))
      debugLog('storage', 'SauvegardÃ©:', { email: email.trim(), rememberMe })
    } catch (error) {
      debugLog('error', 'Erreur sauvegarde:', error)
    }
  },

  // Charger les donnÃ©es remember me
  load: (): { rememberMe: boolean; lastEmail: string } => {
    try {
      const stored = localStorage.getItem(rememberMeUtils.STORAGE_KEY)
      
      if (!stored) {
        debugLog('storage', 'Aucune donnÃ©e stockÃ©e')
        return { rememberMe: false, lastEmail: '' }
      }

      const data = JSON.parse(stored)
      
      // VÃ©rifier l'intÃ©gritÃ© des donnÃ©es
      if (!data.email || typeof data.rememberMe !== 'boolean') {
        debugLog('error', 'DonnÃ©es corrompues, nettoyage')
        localStorage.removeItem(rememberMeUtils.STORAGE_KEY)
        return { rememberMe: false, lastEmail: '' }
      }

      // VÃ©rifier l'Ã¢ge des donnÃ©es (30 jours max)
      const age = Date.now() - (data.timestamp || 0)
      const maxAge = 30 * 24 * 60 * 60 * 1000

      if (age > maxAge) {
        debugLog('storage', 'DonnÃ©es expirÃ©es, nettoyage')
        localStorage.removeItem(rememberMeUtils.STORAGE_KEY)
        return { rememberMe: false, lastEmail: '' }
      }

      debugLog('storage', 'DonnÃ©es chargÃ©es:', { 
        email: data.email, 
        rememberMe: data.rememberMe,
        age: Math.round(age / (24 * 60 * 60 * 1000)) + ' jours'
      })

      return {
        rememberMe: data.rememberMe,
        lastEmail: data.email
      }
    } catch (error) {
      debugLog('error', 'Erreur chargement:', error)
      try {
        localStorage.removeItem(rememberMeUtils.STORAGE_KEY)
      } catch (e) {
        debugLog('error', 'Impossible de nettoyer localStorage:', e)
      }
      return { rememberMe: false, lastEmail: '' }
    }
  },

  // Nettoyer explicitement les donnÃ©es
  clear: (): void => {
    try {
      localStorage.removeItem(rememberMeUtils.STORAGE_KEY)
      debugLog('storage', 'DonnÃ©es nettoyÃ©es manuellement')
    } catch (error) {
      debugLog('error', 'Erreur nettoyage:', error)
    }
  },

  // NOUVELLE FONCTION : PrÃ©server RememberMe lors de la dÃ©connexion
  preserveOnLogout: (): { email: string; rememberMe: boolean } | null => {
    const current = rememberMeUtils.load()
    if (current.rememberMe && current.lastEmail) {
      return {
        email: current.lastEmail,
        rememberMe: true
      }
    }
    return null
  },

  // NOUVELLE FONCTION : Restaurer aprÃ¨s dÃ©connexion
  restoreAfterLogout: (preservedData: { email: string; rememberMe: boolean } | null): void => {
    if (preservedData && preservedData.rememberMe) {
      rememberMeUtils.save(preservedData.email, true)
      debugLog('storage', 'RestaurÃ© aprÃ¨s dÃ©connexion:', preservedData.email)
    }
  }
}

// NOUVELLES FONCTIONS : Gestion de la dÃ©connexion avec prÃ©servation RememberMe

export const preserveRememberMeOnLogout = () => {
  const preserved = rememberMeUtils.preserveOnLogout()
  
  return {
    restore: () => {
      if (preserved) {
        rememberMeUtils.restoreAfterLogout(preserved)
      }
    }
  }
}

export const logoutWithRememberMePreservation = async (customLogoutFn?: () => Promise<void>) => {
  try {
    debugLog('auth', 'DÃ©but dÃ©connexion coordonnÃ©e')
    
    // Ã‰TAPE 1 : PrÃ©server les donnÃ©es RememberMe AVANT le nettoyage
    const preservedRememberMe = rememberMeUtils.preserveOnLogout()
    debugLog('auth', 'DonnÃ©es RememberMe prÃ©servÃ©es:', preservedRememberMe)
    
    // Ã‰TAPE 2 : Nettoyage localStorage sÃ©lectif
    debugLog('auth', 'Nettoyage localStorage sÃ©lectif')
    
    // Supprimer toutes les clÃ©s auth SAUF remember-me
    const keysToRemove = []
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i)
      if (key && key !== rememberMeUtils.STORAGE_KEY) {
        // Garder seulement la clÃ© remember-me
        if (key.startsWith('intelia-') || key.includes('auth') || key.includes('session') || key.includes('supabase')) {
          keysToRemove.push(key)
        }
      }
    }
    
    // Supprimer les clÃ©s identifiÃ©es
    keysToRemove.forEach(key => {
      localStorage.removeItem(key)
      debugLog('auth', `SupprimÃ©: ${key}`)
    })
    
    // Ã‰TAPE 3 : DÃ©connexion personnalisÃ©e si fournie
    if (customLogoutFn) {
      await customLogoutFn()
    }
    
    // Ã‰TAPE 4 : Restaurer les donnÃ©es RememberMe APRÃˆS le nettoyage
    if (preservedRememberMe) {
      setTimeout(() => {
        rememberMeUtils.restoreAfterLogout(preservedRememberMe)
        debugLog('auth', 'RememberMe restaurÃ© aprÃ¨s nettoyage')
      }, 100)
    }
    
    // Ã‰TAPE 5 : Redirection
    debugLog('auth', 'Redirection pour Ã©viter callbacks')
    window.location.href = '/'
    
  } catch (error) {
    debugLog('error', 'Erreur lors de la dÃ©connexion:', error)
    // En cas d'erreur, forcer quand mÃªme la redirection
    window.location.href = '/'
  }
}

// Export pour compatibilitÃ© avec le code existant
export { debugLog }