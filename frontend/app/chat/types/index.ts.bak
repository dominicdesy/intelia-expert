// ==================== TYPES PRINCIPAUX ====================

// ✅ INTERFACE MESSAGE ÉTENDUE AVEC COMMENTAIRES FEEDBACK ET CLARIFICATIONS
export interface Message {
  id: string
  content: string
  isUser: boolean
  timestamp: Date
  feedback?: 'positive' | 'negative' | null
  conversation_id?: string
  feedbackComment?: string  // ✅ NOUVEAU: Commentaire associé au feedback
  
  // ✅ NOUVEAUX CHAMPS POUR CLARIFICATION
  is_clarification_request?: boolean       // Pour les messages du bot qui demandent des clarifications
  is_clarification_response?: boolean      // Pour les messages utilisateur qui répondent aux clarifications
  clarification_questions?: string[]       // Questions de clarification du bot
  clarification_answers?: Record<string, string>  // Réponses de clarification de l'utilisateur (optionnel)
  original_question?: string               // Question originale avant clarification
  clarification_entities?: Record<string, any>    // Entités extraites des réponses de clarification
}

export interface ExpertApiResponse {
  question: string
  response: string
  conversation_id: string
  rag_used: boolean
  rag_score?: number
  timestamp: string
  language: string
  response_time_ms: number
  mode: string
  user?: string
  logged: boolean
  validation_passed?: boolean
  validation_confidence?: number
  // 🆕 NOUVEAUX CHAMPS POUR CLARIFICATION
  is_clarification_request?: boolean
  clarification_questions?: string[]
}

// ✅ INTERFACE ConversationData ÉTENDUE AVEC FEEDBACK
export interface ConversationData {
  user_id: string
  question: string
  response: string
  conversation_id: string
  confidence_score?: number
  response_time_ms?: number
  language?: string
  rag_used?: boolean
  feedback?: 1 | -1 | null          // ✅ NOUVEAU: Feedback numérique pour le backend
  feedback_comment?: string          // ✅ NOUVEAU: Commentaire feedback
}

export interface ConversationItem {
  id: string
  title: string
  messages: Array<{
    id: string
    role: string
    content: string
  }>
  updated_at: string
  created_at: string
  feedback?: number | null
  feedback_comment?: string  // ✅ NOUVEAU: Commentaire dans l'historique
}

// ==================== NOUVEAUX TYPES POUR CONVERSATIONS STYLE CLAUDE.AI ====================

// ✅ NOUVEAU: Structure complète d'une conversation
export interface Conversation {
  id: string
  title: string
  preview: string  // Premier message ou résumé
  message_count: number
  created_at: string
  updated_at: string
  feedback?: number | null
  language?: string
  last_message_preview?: string
  status?: 'active' | 'archived'
}

// ✅ NOUVEAU: Conversation complète avec tous ses messages
export interface ConversationWithMessages extends Conversation {
  messages: Message[]
}

// ✅ NOUVEAU: Structure pour l'historique groupé
export interface ConversationGroup {
  title: string  // "Aujourd'hui", "Hier", "Cette semaine", etc.
  conversations: Conversation[]
}

// ✅ NOUVEAU: Réponse API pour l'historique
export interface ConversationHistoryResponse {
  success: boolean
  conversations: Conversation[]
  groups?: ConversationGroup[]
  total_count: number
  user_id: string
  timestamp: string
}

// ✅ NOUVEAU: Réponse API pour une conversation complète
export interface ConversationDetailResponse {
  success: boolean
  conversation: ConversationWithMessages
  timestamp: string
}

// ✅ NOUVEAU: Options pour le groupement des conversations
export interface ConversationGroupingOptions {
  groupBy: 'date' | 'topic' | 'none'
  sortBy: 'updated_at' | 'created_at' | 'message_count'
  sortOrder: 'desc' | 'asc'
  limit?: number
  offset?: number
}

// ✅ NOUVEAU: Statistiques de conversation
export interface ConversationStats {
  total_conversations: number
  total_messages: number
  avg_messages_per_conversation: number
  most_active_day: string
  favorite_topics: string[]
  satisfaction_rate: number
}

// ==================== TYPES POUR CLARIFICATIONS INLINE ====================

// ✅ Interface simplifiée pour clarifications inline (REMPLACE ClarificationModalProps)
export interface ClarificationInlineProps {
  questions: string[]
  originalQuestion: string
  language: string
  onSubmit: (answers: Record<string, string>) => Promise<void>
  onSkip: () => Promise<void>
  isSubmitting?: boolean
  conversationId?: string
}

// ✅ Interface pour les réponses de clarification
export interface ClarificationResponse {
  needs_clarification: boolean
  questions?: string[]
  confidence_score?: number
  processing_time_ms?: number
  model_used?: string
}

// ✅ Interface pour l'état des clarifications
export interface ClarificationState {
  pendingClarification: ExpertApiResponse | null
  isProcessingClarification: boolean
  clarificationHistory: Array<{
    original_question: string
    clarification_questions: string[]
    answers: Record<string, string>
    final_response: string
    timestamp: string
  }>
}

// ==================== TYPES UTILISATEUR AVEC CHAMPS TÉLÉPHONE ====================

export interface User {
  id: string
  email: string
  name: string
  firstName: string
  lastName: string
  phone: string  // ⚠️ Champ existant - gardé pour compatibilité
  country: string
  linkedinProfile: string
  companyName: string
  companyWebsite: string
  linkedinCorporate: string
  user_type: string
  language: string
  created_at: string
  plan: string
  
  // ✅ NOUVEAUX CHAMPS TÉLÉPHONE SÉPARÉS POUR SUPABASE
  country_code?: string    // Code pays (ex: +1, +33, +32)
  area_code?: string       // Code régional (ex: 514, 04, 2)
  phone_number?: string    // Numéro principal (ex: 1234567, 12345678)
}

export interface ProfileUpdateData {
  firstName: string
  lastName: string
  email: string
  phone?: string  // ✅ CORRIGÉ : Maintenant optionnel pour éviter les conflits
  country: string
  linkedinProfile: string
  companyName: string
  companyWebsite: string
  linkedinCorporate: string
  language?: string
  
  // ✅ NOUVEAUX CHAMPS TÉLÉPHONE SÉPARÉS
  country_code?: string
  area_code?: string
  phone_number?: string
}

// ==================== TYPES SPÉCIFIQUES AU COMPOSANT PHONE ====================

export interface PhoneData {
  country_code: string
  area_code: string
  phone_number: string
}

export interface PhoneValidationResult {
  isValid: boolean
  errors: string[]
  isValidCountry: boolean
  isValidArea: boolean
  isValidNumber: boolean
}

// ==================== NOUVEAUX TYPES FEEDBACK ET COMMENTAIRES ====================

// ✅ NOUVEAU: Interface pour les données feedback enrichies
export interface FeedbackData {
  conversation_id: string
  feedback: 'positive' | 'negative'
  comment?: string
  timestamp: string
  user_id?: string
}

// ✅ NOUVEAU: Props pour la modal feedback
export interface FeedbackModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (feedback: 'positive' | 'negative', comment?: string) => Promise<void>
  feedbackType: 'positive' | 'negative'
  isSubmitting?: boolean
}

// ✅ NOUVEAU: Interface pour les analytics feedback
export interface FeedbackAnalytics {
  period_days: number
  total_conversations: number
  total_feedback: number
  satisfaction_rate: number
  feedback_rate: number
  comment_rate: number
  feedback_breakdown: {
    positive: number
    negative: number
    with_comment: number
  }
  recent_comments: Array<{
    conversation_id: string
    feedback: 'positive' | 'negative'
    comment: string
    timestamp: string
    question_preview: string
  }>
}

// ✅ NOUVEAU: Interface pour le rapport admin feedback
export interface AdminFeedbackReport {
  period_days: number
  generated_at: string
  summary: {
    total_conversations: number
    total_feedback: number
    satisfaction_rate: number
    feedback_rate: number
    comment_rate: number
    avg_response_time_ms?: number
  }
  feedback_breakdown: {
    positive: number
    negative: number
    with_comment: number
  }
  language_stats: Array<{
    language: string
    total: number
    positive: number
    negative: number
    with_comment: number
    satisfaction_rate: number
  }>
  top_negative_feedback: Array<{
    question: string
    comment: string
    timestamp: string
    language: string
  }>
  top_positive_feedback: Array<{
    question: string
    comment: string
    timestamp: string
    language: string
  }>
  most_active_users: Array<{
    user_id: string
    total_conversations: number
    feedback_given: number
    comments_given: number
    engagement_rate: number
  }>
}

// ✅ NOUVEAU: Interface pour les statistiques utilisateur
export interface UserFeedbackStats {
  user_id: string
  total_conversations: number
  feedback_given: number
  comments_given: number
  positive_feedback: number
  negative_feedback: number
  engagement_rate: number
  avg_comment_length?: number
  last_feedback_date?: string
}

// ==================== TYPES HOOKS AVEC CONVERSATIONS ====================

// ✅ INTERFACE AuthStore CORRIGÉE AVEC TOUTES LES PROPRIÉTÉS
export interface AuthStore {
  user: User | null
  isAuthenticated: boolean
  isLoading: boolean
  hasHydrated: boolean  // ✅ AJOUTÉ: Pour éviter l'erreur TypeScript
  logout: () => Promise<void>
  login: (email: string, password: string) => Promise<void>  // ✅ AJOUTÉ
  register: (email: string, password: string, userData?: Partial<User>) => Promise<void>  // ✅ AJOUTÉ
  updateProfile: (data: ProfileUpdateData) => Promise<{ success: boolean; error?: string }>
  initializeSession: () => Promise<boolean>  // ✅ AJOUTÉ
}

// ✅ MISE À JOUR: ChatStore pour gérer les conversations
export interface ChatStore {
  // ✅ PROPRIÉTÉS EXISTANTES CONSERVÉES
  conversations: ConversationItem[]
  isLoading: boolean
  loadConversations: (userId: string) => Promise<void>
  deleteConversation: (id: string) => Promise<void>
  clearAllConversations: (userId?: string) => Promise<void>
  refreshConversations: (userId: string) => Promise<void>
  addConversation: (conversationId: string, question: string, response: string) => void

  // ✅ NOUVELLES PROPRIÉTÉS POUR CONVERSATIONS STYLE CLAUDE.AI
  conversationGroups: ConversationGroup[]
  currentConversation: ConversationWithMessages | null
  isLoadingHistory: boolean
  isLoadingConversation: boolean
  loadConversation: (conversationId: string) => Promise<void>
  createNewConversation: () => void
  addMessage: (message: Message) => void
  updateMessage: (messageId: string, updates: Partial<Message>) => void
  setCurrentConversation: (conversation: ConversationWithMessages | null) => void
}

export interface Translation {
  t: (key: string) => string
  changeLanguage: (lang: string) => void
  currentLanguage: string
}

// ==================== TYPES COMPOSANTS ====================

export interface ModalProps {
  isOpen: boolean
  onClose: () => void
  title: string
  children: React.ReactNode
}

export interface UserInfoModalProps {
  user: User | null
  onClose: () => void
}

export interface IconProps {
  className?: string
}

// ==================== TYPES API ====================

export interface ApiError extends Error {
  status?: number
}

export class AuthError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'AuthError'
  }
}

export class TimeoutError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'TimeoutError'
  }
}

// ==================== CONSTANTES API SÉCURISÉES ====================

// ✅ SÉCURISÉ: Configuration API dynamique depuis environnement
const getApiConfig = () => {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL
  const version = process.env.NEXT_PUBLIC_API_VERSION || 'v1'
  
  if (!baseUrl) {
    console.error('❌ NEXT_PUBLIC_API_BASE_URL environment variable missing')
    return {
      BASE_URL: 'http://localhost:8000', // Fallback développement
      TIMEOUT: 30000,
      LOGGING_BASE_URL: 'http://localhost:8000/api/v1'
    }
  }
  
  return {
    BASE_URL: baseUrl,
    TIMEOUT: 30000,
    LOGGING_BASE_URL: `${baseUrl}/api/${version}`
  }
}

export const API_CONFIG = getApiConfig()

// ✅ NOUVEAUX ENDPOINTS FEEDBACK
export const FEEDBACK_ENDPOINTS = {
  SAVE_CONVERSATION: '/logging/conversation',
  UPDATE_FEEDBACK: '/logging/conversation/{id}/feedback',
  UPDATE_COMMENT: '/logging/conversation/{id}/comment',
  UPDATE_FEEDBACK_WITH_COMMENT: '/logging/conversation/{id}/feedback-with-comment',
  GET_USER_CONVERSATIONS: '/logging/user/{id}/conversations',
  DELETE_CONVERSATION: '/logging/conversation/{id}',
  DELETE_ALL_USER_CONVERSATIONS: '/logging/user/{id}/conversations',
  GET_FEEDBACK_ANALYTICS: '/logging/analytics/feedback',
  GET_CONVERSATIONS_WITH_COMMENTS: '/logging/conversations/with-comments',
  GET_ADMIN_FEEDBACK_REPORT: '/logging/admin/feedback-report',
  EXPORT_FEEDBACK_DATA: '/logging/admin/export-feedback',
  TEST_COMMENT_SUPPORT: '/logging/test-comments'
} as const

export const PLAN_CONFIGS = {
  essential: {
    name: 'Essentiel',
    color: 'text-green-600',
    bgColor: 'bg-green-50',
    borderColor: 'border-green-200',
    features: [
      '50 questions par mois',
      'Accès aux documents publics',
      'Support par email',
      'Interface web'
    ]
  },
  pro: {
    name: 'Pro',
    color: 'text-blue-600',
    bgColor: 'bg-blue-50',
    borderColor: 'border-blue-200',
    features: [
      'Questions illimitées',
      'Accès documents confidentiels',
      'Support prioritaire',
      'Interface web + mobile',
      'Analytics avancées'
    ]
  }
} as const

// ✅ NOUVELLE CONFIGURATION FEEDBACK
export const FEEDBACK_CONFIG = {
  TYPES: {
    POSITIVE: {
      value: 'positive' as const,
      label: 'Utile',
      icon: '👍',
      color: 'text-green-600',
      bgColor: 'bg-green-50',
      description: 'Cette réponse m\'a été utile'
    },
    NEGATIVE: {
      value: 'negative' as const, 
      label: 'Pas utile',
      icon: '👎',
      color: 'text-red-600',
      bgColor: 'bg-red-50',
      description: 'Cette réponse pourrait être améliorée'
    }
  },
  COMMENT_PLACEHOLDERS: {
    positive: 'Qu\'avez-vous apprécié dans cette réponse ?',
    negative: 'Dans quelle mesure cette réponse était-elle satisfaisante ?'
  },
  MODAL_TITLES: {
    positive: 'Merci pour votre feedback positif !',
    negative: 'Aidez-nous à améliorer'
  },
  MAX_COMMENT_LENGTH: 500,
  MIN_COMMENT_LENGTH: 0,
  PRIVACY_POLICY_URL: 'https://intelia.com/privacy-policy/'
} as const

// ✅ CONFIGURATION DES CLARIFICATIONS
export const CLARIFICATION_TEXTS = {
  fr: {
    title: "Informations supplémentaires requises",
    subtitle: "Pour vous donner la meilleure réponse, veuillez répondre à ces questions :",
    placeholder: "Tapez votre réponse ici...",
    submit: "Obtenir ma réponse",
    skip: "Passer et obtenir une réponse générale",
    optional: "(optionnel)",
    required: "Répondez à au moins la moitié des questions",
    processing: "Traitement en cours...",
    validationError: "Veuillez répondre à au moins {count} questions"
  },
  en: {
    title: "Additional information required",
    subtitle: "To give you the best answer, please answer these questions:",
    placeholder: "Type your answer here...",
    submit: "Get my answer",
    skip: "Skip and get a general answer",
    optional: "(optional)",
    required: "Answer at least half of the questions",
    processing: "Processing...",
    validationError: "Please answer at least {count} questions"
  },
  es: {
    title: "Información adicional requerida",
    subtitle: "Para darle la mejor respuesta, por favor responda estas preguntas:",
    placeholder: "Escriba su respuesta aquí...",
    submit: "Obtener mi respuesta",
    skip: "Omitir y obtener una respuesta general",
    optional: "(opcional)",
    required: "Responda al menos la mitad de las preguntas",
    processing: "Procesando...",
    validationError: "Por favor responda al menos {count} preguntas"
  }
} as const

export const CLARIFICATION_CONFIG = {
  MAX_QUESTIONS: 4,
  MIN_ANSWER_LENGTH: 0,
  MAX_ANSWER_LENGTH: 200,
  REQUIRED_ANSWER_PERCENTAGE: 0.5, // 50% des questions doivent être répondues
  AUTO_SCROLL_DELAY: 300,
  VALIDATION_DEBOUNCE: 500
} as const

// ✅ UTILITAIRES ANALYTICS
export const ANALYTICS_UTILS = {
  calculateSatisfactionRate: (positive: number, negative: number): number => {
    const total = positive + negative
    return total > 0 ? Math.round((positive / total) * 1000) / 1000 : 0
  },
  
  calculateEngagementRate: (feedbackGiven: number, totalConversations: number): number => {
    return totalConversations > 0 ? Math.round((feedbackGiven / totalConversations) * 1000) / 1000 : 0
  },
  
  calculateCommentRate: (withComments: number, totalFeedback: number): number => {
    return totalFeedback > 0 ? Math.round((withComments / totalFeedback) * 1000) / 1000 : 0
  },
  
  formatPercentage: (rate: number): string => {
    return `${(rate * 100).toFixed(1)}%`
  },
  
  truncateText: (text: string, maxLength: number): string => {
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text
  },
  
  formatTimestamp: (timestamp: string): string => {
    try {
      const date = new Date(timestamp)
      return date.toLocaleDateString('fr-FR', { 
        day: 'numeric', 
        month: 'short', 
        hour: '2-digit', 
        minute: '2-digit' 
      })
    } catch {
      return timestamp
    }
  }
} as const

// ✅ UTILITAIRES POUR CLARIFICATIONS
export const ClarificationUtils = {
  isClarificationResponse: (response: ExpertApiResponse): boolean => {
    return (
      response.mode?.includes("clarification_needed") ||
      response.response?.includes("❓") ||
      response.response?.includes("précisions") ||
      response.response?.includes("clarification") ||
      response.response?.includes("aclaraciones") ||
      response.is_clarification_request === true
    )
  },

  extractClarificationQuestions: (response: ExpertApiResponse): string[] => {
    if (response.clarification_questions) {
      return response.clarification_questions
    }
    
    const questions: string[] = []
    const lines = response.response.split('\n')
    
    for (const line of lines) {
      const cleaned = line.trim()
      if (cleaned.startsWith('• ') || cleaned.startsWith('- ')) {
        const question = cleaned.replace(/^[•-]\s*/, '').trim()
        if (question.length > 5) {
          questions.push(question)
        }
      }
    }
    
    return questions
  },

  buildEnrichedQuestion: (
    originalQuestion: string, 
    clarificationAnswers: Record<string, string>, 
    clarificationQuestions: string[]
  ): string => {
    let enrichedQuestion = originalQuestion + "\n\nInformations supplémentaires :"
    
    Object.entries(clarificationAnswers).forEach(([index, answer]) => {
      if (answer && answer.trim()) {
        try {
          const questionIndex = parseInt(index)
          if (questionIndex >= 0 && questionIndex < clarificationQuestions.length) {
            const question = clarificationQuestions[questionIndex]
            enrichedQuestion += `\n- ${question}: ${answer.trim()}`
          }
        } catch {
          // Ignorer les index invalides
        }
      }
    })
    
    return enrichedQuestion
  },

  validateClarificationAnswers: (
    answers: Record<string, string>, 
    questions: string[]
  ): { isValid: boolean; requiredCount: number; answeredCount: number } => {
    const answeredCount = Object.values(answers).filter(a => a && a.trim().length > 0).length
    const requiredCount = Math.ceil(questions.length * 0.5) // Au moins 50% des questions
    
    return {
      isValid: answeredCount >= requiredCount,
      requiredCount,
      answeredCount
    }
  }
} as const

// ✅ CONSTANTES DE VALIDATION
export const VALIDATION_RULES = {
  FEEDBACK: {
    COMMENT_MIN_LENGTH: 0,
    COMMENT_MAX_LENGTH: 500,
    REQUIRED_FIELDS: [] as string[], // Aucun champ requis pour le feedback
    ALLOWED_FEEDBACK_TYPES: ['positive', 'negative'] as const
  },
  PHONE: {
    COUNTRY_CODE_PATTERN: /^\+\d{1,4}$/,
    AREA_CODE_PATTERN: /^\d{1,4}$/,
    PHONE_NUMBER_PATTERN: /^\d{4,12}$/
  },
  // ✅ NOUVELLES RÈGLES POUR CONVERSATIONS
  CONVERSATION: {
    TITLE_MAX_LENGTH: 60,
    PREVIEW_MAX_LENGTH: 150,
    MESSAGE_MAX_LENGTH: 5000,
    MAX_CONVERSATIONS_PER_USER: 1000,
    AUTO_DELETE_DAYS: 30
  },
  // ✅ NOUVELLES RÈGLES POUR CLARIFICATIONS
  CLARIFICATION: {
    MIN_ANSWER_LENGTH: 0,
    MAX_ANSWER_LENGTH: 200,
    MAX_QUESTIONS: 4,
    REQUIRED_ANSWER_PERCENTAGE: 0.5
  }
} as const

// ✅ MESSAGES D'ERREUR LOCALISÉS
export const ERROR_MESSAGES = {
  FEEDBACK: {
    SUBMISSION_FAILED: 'Erreur lors de l\'envoi du feedback. Veuillez réessayer.',
    INVALID_CONVERSATION_ID: 'Impossible d\'enregistrer le feedback - ID de conversation manquant',
    COMMENT_TOO_LONG: `Le commentaire ne peut pas dépasser ${VALIDATION_RULES.FEEDBACK.COMMENT_MAX_LENGTH} caractères`,
    NETWORK_ERROR: 'Problème de connexion réseau. Vérifiez votre connexion internet.',
    SERVER_ERROR: 'Erreur serveur. Veuillez réessayer plus tard.',
    TIMEOUT_ERROR: 'Timeout - le serveur met trop de temps à répondre'
  },
  // ✅ NOUVEAUX MESSAGES POUR CONVERSATIONS
  CONVERSATION: {
    LOAD_FAILED: 'Erreur lors du chargement de la conversation',
    DELETE_FAILED: 'Erreur lors de la suppression de la conversation',
    NOT_FOUND: 'Conversation non trouvée',
    EMPTY_MESSAGE: 'Le message ne peut pas être vide',
    MESSAGE_TOO_LONG: `Le message ne peut pas dépasser ${VALIDATION_RULES.CONVERSATION.MESSAGE_MAX_LENGTH} caractères`,
    CREATION_FAILED: 'Erreur lors de la création de la conversation'
  },
  // ✅ NOUVEAUX MESSAGES POUR CLARIFICATIONS
  CLARIFICATION: {
    PROCESSING_FAILED: 'Erreur lors du traitement des clarifications',
    INVALID_ANSWERS: 'Réponses invalides. Veuillez vérifier vos réponses.',
    SUBMISSION_FAILED: 'Erreur lors de l\'envoi des clarifications',
    TIMEOUT: 'Timeout lors du traitement des clarifications'
  },
  GENERAL: {
    UNAUTHORIZED: 'Session expirée - reconnexion nécessaire',
    FORBIDDEN: 'Accès non autorisé',
    NOT_FOUND: 'Ressource non trouvée',
    GENERIC: 'Une erreur inattendue s\'est produite'
  }
} as const

// ✅ TYPES POUR LES RÉPONSES D'API FEEDBACK
export interface FeedbackApiResponse {
  status: 'success' | 'error'
  message: string
  conversation_id: string
  feedback?: number
  comment?: string
  timestamp: string
}

export interface ConversationApiResponse {
  status: 'success' | 'error'
  message: string
  conversation_id: string
  timestamp: string
}

export interface AnalyticsApiResponse {
  status: 'success' | 'error'
  timestamp: string
  analytics: FeedbackAnalytics
  message: string
}

// ✅ TYPE GUARDS POUR LA VALIDATION
export const TypeGuards = {
  isFeedbackType: (value: any): value is 'positive' | 'negative' => {
    return typeof value === 'string' && ['positive', 'negative'].includes(value)
  },
  
  isValidMessage: (value: any): value is Message => {
    return (
      typeof value === 'object' &&
      value !== null &&
      typeof value.id === 'string' &&
      typeof value.content === 'string' &&
      typeof value.isUser === 'boolean' &&
      value.timestamp instanceof Date
    )
  },
  
  isValidUser: (value: any): value is User => {
    return (
      typeof value === 'object' &&
      value !== null &&
      typeof value.id === 'string' &&
      typeof value.email === 'string'
    )
  },

  // ✅ TYPE GUARD POUR CONVERSATION DE BASE
  isValidConversation: (value: any): value is Conversation => {
    return (
      typeof value === 'object' &&
      value !== null &&
      typeof value.id === 'string' &&
      typeof value.title === 'string' &&
      typeof value.preview === 'string' &&
      typeof value.message_count === 'number'
    )
  },

  // ✅ Type guard pour ConversationWithMessages
  isValidConversationWithMessages: (value: any): value is ConversationWithMessages => {
    return (
      typeof value === 'object' &&
      value !== null &&
      typeof value.id === 'string' &&
      typeof value.title === 'string' &&
      typeof value.preview === 'string' &&
      typeof value.message_count === 'number' &&
      Array.isArray(value.messages) &&
      value.messages.every((msg: any) => TypeGuards.isValidMessage(msg))
    )
  },

  isValidConversationGroup: (value: any): value is ConversationGroup => {
    return (
      typeof value === 'object' &&
      value !== null &&
      typeof value.title === 'string' &&
      Array.isArray(value.conversations) &&
      value.conversations.every((conv: any) => TypeGuards.isValidConversation(conv))
    )
  },

  // ✅ NOUVEAU: Type guard pour clarifications
  isValidClarificationResponse: (value: any): value is ClarificationResponse => {
    return (
      typeof value === 'object' &&
      value !== null &&
      typeof value.needs_clarification === 'boolean'
    )
  }
} as const

// ✅ CONFIGURATION DES CONVERSATIONS
export const CONVERSATION_CONFIG = {
  GROUPING: {
    DEFAULT_OPTIONS: {
      groupBy: 'date' as const,
      sortBy: 'updated_at' as const,
      sortOrder: 'desc' as const,
      limit: 50
    },
    TIME_PERIODS: {
      TODAY: 'Aujourd\'hui',
      YESTERDAY: 'Hier',
      THIS_WEEK: 'Cette semaine',
      THIS_MONTH: 'Ce mois-ci',
      OLDER: 'Plus ancien'
    }
  },
  UI: {
    SIDEBAR_WIDTH: 'w-96', // 384px
    MAX_TITLE_LENGTH: 60,
    MAX_PREVIEW_LENGTH: 150,
    MESSAGES_PER_PAGE: 50,
    AUTO_SCROLL_DELAY: 100
  },
  CACHE: {
    CONVERSATION_LIST_TTL: 5 * 60 * 1000, // 5 minutes
    CONVERSATION_DETAIL_TTL: 10 * 60 * 1000, // 10 minutes
    MAX_CACHED_CONVERSATIONS: 100
  }
} as const

// ✅ UTILITAIRES POUR CONVERSATIONS
export const CONVERSATION_UTILS = {
  generateTitle: (firstMessage: string): string => {
    const maxLength = CONVERSATION_CONFIG.UI.MAX_TITLE_LENGTH
    return firstMessage.length > maxLength 
      ? firstMessage.substring(0, maxLength) + '...' 
      : firstMessage
  },

  generatePreview: (firstMessage: string): string => {
    const maxLength = CONVERSATION_CONFIG.UI.MAX_PREVIEW_LENGTH
    return firstMessage.length > maxLength 
      ? firstMessage.substring(0, maxLength) + '...' 
      : firstMessage
  },

  formatRelativeTime: (timestamp: string): string => {
    const now = new Date()
    const date = new Date(timestamp)
    const diffMs = now.getTime() - date.getTime()
    const diffMinutes = Math.floor(diffMs / (1000 * 60))
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

    if (diffMinutes < 1) return 'À l\'instant'
    if (diffMinutes < 60) return `Il y a ${diffMinutes}m`
    if (diffHours < 24) return `Il y a ${diffHours}h`
    if (diffDays < 7) return `Il y a ${diffDays}j`
    
    return ANALYTICS_UTILS.formatTimestamp(timestamp)
  },

  sortConversations: (conversations: Conversation[], sortBy: 'updated_at' | 'created_at' | 'message_count' = 'updated_at'): Conversation[] => {
    return [...conversations].sort((a, b) => {
      switch (sortBy) {
        case 'message_count':
          return b.message_count - a.message_count
        case 'created_at':
          return new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
        case 'updated_at':
        default:
          return new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()
      }
    })
  }
} as const

// ✅ TYPES POUR LANGUAGES (souvent utilisé)
export type Language = 'fr' | 'en' | 'es' | 'de'