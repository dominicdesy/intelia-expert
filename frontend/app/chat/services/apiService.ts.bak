// ==================== API SERVICE UNIFIÃ‰ - CORRIGÃ‰ AUTH-TEMP + PRÃ‰SERVATION COMPLÃˆTE ====================

// ğŸ”§ AJOUT : Import du conversationService pour stocker les session IDs
import { conversationService } from './conversationService'

// âœ… CONFIGURATION CORRIGÃ‰E POUR AUTH-TEMP
const getApiConfig = () => {
  // ğŸ”§ CORRECTION: URL de base corrigÃ©e pour auth-temp
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'https://expert-app-cngws.ondigitalocean.app'
  const version = process.env.NEXT_PUBLIC_API_VERSION || 'v1'
  
  if (!baseUrl) {
    console.error('âŒ NEXT_PUBLIC_API_BASE_URL environment variable is required')
    throw new Error('API configuration missing - check environment variables')
  }
  
  return `${baseUrl}/api/${version}`
}

const API_BASE_URL = getApiConfig()

// âœ… FONCTIONS AUTH CORRIGÃ‰ES POUR AUTH-TEMP
const getAuthToken = (): string | null => {
  try {
    // ğŸ”§ PRIORITÃ‰ 1: Chercher dans le localStorage standard (auth-temp)
    const authToken = localStorage.getItem('auth_token')
    if (authToken && authToken !== 'null' && authToken !== 'undefined') {
      console.log('[getAuthToken] Token trouvÃ© dans localStorage (auth-temp)')
      return authToken
    }

    // PRIORITÃ‰ 2: Chercher dans les cookies
    const cookieToken = getCookieToken()
    if (cookieToken) {
      console.log('[getAuthToken] Token trouvÃ© dans cookies')
      return cookieToken
    }

    // PRIORITÃ‰ 3: Fallback Supabase localStorage
    const sbToken = localStorage.getItem('sb-cdrmjshmkdfwwtsfdvbl-auth-token')
    if (sbToken) {
      try {
        const parsed = JSON.parse(sbToken)
        if (Array.isArray(parsed) && parsed[0] && parsed[0] !== 'mock-jwt-token-for-development') {
          console.log('[getAuthToken] Token trouvÃ© dans localStorage Supabase (fallback)')
          return parsed[0]
        }
      } catch (e) {
        console.warn('[getAuthToken] Failed to parse sb localStorage token:', e)
      }
    }

    console.warn('[getAuthToken] Aucun token trouvÃ© dans toutes les sources')
    return null
  } catch (error) {
    console.error('[getAuthToken] Error getting auth token:', error)
    return null
  }
}

const getCookieToken = (): string | null => {
  try {
    const cookies = document.cookie.split(';')
    const sbCookie = cookies.find(cookie => 
      cookie.trim().startsWith('sb-cdrmjshmkdfwwtsfdvbl-auth-token=')
    )
    
    if (sbCookie) {
      const cookieValue = sbCookie.split('=')[1]
      const decodedValue = decodeURIComponent(cookieValue)
      const parsed = JSON.parse(decodedValue)
      
      if (Array.isArray(parsed) && parsed[0] && parsed[0] !== 'mock-jwt-token-for-development') {
        console.log('[getCookieToken] Token valide trouvÃ© dans cookie')
        return parsed[0]
      }
    }
    
    return null
  } catch (error) {
    console.error('[getCookieToken] Error parsing cookie token:', error)
    return null
  }
}

const getAuthHeaders = (): Record<string, string> => {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    'Origin': 'https://expert.intelia.com', // ğŸ”§ AJOUT: Header CORS obligatoire
  }

  const authToken = getAuthToken()
  if (authToken) {
    headers['Authorization'] = `Bearer ${authToken}`
    console.log('ğŸ”‘ [apiService] Token ajoutÃ© aux headers (auth-temp compatible)')
  } else {
    console.warn('âš ï¸ [apiService] Aucun token trouvÃ© - requÃªte sans auth')
  }

  return headers
}

// âœ… GÃ‰NÃ‰RATION UUID INCHANGÃ‰E
const generateUUID = (): string => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID()
  }
  
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0
    const v = c === 'x' ? r : (r & 0x3 | 0x8)
    return v.toString(16)
  })
}

// ğŸ†• NOUVEAU : FONCTIONS FORMATAGE HEURE LOCALE (PRÃ‰SERVÃ‰ES)
export const formatToLocalTime = (utcTimestamp: string): string => {
  try {
    const date = new Date(utcTimestamp);
    
    // Options pour l'affichage en franÃ§ais canadien
    const options: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: '2-digit', 
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone, // Heure locale auto
      hour12: false // Format 24h
    };
    
    return date.toLocaleString('fr-CA', options);
  } catch (error) {
    console.warn('Erreur formatage date:', error);
    return utcTimestamp; // Fallback
  }
}

// Version plus simple si prÃ©fÃ©rÃ©e
export const simpleLocalTime = (utcTimestamp: string): string => {
  try {
    return new Date(utcTimestamp).toLocaleString('fr-CA', {
      year: 'numeric',
      month: '2-digit', 
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  } catch (error) {
    console.warn('Erreur formatage date simple:', error);
    return utcTimestamp;
  }
}

// ğŸ”§ INTERFACE ADAPTÃ‰E : Compatible nouveau backend + garder compatibilitÃ© (PRÃ‰SERVÃ‰E INTÃ‰GRALEMENT)
interface EnhancedAIResponse {
  response?: string
  conversation_id: string
  language: string
  ai_enhancements_used?: string[]
  rag_used?: boolean
  sources?: any[]
  confidence_score?: number
  response_time?: number
  mode?: string
  note?: string
  timestamp?: string
  processing_time?: number
  
  // ğŸš€ NOUVEAU : Toutes les versions de rÃ©ponse (gÃ©nÃ©rÃ© cÃ´tÃ© frontend si absent)
  response_versions?: {
    ultra_concise?: string
    concise?: string
    standard?: string
    detailed?: string
  }
  
  // âœ… CLARIFICATIONS INCHANGÃ‰ES
  clarification_result?: {
    clarification_requested: boolean
    clarification_type: string
    missing_information: string[]
    age_detected?: string
    confidence: number
  }
  requires_clarification?: boolean
  clarification_questions?: string[]
  clarification_type?: string
  vague_entities?: string[]
  
  // ğŸš€ NOUVEAU : Support format DialogueManager
  type?: 'answer' | 'clarification' | 'partial_answer' | 'validation_rejected'
  questions?: string[]
  source?: string
  documents_used?: number
  warning?: string
  
  // ğŸ”§ AJOUT CRITIQUE : Support format partial_answer
  general_answer?: {
    text: string
    source?: string
  }
  follow_up_questions?: Array<{
    field: string
    question: string
    options?: string[]
  }>
  
  // ğŸŒ¾ NOUVEAU : Support validation_rejected
  message?: string
  validation?: {
    is_valid: boolean
    confidence: number
    suggested_topics?: string[]
    detected_keywords?: string[]
    rejected_keywords?: string[]
  }
  
  // ğŸš€ AJOUT : Champ pour compatibilitÃ©
  full_text?: string
}

// âœ… INTERFACE ERROR INCHANGÃ‰E
interface APIError {
  detail: string
  timestamp: string
  path: string
  version: string
}

/**
 * ğŸ”§ FONCTION PRINCIPALE AVEC STOCKAGE SESSION ID (PRÃ‰SERVÃ‰E + CORRIGÃ‰E AUTH-TEMP)
 */
export const generateAIResponse = async (
  question: string,
  user: any,
  language: string = 'fr',
  conversationId?: string,
  concisionLevel: 'ultra_concise' | 'concise' | 'standard' | 'detailed' = 'concise',
  isClarificationResponse = false,
  originalQuestion?: string,
  clarificationEntities?: Record<string, any>
): Promise<EnhancedAIResponse> => {
  if (!question || question.trim() === '') {
    throw new Error('Question requise')
  }

  if (!user || !user.id) {
    throw new Error('Utilisateur requis')
  }

  // ğŸ”§ ADAPTÃ‰ : Session ID pour DialogueManager
  const finalConversationId = conversationId || generateUUID()

  console.log('ğŸ¯ [apiService] Nouveau systÃ¨me DialogueManager (auth-temp compatible):', {
    question: question.substring(0, 50) + '...',
    session_id: finalConversationId.substring(0, 8) + '...',
    system: 'expert.py + DialogueManager + auth-temp'
  })

  try {
    // ğŸ”§ ADAPTÃ‰ : Endpoint simplifiÃ© du nouveau systÃ¨me
    const endpoint = `${API_BASE_URL}/expert/ask`
    
    // âœ… ENRICHISSEMENT CLARIFICATION CONSERVÃ‰ (au cas oÃ¹)
    let finalQuestion = question.trim()
    
    if (isClarificationResponse && originalQuestion) {
      console.log('ğŸª [apiService] Mode clarification - enrichissement question')
      
      const breedMatch = finalQuestion.match(/(ross\s*308|cobb\s*500|hubbard)/i)
      const sexMatch = finalQuestion.match(/(mÃ¢le|male|femelle|female|mixte|mixed)/i)
      
      const breed = breedMatch ? breedMatch[0] : ''
      const sex = sexMatch ? sexMatch[0] : ''
      
      if (breed && sex) {
        finalQuestion = `${originalQuestion} pour ${breed} ${sex}`
        console.log('âœ… [apiService] Question enrichie:', finalQuestion)
      }
    }

    // ğŸ”§ CORRECTION CRITIQUE : session_id dans le body, pas dans les headers !
    const requestBody = {
      session_id: finalConversationId,  // âœ… CORRIGÃ‰ !
      question: finalQuestion
    }

    // ğŸ”§ CORRECTION : Headers avec CORS et auth-temp
    const headers = getAuthHeaders()  // âœ… CORRIGÃ‰ !

    console.log('ğŸ“¤ [apiService] Body DialogueManager (auth-temp):', requestBody)
    console.log('ğŸ“¤ [apiService] Session ID:', finalConversationId.substring(0, 8) + '...')

    const response = await fetch(endpoint, {
      method: 'POST',
      headers,
      body: JSON.stringify(requestBody)
    })

    console.log('ğŸ“¡ [apiService] Statut DialogueManager (auth-temp):', response.status)

    if (!response.ok) {
      const errorText = await response.text()
      console.error('âŒ [apiService] Erreur DialogueManager (auth-temp):', errorText)
      
      if (response.status === 401) {
        throw new Error('Session expirÃ©e. Veuillez vous reconnecter.')
      }
      
      if (response.status === 403) {
        throw new Error('AccÃ¨s non autorisÃ©.')
      }
      
      let errorMessage = `Erreur API: ${response.status}`
      try {
        const errorData: APIError = JSON.parse(errorText)
        errorMessage = errorData.detail || errorMessage
      } catch (e) {
        errorMessage = errorText || errorMessage
      }
      
      throw new Error(errorMessage)
    }

    const data = await response.json()
    
    console.log('âœ… [apiService] RÃ©ponse DialogueManager reÃ§ue (auth-temp):', {
      type: data.type,
      has_answer: !!data.answer,
      answer_text_exists: !!(data.answer?.text),
      has_general_answer: !!data.general_answer,
      has_questions: !!data.questions,
      has_message: !!data.message,
      source: data.source,
      documents_used: data.documents_used
    })

    // ğŸš¨ CORRECTION CRITIQUE : Extraction du texte selon le type + validation_rejected (PRÃ‰SERVÃ‰E)
    let responseText = ''
    if (data.type === 'answer' && data.answer?.text) {
      responseText = data.answer.text
      console.log('ğŸ¯ [apiService] Texte extrait de data.answer.text:', responseText.substring(0, 100))
    } else if (data.type === 'partial_answer' && data.general_answer?.text) {
      responseText = data.general_answer.text
      console.log('ğŸ¯ [apiService] Texte extrait de data.general_answer.text:', responseText.substring(0, 100))
    } else if (data.type === 'validation_rejected') {
      // ğŸŒ¾ NOUVEAU : Gestion validation_rejected
      responseText = data.message || "Cette question ne concerne pas le domaine agricole."
      console.log('ğŸš« [apiService] Question rejetÃ©e par validation agricole:', responseText.substring(0, 100))
    } else {
      console.warn('âš ï¸ [apiService] Aucun texte trouvÃ© dans la rÃ©ponse!')
    }

    // ğŸ”§ CORRECTION FINALE : Construction processedData simplifiÃ©e + validation_rejected (PRÃ‰SERVÃ‰E)
    const processedData: EnhancedAIResponse = {
      conversation_id: finalConversationId,
      language: language,
      timestamp: new Date().toISOString(),
      
      // ğŸš¨ CORRECTION TYPE ANSWER
      ...(data.type === 'answer' ? {
        type: 'answer',
        response: responseText,
        full_text: responseText,
        requires_clarification: false,
        rag_used: true,
        sources: data.answer?.sources || (data.source ? [{ source: data.source }] : []),
        mode: 'perfstore_hit',
        note: data.warning || `Documents utilisÃ©s: ${data.documents_used || 0}`,
        confidence_score: data.answer?.confidence || 0.9
      } : {}),
      
      // ğŸ”§ PRÃ‰SERVATION FORMAT PARTIAL_ANSWER
      ...(data.type === 'partial_answer' ? {
        type: 'partial_answer',
        general_answer: data.general_answer,
        follow_up_questions: data.follow_up_questions,
        response: responseText,
        full_text: responseText,
        rag_used: true,
        sources: data.source ? [{ source: data.source }] : [],
        mode: 'rag_partial_answer',
        note: data.warning || `Documents utilisÃ©s: ${data.documents_used || 0}`,
        confidence_score: data.documents_used ? Math.min(0.9, 0.5 + (data.documents_used * 0.1)) : 0.5
      } : {}),
      
      // ğŸ”§ GESTION CLARIFICATION : Format DialogueManager
      ...(data.type === 'clarification' ? {
        type: 'clarification',
        requires_clarification: true,
        clarification_questions: data.questions || [],
        clarification_type: 'missing_info',
        vague_entities: ['breed', 'sex'],
        clarification_result: {
          clarification_requested: true,
          clarification_type: 'missing_info',
          missing_information: ['breed', 'sex'],
          confidence: 0.5
        },
        rag_used: false,
        sources: [],
        mode: 'clarification_dialoguemanager',
        note: 'Clarification requise'
      } : {}),

      // ğŸŒ¾ GESTION VALIDATION_REJECTED : Nouveau type
      ...(data.type === 'validation_rejected' ? {
        type: 'validation_rejected',
        message: data.message,
        validation: data.validation,
        response: responseText,
        full_text: responseText,
        requires_clarification: false,
        rag_used: false,
        sources: [],
        mode: 'validation_rejected',
        note: 'Question rejetÃ©e par validation agricole',
        confidence_score: 0.0
      } : {})
    }

    // ğŸš€ GÃ‰NÃ‰RATION AUTOMATIQUE response_versions SEULEMENT si response existe (PRÃ‰SERVÃ‰E)
    if (processedData.response && !processedData.response_versions) {
      console.log('âœ… [apiService] GÃ©nÃ©ration automatique response_versions')
      
      const mainResponse = processedData.response
      
      processedData.response_versions = {
        ultra_concise: mainResponse.length > 200 ? 
          mainResponse.substring(0, 150) + '...' : mainResponse,
        concise: mainResponse.length > 400 ? 
          mainResponse.substring(0, 300) + '...' : mainResponse,
        standard: mainResponse,
        detailed: mainResponse + (processedData.sources?.length ? 
          `\n\nSources consultÃ©es: ${processedData.sources.length} documents` : '')
      }
    }

    // ğŸ”§ NOUVEAU : Stocker le session ID pour l'historique (PRÃ‰SERVÃ‰)
    try {
      conversationService.storeRecentSessionId(finalConversationId)
      console.log('âœ… [apiService] Session ID stockÃ© pour historique')
    } catch (error) {
      console.warn('âš ï¸ [apiService] Erreur stockage session ID:', error)
    }

    // ğŸš€ NOUVEAU: Sauvegarder explicitement la conversation - DÃ‰SACTIVÃ‰ car endpoint manquant (PRÃ‰SERVÃ‰)
    try {
      await saveConversationExplicitly(processedData, user.id, finalQuestion)
      console.log('âœ… [apiService] Conversation sauvegardÃ©e explicitement')
    } catch (saveError) {
      console.warn('âš ï¸ [apiService] Erreur sauvegarde conversation:', saveError)
      // Ne pas faire Ã©chouer la rÃ©ponse pour une erreur de sauvegarde
    }

    console.log('ğŸ¯ [apiService] DonnÃ©es traitÃ©es DialogueManager (auth-temp):', {
      type: processedData.type,
      requires_clarification: processedData.requires_clarification,
      clarification_questions_count: processedData.clarification_questions?.length || 0,
      has_response: !!processedData.response,
      response_length: processedData.response?.length || 0,
      has_general_answer: !!processedData.general_answer,
      has_versions: !!processedData.response_versions,
      validation_rejected: processedData.type === 'validation_rejected'
    })

    return processedData

  } catch (error) {
    console.error('âŒ [apiService] Erreur DialogueManager (auth-temp):', error)
    
    if (error instanceof Error) {
      throw error
    }
    
    throw new Error('Erreur de communication avec le serveur')
  }
}

/**
 * ğŸ”§ VERSION PUBLIQUE AVEC STOCKAGE SESSION ID (PRÃ‰SERVÃ‰E + CORRIGÃ‰E AUTH-TEMP)
 */
export const generateAIResponsePublic = async (
  question: string,
  language: string = 'fr',
  conversationId?: string,
  concisionLevel: 'ultra_concise' | 'concise' | 'standard' | 'detailed' = 'concise'
): Promise<EnhancedAIResponse> => {
  if (!question || question.trim() === '') {
    throw new Error('Question requise')
  }

  const finalConversationId = conversationId || generateUUID()

  console.log('ğŸŒ [apiService] DialogueManager public (auth-temp):', {
    question: question.substring(0, 50) + '...',
    session_id: finalConversationId.substring(0, 8) + '...'
  })

  try {
    const endpoint = `${API_BASE_URL}/expert/ask-public`
    
    const requestBody = {
      session_id: finalConversationId,
      question: question.trim()
    }

    const headers = {
      'Content-Type': 'application/json',
      'Origin': 'https://expert.intelia.com' // ğŸ”§ AJOUT: Header CORS
    }

    const response = await fetch(endpoint, {
      method: 'POST',
      headers,
      body: JSON.stringify(requestBody)
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('âŒ [apiService] Erreur DialogueManager public (auth-temp):', errorText)
      throw new Error(`Erreur API: ${response.status}`)
    }

    const data = await response.json()
    
    console.log('âœ… [apiService] RÃ©ponse DialogueManager public (auth-temp):', {
      type: data.type,
      has_answer: !!data.answer,
      answer_text_exists: !!(data.answer?.text),
      has_general_answer: !!data.general_answer,
      has_questions: !!data.questions,
      has_message: !!data.message
    })

    // ğŸš¨ MÃŠME EXTRACTION que la version auth + validation_rejected (PRÃ‰SERVÃ‰E)
    let responseText = ''
    if (data.type === 'answer' && data.answer?.text) {
      responseText = data.answer.text
    } else if (data.type === 'partial_answer' && data.general_answer?.text) {
      responseText = data.general_answer.text
    } else if (data.type === 'validation_rejected') {
      // ğŸŒ¾ NOUVEAU : Gestion validation_rejected
      responseText = data.message || "Cette question ne concerne pas le domaine agricole."
      console.log('ğŸš« [apiService] Question rejetÃ©e par validation agricole (public):', responseText.substring(0, 100))
    }

    const processedData: EnhancedAIResponse = {
      conversation_id: finalConversationId,
      language: language,
      timestamp: new Date().toISOString(),
      
      // ğŸš¨ CORRECTION TYPE ANSWER (PRÃ‰SERVÃ‰E)
      ...(data.type === 'answer' ? {
        type: 'answer',
        response: responseText,
        full_text: responseText,
        requires_clarification: false,
        rag_used: true,
        sources: data.answer?.sources || (data.source ? [{ source: data.source }] : []),
        mode: 'perfstore_hit_public',
        note: data.warning || `Documents utilisÃ©s: ${data.documents_used || 0}`,
        confidence_score: data.answer?.confidence || 0.9
      } : {}),
      
      // ğŸ”§ PRÃ‰SERVATION FORMAT PARTIAL_ANSWER (PRÃ‰SERVÃ‰E)
      ...(data.type === 'partial_answer' ? {
        type: 'partial_answer',
        general_answer: data.general_answer,
        follow_up_questions: data.follow_up_questions,
        response: responseText,
        full_text: responseText,
        rag_used: true,
        sources: data.source ? [{ source: data.source }] : [],
        mode: 'rag_partial_answer_public',
        note: data.warning || `Documents utilisÃ©s: ${data.documents_used || 0}`,
        confidence_score: data.documents_used ? Math.min(0.9, 0.5 + (data.documents_used * 0.1)) : 0.5
      } : {}),
      
      // ğŸ”§ GESTION CLARIFICATION (PRÃ‰SERVÃ‰E)
      ...(data.type === 'clarification' ? {
        type: 'clarification',
        requires_clarification: true,
        clarification_questions: data.questions || [],
        clarification_type: 'missing_info',
        vague_entities: ['breed', 'sex'],
        clarification_result: {
          clarification_requested: true,
          clarification_type: 'missing_info',
          missing_information: ['breed', 'sex'],
          confidence: 0.5
        },
        rag_used: false,
        sources: [],
        mode: 'clarification_dialoguemanager_public',
        note: 'Clarification requise'
      } : {}),

      // ğŸŒ¾ GESTION VALIDATION_REJECTED : Nouveau type (public) (PRÃ‰SERVÃ‰E)
      ...(data.type === 'validation_rejected' ? {
        type: 'validation_rejected',
        message: data.message,
        validation: data.validation,
        response: responseText,
        full_text: responseText,
        requires_clarification: false,
        rag_used: false,
        sources: [],
        mode: 'validation_rejected_public',
        note: 'Question rejetÃ©e par validation agricole',
        confidence_score: 0.0
      } : {})
    }

    // ğŸš€ GÃ‰NÃ‰RATION response_versions SEULEMENT si response existe (PRÃ‰SERVÃ‰E)
    if (processedData.response && !processedData.response_versions) {
      const mainResponse = processedData.response
      
      processedData.response_versions = {
        ultra_concise: mainResponse.length > 200 ? 
          mainResponse.substring(0, 150) + '...' : mainResponse,
        concise: mainResponse.length > 400 ? 
          mainResponse.substring(0, 300) + '...' : mainResponse,
        standard: mainResponse,
        detailed: mainResponse
      }
    }

    // ğŸ”§ NOUVEAU : Stocker le session ID pour l'historique (version publique aussi) (PRÃ‰SERVÃ‰)
    try {
      conversationService.storeRecentSessionId(finalConversationId)
      console.log('âœ… [apiService] Session ID stockÃ© pour historique (public)')
    } catch (error) {
      console.warn('âš ï¸ [apiService] Erreur stockage session ID (public):', error)
    }

    // ğŸš€ NOUVEAU: Sauvegarder explicitement la conversation (version publique) - DÃ‰SACTIVÃ‰ car endpoint manquant (PRÃ‰SERVÃ‰)
    try {
      await saveConversationPublic(processedData, question.trim())
      console.log('âœ… [apiService] Conversation publique sauvegardÃ©e explicitement')
    } catch (saveError) {
      console.warn('âš ï¸ [apiService] Erreur sauvegarde conversation publique:', saveError)
      // Ne pas faire Ã©chouer la rÃ©ponse pour une erreur de sauvegarde
    }

    return processedData

  } catch (error) {
    console.error('âŒ [apiService] Erreur DialogueManager public (auth-temp):', error)
    throw error
  }
}

/**
 * ğŸš€ FONCTIONS DE SAUVEGARDE EXPLICITE - CORRIGÃ‰ES POUR Ã‰VITER ERREUR 405 (PRÃ‰SERVÃ‰ES)
 */
const saveConversationExplicitly = async (
  processedData: EnhancedAIResponse,
  userId: string,
  question: string
): Promise<void> => {
  // âœ… CORRECTION : DÃ©sactiver car l'endpoint POST /v1/conversation n'existe pas
  console.log('â„¹ï¸ [saveConversationExplicitly] Sauvegarde automatique via /expert/ask - endpoint POST manquant, skipping explicit save')
  console.log('ğŸ“Š [saveConversationExplicitly] Conversation dÃ©jÃ  crÃ©Ã©e avec ID:', processedData.conversation_id)
  
  // Les conversations sont automatiquement crÃ©Ã©es par /v1/expert/ask
  // Pas besoin de sauvegarde explicite supplÃ©mentaire
  return
}

const saveConversationPublic = async (
  processedData: EnhancedAIResponse,
  question: string
): Promise<void> => {
  // âœ… CORRECTION : DÃ©sactiver car l'endpoint POST /v1/conversation n'existe pas
  console.log('â„¹ï¸ [saveConversationPublic] Sauvegarde automatique via /expert/ask - endpoint POST manquant, skipping explicit save')
  console.log('ğŸ“Š [saveConversationPublic] Conversation publique dÃ©jÃ  crÃ©Ã©e avec ID:', processedData.conversation_id)
  
  // Les conversations sont automatiquement crÃ©Ã©es par /v1/expert/ask
  // Pas besoin de sauvegarde explicite supplÃ©mentaire
  return
}

/**
 * ğŸ†• NOUVEAU : FONCTION DELETE CONVERSATION CORRIGÃ‰E (PRÃ‰SERVÃ‰E + CORRIGÃ‰E AUTH-TEMP)
 */
export const deleteConversation = async (conversationId: string): Promise<void> => {
  if (!conversationId) {
    throw new Error('ID de conversation requis')
  }

  console.log('ğŸ—‘ï¸ [apiService] Suppression conversation (auth-temp):', conversationId)

  try {
    const headers = getAuthHeaders() // ğŸ”§ CORRECTION: Utilise auth-temp headers

    // âœ… CORRECTION : URL corrigÃ©e avec conversations (au pluriel)
    const response = await fetch(`${API_BASE_URL}/conversations/${conversationId}`, {
      method: 'DELETE',
      headers
    })

    console.log('ğŸ“¡ [apiService] Delete statut (auth-temp):', response.status)

    if (!response.ok) {
      const errorText = await response.text()
      console.error('âŒ [apiService] Erreur delete conversation (auth-temp):', errorText)
      
      if (response.status === 401) {
        throw new Error('Session expirÃ©e. Veuillez vous reconnecter.')
      }
      
      if (response.status === 404) {
        console.warn('âš ï¸ [apiService] Conversation dÃ©jÃ  supprimÃ©e ou inexistante')
        return // Ne pas lever d'erreur pour un 404
      }
      
      throw new Error(`Erreur suppression conversation: ${response.status}`)
    }

    const result = await response.json()
    console.log('âœ… [apiService] Conversation supprimÃ©e (auth-temp):', result.message || 'SuccÃ¨s')

  } catch (error) {
    console.error('âŒ [apiService] Erreur suppression conversation (auth-temp):', error)
    throw error
  }
}

/**
 * ğŸ†• NOUVEAU : FONCTION CLEAR ALL CONVERSATIONS CORRIGÃ‰E (PRÃ‰SERVÃ‰E + CORRIGÃ‰E AUTH-TEMP)
 */
export const clearAllUserConversations = async (userId: string): Promise<void> => {
  if (!userId) {
    throw new Error('User ID requis')
  }

  console.log('ğŸ—‘ï¸ [apiService] Suppression toutes conversations pour (auth-temp):', userId)

  try {
    const headers = getAuthHeaders() // ğŸ”§ CORRECTION: Utilise auth-temp headers

    // âœ… CORRECTION : URL corrigÃ©e
    const response = await fetch(`${API_BASE_URL}/conversations/user/${userId}`, {
      method: 'DELETE',
      headers
    })

    console.log('ğŸ“¡ [apiService] Clear all statut (auth-temp):', response.status)

    if (!response.ok) {
      const errorText = await response.text()
      console.error('âŒ [apiService] Erreur clear all conversations (auth-temp):', errorText)
      
      if (response.status === 401) {
        throw new Error('Session expirÃ©e. Veuillez vous reconnecter.')
      }
      
      throw new Error(`Erreur suppression conversations: ${response.status}`)
    }

    const result = await response.json()
    console.log('âœ… [apiService] Toutes conversations supprimÃ©es (auth-temp):', {
      message: result.message,
      deleted_count: result.deleted_count || 0
    })

  } catch (error) {
    console.error('âŒ [apiService] Erreur suppression toutes conversations (auth-temp):', error)
    throw error
  }
}

/**
 * âœ… TOUTES LES AUTRES FONCTIONS RESTENT IDENTIQUES MAIS AVEC AUTH-TEMP HEADERS
 */
export const sendFeedback = async (
  conversationId: string,
  feedback: 1 | -1,
  comment?: string
): Promise<void> => {
  if (!conversationId) {
    throw new Error('ID de conversation requis')
  }

  console.log('ğŸ‘ğŸ‘ [apiService] Envoi feedback (auth-temp):', feedback, 'pour conversation:', conversationId)

  try {
    const requestBody = {
      conversation_id: conversationId,
      rating: feedback === 1 ? 'positive' : 'negative',
      ...(comment && { comment: comment.trim() })
    }

    const headers = getAuthHeaders() // ğŸ”§ CORRECTION: Utilise auth-temp headers

    const response = await fetch(`${API_BASE_URL}/expert/feedback`, {
      method: 'POST',
      headers,
      body: JSON.stringify(requestBody)
    })

    console.log('ğŸ“¡ [apiService] Feedback statut (auth-temp):', response.status)

    if (!response.ok) {
      const errorText = await response.text()
      console.error('âŒ [apiService] Erreur feedback (auth-temp):', errorText)
      
      if (response.status === 401) {
        throw new Error('Session expirÃ©e. Veuillez vous reconnecter.')
      }
      
      throw new Error(`Erreur envoi feedback: ${response.status}`)
    }

    console.log('âœ… [apiService] Feedback envoyÃ© avec succÃ¨s (auth-temp)')

  } catch (error) {
    console.error('âŒ [apiService] Erreur feedback (auth-temp):', error)
    throw error
  }
}

export const loadUserConversations = async (userId: string): Promise<any> => {
  if (!userId) {
    throw new Error('User ID requis')
  }

  console.log('ğŸ“‚ [apiService] Chargement conversations pour (auth-temp):', userId)

  try {
    const headers = getAuthHeaders() // ğŸ”§ CORRECTION: Utilise auth-temp headers

    const response = await fetch(`${API_BASE_URL}/conversations/user/${userId}`, {
      method: 'GET',
      headers
    })

    console.log('ğŸ“¡ [apiService] Conversations statut (auth-temp):', response.status)

    if (!response.ok) {
      const errorText = await response.text()
      console.error('âŒ [apiService] Erreur conversations (auth-temp):', errorText)
      
      if (response.status === 401) {
        throw new Error('Session expirÃ©e. Veuillez vous reconnecter.')
      }
      
      throw new Error(`Erreur chargement conversations: ${response.status}`)
    }

    const data = await response.json()
    console.log('âœ… [apiService] Conversations chargÃ©es (auth-temp):', {
      count: data.count,
      conversations: data.conversations?.length || 0
    })

    return data

  } catch (error) {
    console.error('âŒ [apiService] Erreur chargement conversations (auth-temp):', error)
    throw error
  }
}

export const getTopicSuggestions = async (language: string = 'fr'): Promise<string[]> => {
  console.log('ğŸ’¡ [apiService] RÃ©cupÃ©ration suggestions sujets (auth-temp):', language)

  try {
    const headers = getAuthHeaders() // ğŸ”§ CORRECTION: Utilise auth-temp headers

    const response = await fetch(`${API_BASE_URL}/expert/topics?language=${language}`, {
      method: 'GET',
      headers
    })

    if (!response.ok) {
      console.warn('âš ï¸ [apiService] Erreur rÃ©cupÃ©ration sujets (auth-temp):', response.status)
      
      return [
        "ProblÃ¨mes de croissance poulets",
        "Conditions environnementales optimales",
        "Protocoles de vaccination",
        "Diagnostic problÃ¨mes de santÃ©",
        "Nutrition et alimentation",
        "Gestion de la mortalitÃ©"
      ]
    }

    const data = await response.json()
    console.log('âœ… [apiService] Sujets rÃ©cupÃ©rÃ©s (auth-temp):', data.topics?.length || 0)

    return Array.isArray(data.topics) ? data.topics : []

  } catch (error) {
    console.error('âŒ [apiService] Erreur sujets (auth-temp):', error)
    
    return [
      "ProblÃ¨mes de croissance poulets",
      "Conditions environnementales optimales", 
      "Protocoles de vaccination",
      "Diagnostic problÃ¨mes de santÃ©",
      "Nutrition et alimentation",
      "Gestion de la mortalitÃ©"
    ]
  }
}

export const checkAPIHealth = async (): Promise<boolean> => {
  try {
    const response = await fetch(`${API_BASE_URL}/system/health`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Origin': 'https://expert.intelia.com' // ğŸ”§ AJOUT: Header CORS
      }
    })

    const isHealthy = response.ok
    console.log('ğŸ¥ [apiService] API Health (auth-temp):', isHealthy ? 'OK' : 'KO')
    
    return isHealthy

  } catch (error) {
    console.error('âŒ [apiService] Erreur health check (auth-temp):', error)
    return false
  }
}

/**
 * âœ… UTILITAIRES CLARIFICATION - INCHANGÃ‰S (PRÃ‰SERVÃ‰S INTÃ‰GRALEMENT)
 */
export const buildClarificationEntities = (
  clarificationAnswers: Record<string, string>,
  clarificationQuestions: string[]
): Record<string, any> => {
  const entities: Record<string, any> = {}
  
  Object.entries(clarificationAnswers).forEach(([index, answer]) => {
    if (answer && answer.trim()) {
      try {
        const questionIndex = parseInt(index)
        if (questionIndex >= 0 && questionIndex < clarificationQuestions.length) {
          const question = clarificationQuestions[questionIndex].toLowerCase()
          
          if (question.includes('race') || question.includes('breed') || question.includes('souche')) {
            entities.breed = answer.trim()
          } else if (question.includes('sexe') || question.includes('sex') || question.includes('mÃ¢le') || question.includes('femelle')) {
            entities.sex = answer.trim()
          } else if (question.includes('Ã¢ge') || question.includes('age') || question.includes('jour') || question.includes('semaine')) {
            entities.age = answer.trim()
          } else if (question.includes('poids') || question.includes('weight')) {
            entities.weight = answer.trim()
          } else if (question.includes('tempÃ©rature') || question.includes('temperature')) {
            entities.temperature = answer.trim()
          } else if (question.includes('nombre') || question.includes('quantitÃ©') || question.includes('effectif')) {
            entities.quantity = answer.trim()
          } else {
            entities[`answer_${questionIndex}`] = answer.trim()
          }
        }
      } catch {
        // Ignorer les index invalides
      }
    }
  })
  
  console.log('ğŸ” [apiService] EntitÃ©s construites:', entities)
  return entities
}

/**
 * âœ… TOUTES LES AUTRES FONCTIONS UTILITAIRES INCHANGÃ‰ES (PRÃ‰SERVÃ‰ES INTÃ‰GRALEMENT)
 */
export const handleEnhancedNetworkError = (error: any): string => {
  if (error?.message?.includes('Failed to fetch')) {
    return 'ProblÃ¨me de connexion. VÃ©rifiez votre connexion internet.'
  }
  
  if (error?.message?.includes('Session expirÃ©e')) {
    return 'Votre session a expirÃ©. Veuillez vous reconnecter.'
  }
  
  if (error?.message?.includes('AccÃ¨s non autorisÃ©')) {
    return 'Vous n\'avez pas l\'autorisation d\'effectuer cette action.'
  }
  
  if (error?.message?.includes('DialogueManager') || error?.message?.includes('ask')) {
    return 'Erreur du systÃ¨me expert. Veuillez rÃ©essayer.'
  }
  
  return error?.message || 'Une erreur inattendue s\'est produite.'
}

export const debugEnhancedConversationFlow = (
  step: string,
  conversationId: string | undefined,
  additionalInfo?: any
) => {
  console.log(`ğŸ” [DialogueManager Debug] ${step}:`, {
    session_id: conversationId || 'GÃ‰NÃ‰RÃ‰_AUTO',
    endpoint: 'ask (DialogueManager)',
    auth_system: 'auth-temp',
    timestamp: new Date().toISOString(),
    ...additionalInfo
  })
}

export const debugEnhancedAPI = () => {
  console.group('ğŸ”§ [apiService] Configuration DialogueManager + expert.py + AUTH-TEMP CORRIGÃ‰E + VALIDATION_REJECTED + CONVERSATION_SERVICE + DELETE_FIX + HEURE_LOCALE')
  console.log('API_BASE_URL:', API_BASE_URL)
  console.log('SystÃ¨me backend: DialogueManager + expert.py')
  console.log('SystÃ¨me auth: auth-temp endpoints')
  console.log('Endpoint principal:', `${API_BASE_URL}/expert/ask`)
  console.log('ğŸ”§ CORRECTIONS EFFECTUÃ‰ES:')
  console.log('  âœ… Body avec session_id: { session_id, question }')
  console.log('  âœ… Headers avec CORS Origin obligatoire')
  console.log('  âœ… Auth-temp token dans Authorization header')
  console.log('  âœ… Extraction correcte du texte selon type')
  console.log('  âœ… Support type: "answer" avec data.answer.text')
  console.log('  âœ… Support type: "partial_answer"')
  console.log('  âœ… Support type: "clarification"')
  console.log('  ğŸŒ¾ Support type: "validation_rejected" (NOUVEAU !)')
  console.log('  âœ… GÃ©nÃ©ration automatique response_versions')
  console.log('  ğŸ”§ Stockage automatique session ID pour historique (NOUVEAU !)')
  console.log('  âœ… Sauvegarde conversation dÃ©sactivÃ©e (endpoint manquant - CORRIGÃ‰ !)')
  console.log('  ğŸ†• DELETE conversation corrigÃ© (/conversations au pluriel)')
  console.log('  ğŸ†• CLEAR ALL conversations ajoutÃ©')
  console.log('  ğŸ†• Formatage heure locale (formatToLocalTime, simpleLocalTime)')
  console.log('  ğŸ”§ AUTH-TEMP: Headers avec Origin + Authorization')
  console.log('FONCTIONNALITÃ‰S PRÃ‰SERVÃ‰ES:')
  console.log('  âœ… Authentification JWT (auth-temp)')
  console.log('  âœ… Feedback, conversations, topics')
  console.log('  âœ… Gestion erreurs')
  console.log('  âœ… Health check')
  console.log('  âœ… Utilitaires clarification')
  console.log('  âœ… IntÃ©gration ConversationService')
  console.groupEnd()
}

export const testEnhancedConversationContinuity = async (
  user: any,
  language: string = 'fr'
): Promise<{
  first_conversation_id: string,
  second_conversation_id: string,
  same_id: boolean,
  success: boolean,
  enhancements_used: string[]
}> => {
  try {
    console.log('ğŸ§ª [apiService] Test continuitÃ© DialogueManager (auth-temp)...')
    
    const firstResponse = await generateAIResponse(
      "Test question 1: Qu'est-ce que les poulets de chair ?",
      user,
      language
    )
    
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    const secondResponse = await generateAIResponse(
      "Test question 2: Quel est leur poids optimal Ã  12 jours ?",
      user,
      language,
      firstResponse.conversation_id
    )
    
    const sameId = firstResponse.conversation_id === secondResponse.conversation_id
    
    console.log('ğŸ§ª [apiService] Test DialogueManager rÃ©sultat (auth-temp):', {
      first_id: firstResponse.conversation_id,
      second_id: secondResponse.conversation_id,
      same_id: sameId,
      first_type: firstResponse.type,
      second_type: secondResponse.type
    })
    
    return {
      first_conversation_id: firstResponse.conversation_id,
      second_conversation_id: secondResponse.conversation_id,
      same_id: sameId,
      success: true,
      enhancements_used: ['DialogueManager', 'expert.py', 'ConversationService', 'DeleteFix', 'HeureLocale', 'AuthTemp']
    }
    
  } catch (error) {
    console.error('âŒ [apiService] Erreur test DialogueManager (auth-temp):', error)
    return {
      first_conversation_id: '',
      second_conversation_id: '',
      same_id: false,
      success: false,
      enhancements_used: []
    }
  }
}

export const detectAPIVersion = async (): Promise<'dialoguemanager' | 'legacy' | 'error'> => {
  try {
    const response = await fetch(`${API_BASE_URL}/expert/ask`, {
      method: 'OPTIONS',
      headers: { 
        'Content-Type': 'application/json',
        'Origin': 'https://expert.intelia.com' // ğŸ”§ AJOUT: Header CORS
      }
    })
    
    if (response.ok || response.status === 405) {
      console.log('âœ… [detectAPIVersion] DialogueManager /ask disponible (auth-temp)')
      return 'dialoguemanager'
    }
    
    return 'error'
    
  } catch (error) {
    console.error('âŒ [detectAPIVersion] Erreur dÃ©tection (auth-temp):', error)
    return 'error'
  }
}

export const logEnhancedAPIInfo = () => {
  console.group('ğŸš€ [apiService] DialogueManager + expert.py Integration + AUTH-TEMP CORRIGÃ‰E + VALIDATION_REJECTED + CONVERSATION_SERVICE + DELETE_FIX + HEURE_LOCALE')
  console.log('Version:', 'DialogueManager v1.0 - AUTH-TEMP + TYPE ANSWER + VALIDATION_REJECTED + CONVERSATION_SERVICE + DELETE_FIX + HEURE_LOCALE FIXED')
  console.log('Base URL:', API_BASE_URL)
  console.log('Backend: expert.py + DialogueManager + Agricultural Validator')
  console.log('Auth System: auth-temp endpoints')
  console.log('ğŸ”§ CHANGEMENTS MAJEURS CORRIGÃ‰S:')
  console.log('  - ğŸš€ Utilisation endpoint /ask simplifiÃ©')
  console.log('  - ğŸ”§ Session ID dans le BODY (corrigÃ© !)')
  console.log('  - ğŸ”§ Headers avec CORS Origin obligatoire')
  console.log('  - ğŸ”§ Auth-temp: localStorage auth_token + Authorization header')
  console.log('  - ğŸš¨ Extraction type: "answer" de data.answer.text (CORRIGÃ‰ !)')
  console.log('  - ğŸŒ¾ Support type: "validation_rejected" (NOUVEAU !)')
  console.log('  - ğŸ”§ Stockage automatique session ID pour historique (NOUVEAU !)')
  console.log('  - ğŸš€ Sauvegarde conversation dÃ©sactivÃ©e (endpoint manquant - CORRIGÃ‰ !)')
  console.log('  - ğŸ†• DELETE conversation corrigÃ© (/conversations au pluriel)')
  console.log('  - ğŸ†• CLEAR ALL conversations ajoutÃ©')
  console.log('  - ğŸ†• Formatage heure locale (formatToLocalTime, simpleLocalTime)')
  console.log('  - ğŸš€ Body: { session_id, question }')
  console.log('  - ğŸš€ Support type: clarification/answer/partial_answer/validation_rejected')
  console.log('  - ğŸš€ PRÃ‰SERVATION format partial_answer')
  console.log('  - ğŸš€ Conversion automatique format')
  console.log('  - ğŸ”§ AUTH-TEMP: Fallback Supabase + prioritÃ© auth_token')
  console.log('FONCTIONNALITÃ‰S:')
  console.log('  - âœ… Clarification intelligente automatique')
  console.log('  - âœ… Gestion mÃ©moire conversation Postgres')
  console.log('  - âœ… Pipeline RAG modulaire')
  console.log('  - ğŸŒ¾ Validation agricole intÃ©grÃ©e (NOUVEAU !)')
  console.log('  - âœ… Toutes fonctions frontend prÃ©servÃ©es')
  console.log('  - âœ… Support PerfStore avec type: "answer"')
  console.log('  - ğŸ”§ IntÃ©gration ConversationService pour historique (NOUVEAU !)')
  console.log('  - âœ… Sauvegarde automatique via /expert/ask (CORRIGÃ‰ !)')
  console.log('  - ğŸ†• Gestion DELETE conversations (NOUVEAU !)')
  console.log('  - ğŸ†• Formatage heure locale automatique (NOUVEAU !)')
  console.log('  - ğŸ”§ Auth-temp: Compatible avec systÃ¨me actuel (NOUVEAU !)')
  console.groupEnd()
}

// Export par dÃ©faut de la fonction principale
export default generateAIResponse