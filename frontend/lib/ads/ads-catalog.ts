/**
 * Catalogue centralis√© des publicit√©s avec syst√®me de rotation
 */

import { ad01Config } from "./ad-01-poultry-ai/config";
import { ad01Translations, type SupportedLanguage } from "./ad-01-poultry-ai/translations";
import { ad02Config } from "./ad-02-smart-sensors/config";
import { ad02Translations } from "./ad-02-smart-sensors/translations";
import { PersistentJSONStorage } from "../utils/persistentStorage";

// Type pour une publicit√© compl√®te
export interface Ad {
  id: string;
  imageUrl: string;
  ctaUrl: string;
  category: string;
  targetAudience: string[];
  priority: number;
  isActive: boolean;
  startDate: string;
  endDate: string | null;
  translations: Record<SupportedLanguage, any>;
}

// Catalogue de toutes les publicit√©s disponibles
export const ADS_CATALOG: Ad[] = [
  {
    ...ad01Config,
    translations: ad01Translations,
  },
  {
    ...ad02Config,
    translations: ad02Translations,
  },
  // FUTURE: Ajoutez ici ad-03, ad-04, etc.
  // {
  //   ...ad03Config,
  //   translations: ad03Translations,
  // },
];

/**
 * Filtre les publicit√©s actives
 */
export function getActiveAds(): Ad[] {
  const now = new Date();

  return ADS_CATALOG.filter((ad) => {
    if (!ad.isActive) return false;

    const startDate = new Date(ad.startDate);
    if (now < startDate) return false;

    if (ad.endDate) {
      const endDate = new Date(ad.endDate);
      if (now > endDate) return false;
    }

    return true;
  });
}

/**
 * Filtre les publicit√©s par type d'utilisateur
 */
export function getAdsForUserType(userType?: string): Ad[] {
  const activeAds = getActiveAds();

  if (!userType) return activeAds;

  return activeAds.filter((ad) =>
    ad.targetAudience.includes(userType) || ad.targetAudience.includes("all")
  );
}

/**
 * Syst√®me de rotation intelligent avec stockage persistant multi-m√©thodes
 * √âvite de montrer la m√™me pub deux fois de suite
 */
const AD_HISTORY_KEY = "intelia_ad_history";
const MAX_HISTORY_SIZE = 10; // Garder les 10 derni√®res pubs montr√©es

// Utiliser le stockage persistant (cookie + localStorage + sessionStorage)
const adHistoryStorage = new PersistentJSONStorage<string[]>(AD_HISTORY_KEY);

function getAdHistory(): string[] {
  try {
    console.log(`[AdCatalog] üîç Lecture de la cl√©: ${AD_HISTORY_KEY}`);
    const history = adHistoryStorage.get();
    console.log(`[AdCatalog] üîç Historique r√©cup√©r√©:`, history);

    if (!history || !Array.isArray(history)) {
      console.log(`[AdCatalog] üîç Pas de donn√©es valides, retour tableau vide`);
      return [];
    }

    return history;
  } catch (error) {
    console.error(`[AdCatalog] ‚ùå Erreur lecture historique:`, error);
    return [];
  }
}

function addToHistory(adId: string): void {
  try {
    console.log(`[AdCatalog] üîµ D√©but addToHistory pour: ${adId}`);
    const history = getAdHistory();
    console.log(`[AdCatalog] üîµ Historique actuel:`, history);

    history.unshift(adId); // Ajouter au d√©but
    console.log(`[AdCatalog] üîµ Apr√®s ajout:`, history);

    // Garder seulement les N derni√®res
    const trimmedHistory = history.slice(0, MAX_HISTORY_SIZE);
    console.log(`[AdCatalog] üîµ Apr√®s trim:`, trimmedHistory);

    // Sauvegarder avec le syst√®me persistant (cookie + localStorage + sessionStorage)
    adHistoryStorage.set(trimmedHistory);
    console.log(`[AdCatalog] üîµ Sauvegarde persistante r√©ussie`);

    // V√©rification imm√©diate
    const verification = adHistoryStorage.get();
    console.log(`[AdCatalog] üîµ V√©rification imm√©diate:`, verification);
  } catch (error) {
    console.error("[AdCatalog] ‚ùå Erreur sauvegarde historique:", error);
  }
}

/**
 * S√©lectionne la prochaine publicit√© √† afficher
 * Logique de rotation stricte: jamais la m√™me pub deux fois de suite
 * Alternance garantie: pub1 ‚Üí pub2 ‚Üí pub1 ‚Üí pub2
 * NOTE: N'ajoute PAS √† l'historique ici - l'historique est ajout√© quand la pub est affich√©e
 */
export function selectNextAd(userType?: string): Ad | null {
  const eligibleAds = getAdsForUserType(userType);

  if (eligibleAds.length === 0) {
    console.warn("[AdCatalog] Aucune publicit√© active disponible");
    return null;
  }

  // Si une seule pub, pas de choix
  if (eligibleAds.length === 1) {
    return eligibleAds[0];
  }

  // Logique de rotation stricte
  const history = getAdHistory();
  const lastShownId = history[0]; // La derni√®re montr√©e

  console.log(`[AdCatalog] Derni√®re pub affich√©e: ${lastShownId}, Historique:`, history);

  // Trier par priorit√© (1 = haute, 2 = moyenne, etc.)
  const sortedAds = [...eligibleAds].sort((a, b) => a.priority - b.priority);

  // GARANTIE D'ALTERNANCE: Filtrer TOUTES les pubs diff√©rentes de la derni√®re
  const differentAds = sortedAds.filter((ad) => ad.id !== lastShownId);

  // S'il y a au moins une pub diff√©rente, la choisir
  if (differentAds.length > 0) {
    // Prendre la premi√®re (plus haute priorit√©) parmi les pubs diff√©rentes
    const selectedAd = differentAds[0];
    console.log(`[AdCatalog] S√©lection alternance: ${lastShownId} ‚Üí ${selectedAd.id}`);
    return selectedAd;
  }

  // Cas edge (ne devrait jamais arriver si eligibleAds.length > 1)
  // Si toutes les pubs sont identiques √† la derni√®re (impossible normalement)
  const selectedAd = sortedAds[0];
  console.log(`[AdCatalog] S√©lection par d√©faut: ${selectedAd.id}`);
  return selectedAd;
}

/**
 * Enregistre qu'une publicit√© a √©t√© affich√©e
 * √Ä appeler UNIQUEMENT quand la pub est effectivement montr√©e √† l'utilisateur
 */
export function markAdAsShown(adId: string): void {
  addToHistory(adId);
  console.log(`[AdCatalog] ‚úÖ Pub marqu√©e comme affich√©e: ${adId}`);
}

/**
 * Obtient les traductions d'une pub pour une langue donn√©e
 */
export function getAdTranslations(ad: Ad, language: string) {
  // Fallback vers anglais si la langue n'existe pas
  const lang = (ad.translations[language as SupportedLanguage]
    ? language
    : "en") as SupportedLanguage;

  return ad.translations[lang];
}

/**
 * R√©initialise l'historique (utile pour le dev/test)
 */
export function clearAdHistory(): void {
  try {
    adHistoryStorage.remove();
    console.log("[AdCatalog] Historique r√©initialis√© (cookie + localStorage + sessionStorage)");
  } catch (error) {
    console.error("[AdCatalog] Erreur r√©initialisation historique:", error);
  }
}

/**
 * Debug: Affiche l'√©tat du syst√®me de pubs
 */
export function debugAdSystem(): void {
  console.group("üìä [AdCatalog] √âtat du syst√®me");
  console.log("Total pubs catalog:", ADS_CATALOG.length);
  console.log("Pubs actives:", getActiveAds().length);
  console.log("Historique:", getAdHistory());
  console.log("Prochaine pub:", selectNextAd()?.id);
  console.groupEnd();
}

// Export pour debug dans la console navigateur
if (typeof window !== "undefined") {
  (window as any).debugAdSystem = debugAdSystem;
  (window as any).clearAdHistory = clearAdHistory;
}
