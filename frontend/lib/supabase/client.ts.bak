// lib/supabase/client.ts â€“ CLIENT SUPABASE SÃ‰CURISÃ‰ (timeout 25s) + DEBUG + SINGLETON
'use client'

// âœ… CHANGEMENT CRITIQUE: Utiliser le singleton au lieu de crÃ©er de nouvelles instances
import { getSupabaseClient, resetSupabaseClient } from './singleton'
import type { Database } from '@/types/supabase'

// âœ… EXPORT DU CLIENT SINGLETON au lieu de createClientComponentClient
export const supabase = getSupabaseClient()

// Configuration env (conservÃ©e pour compatibilitÃ©)
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

if (!SUPABASE_URL) throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_URL')
if (!SUPABASE_ANON_KEY) throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_ANON_KEY')

// ---- DEBUG (conservÃ© tel quel) ----
const SUPABASE_DEBUG = (
  (typeof window !== 'undefined' && (
    localStorage.getItem('SUPABASE_DEBUG') === '1' ||
    localStorage.getItem('AUTH_DEBUG') === '1'
  )) || process.env.NEXT_PUBLIC_SUPABASE_DEBUG === '1' || process.env.NEXT_PUBLIC_AUTH_DEBUG === '1'
)

const slog = (...args: any[]) => {
  if (SUPABASE_DEBUG) {
    if (typeof window !== 'undefined') console.debug('[SupabaseClient/Singleton]', ...args)
    else console.debug('[SupabaseClient/Singleton/SSR]', ...args)
  }
}

slog('âœ… Loaded client.ts (supabase singleton client ready)', { url: SUPABASE_URL })

// â³ fetch avec timeout (conservÃ© tel quel)
let __fetchSeq = 0
export const fetchWithTimeout = (ms: number = 45000) => {
  return async (input: RequestInfo | URL, init: RequestInit = {}) => {
    const idNum = ++__fetchSeq
    const start = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now()
    const controller = new AbortController()
    try {
      controller.signal.addEventListener('abort', () => {
        try { slog(`#${idNum} âš ï¸ signal aborted`, (controller as any)?.signal?.reason || '(no reason)') } catch {}
      })
    } catch {}
    const to = setTimeout(() => {
      const reason = new Error(`timeout:${ms}ms`)
      try { (controller as any).abort(reason) } catch { controller.abort() }
      try {
        slog(`#${idNum} â±ï¸ ABORT after ${ms}ms`, { reason: reason.message, url: (input as any)?.toString?.() ?? String(input) })
      } catch {}
    }, ms)

    try {
      slog(`#${idNum} â†— fetch start`, (input as any)?.toString?.() ?? String(input), { timeout_ms: ms })
      const res = await fetch(input, { ...init, signal: controller.signal })
      const dur = Math.round(((typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now()) - start))
      slog(`#${idNum} â†™ fetch end`, { status: (res as any)?.status, duration_ms: dur })
      return res
    } catch (e) {
      const dur = Math.round(((typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now()) - start))
      slog(`#${idNum} âœ– fetch error after ${dur}ms`, e)
      throw e
    } finally {
      clearTimeout(to)
    }
  }
}

// âœ… CHANGEMENT: supabaseAuth utilise maintenant le singleton avec fetch temporisÃ©
// Au lieu de crÃ©er une nouvelle instance, on utilise le singleton existant
export const supabaseAuth = getSupabaseClient()

slog('ğŸ” supabaseAuth using singleton (no new instance created)')

// â€”â€” Helpers d'auth (conservÃ©s mais utilisent le singleton) â€”â€”
export const auth = {
  async getSession() {
    // âœ… Utilise le singleton
    const client = getSupabaseClient()
    const { data } = await client.auth.getSession()
    slog('getSession â†¦', !!data?.session)
    return data?.session || null
  },

  async getAccessToken() {
    const session = await this.getSession()
    const token = session?.access_token || null
    slog('getAccessToken â†¦', token ? 'present' : 'null')
    return token
  },

  async logout() {
    try {
      slog('logout() called')
      // âœ… Utilise le singleton
      const client = getSupabaseClient()
      const { error } = await client.auth.signOut()
      if (error) throw error
      try { localStorage.removeItem('intelia-chat-storage') } catch {}
      slog('logout() â†¦ success')
      return { success: true }
    } catch (error) {
      console.error('âŒ Erreur dÃ©connexion:', error)
      return { success: false, error }
    }
  },
}

// â€”â€” RequÃªtes sÃ©curisÃ©es (conservÃ©es, utilisent auth.getAccessToken qui utilise le singleton) â€”â€”
export const secureRequest = {
  async get(url: string, options: RequestInit = {}) {
    const token = await auth.getAccessToken()
    if (!token) throw new Error('Non authentifiÃ©')
    slog('secure GET', url)
    return fetch(url, {
      ...options,
      headers: { 'Authorization': `Bearer ${token}`, ...(options.headers || {}) },
      method: 'GET',
    })
  },
  async post(url: string, data: any, options: RequestInit = {}) {
    const token = await auth.getAccessToken()
    if (!token) throw new Error('Non authentifiÃ©')
    slog('secure POST', url, { hasBody: true })
    return fetch(url, {
      ...options,
      method: 'POST',
      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json', ...(options.headers || {}) },
      body: JSON.stringify(data),
    })
  },
}

// âœ… NOUVELLES FONCTIONS UTILITAIRES POUR LE SINGLETON
export const getAuthHeaders = async () => {
  try {
    const client = getSupabaseClient()
    const { data: { session }, error } = await client.auth.getSession()
    
    if (error) {
      console.error('âŒ [client] Erreur rÃ©cupÃ©ration session:', error.message)
      return {
        'Content-Type': 'application/json',
      }
    }

    if (!session?.access_token) {
      console.warn('âš ï¸ [client] Aucun token d\'accÃ¨s disponible')
      return {
        'Content-Type': 'application/json',
      }
    }

    console.log('âœ… [client] Token Supabase rÃ©cupÃ©rÃ© avec succÃ¨s (singleton)')
    return {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${session.access_token}`,
      'X-Supabase-Auth': 'true',
    }
  } catch (error) {
    console.error('âŒ [client] Erreur getAuthHeaders (singleton):', error)
    return {
      'Content-Type': 'application/json',
    }
  }
}

// âœ… FONCTION POUR RÃ‰INITIALISER LE SINGLETON (utile pour logout complet)
export const resetClient = () => {
  resetSupabaseClient()
  slog('ğŸ”„ Client singleton rÃ©initialisÃ©')
}

// Export par dÃ©faut (utilise le singleton)
export default supabase