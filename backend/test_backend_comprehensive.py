#!/usr/bin/env python3
"""
Script de Test Complet Backend Intelia Expert
VERSION 3.5.0 - Post-corrections expert.py et auth.py

Ce script teste TOUS les endpoints pour s'assurer que le backend est solide
apr√®s les modifications critiques dans expert.py et auth.py.

Usage:
    python test_backend_comprehensive.py [--base-url http://localhost:8080] [--verbose]
"""

import requests
import json
import time
import argparse
import sys
from datetime import datetime
from typing import Dict, List, Any, Optional
import uuid
import base64

class BackendTester:
    def __init__(self, base_url: str = "http://localhost:8080", verbose: bool = False):
        self.base_url = base_url.rstrip('/')
        self.verbose = verbose
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json; charset=utf-8',
            'Accept': 'application/json',
            'Accept-Charset': 'utf-8',
            'User-Agent': 'Intelia-Backend-Tester/3.5.0'
        })
        
        # R√©sultats des tests
        self.test_results = []
        self.auth_token = None
        self.test_user_email = "test@intelia.com"
        self.test_conversation_id = None
        
        # Donn√©es de test UTF-8
        self.utf8_test_cases = {
            "french_accents": "Temp√©rature √©lev√©e √† 32¬∞C pour poulets - humidit√© 65%",
            "spanish_special": "¬øCu√°l es la nutrici√≥n √≥ptima para pollos de engorde?",
            "symbols_mixed": "Co√ªt: 15‚Ç¨/kg, efficacit√©: 95%, temp√©rature: 32¬∞C",
            "complex_question": "Mes poulets Ross 308 de 25 jours p√®sent 800g √† 32¬∞C - est-ce normal?",
            "emoji_question": "üêî Probl√®me croissance poulets üìä Besoin aide urgente! üî•"
        }
        
        print(f"üöÄ Initialisation du testeur backend")
        print(f"üì° URL de base: {self.base_url}")
        print(f"üî§ Mode verbose: {verbose}")
        print(f"üß™ Cas de test UTF-8: {len(self.utf8_test_cases)}")

    def log(self, message: str, level: str = "INFO"):
        """Log avec timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        if self.verbose or level in ["ERROR", "SUCCESS", "FAIL"]:
            print(f"[{timestamp}] {level}: {message}")

    def make_request(self, method: str, endpoint: str, data: Optional[Dict] = None, 
                    headers: Optional[Dict] = None, timeout: int = 30) -> Dict[str, Any]:
        """Effectue une requ√™te HTTP avec gestion d'erreurs compl√®te"""
        url = f"{self.base_url}{endpoint}"
        
        # Headers par d√©faut + headers sp√©cifiques
        request_headers = self.session.headers.copy()
        if headers:
            request_headers.update(headers)
        
        self.log(f"üîÑ {method} {endpoint}", "DEBUG")
        
        try:
            response = self.session.request(
                method=method,
                url=url,
                json=data if data else None,
                headers=request_headers,
                timeout=timeout
            )
            
            # Tentative de parsing JSON
            try:
                response_data = response.json()
            except json.JSONDecodeError:
                response_data = {"raw_response": response.text}
            
            result = {
                "success": response.status_code < 400,
                "status_code": response.status_code,
                "response": response_data,
                "headers": dict(response.headers),
                "url": url,
                "method": method,
                "request_data": data
            }
            
            # Log du r√©sultat
            if response.status_code < 400:
                self.log(f"‚úÖ {method} {endpoint} -> {response.status_code}", "SUCCESS")
            else:
                self.log(f"‚ùå {method} {endpoint} -> {response.status_code}: {response_data}", "ERROR")
            
            return result
            
        except requests.exceptions.Timeout:
            error_result = {
                "success": False,
                "status_code": 0,
                "response": {"error": "Request timeout"},
                "url": url,
                "method": method,
                "request_data": data
            }
            self.log(f"‚è∞ {method} {endpoint} -> Timeout", "ERROR")
            return error_result
            
        except requests.exceptions.ConnectionError:
            error_result = {
                "success": False,
                "status_code": 0,
                "response": {"error": "Connection error - Backend may be down"},
                "url": url,
                "method": method,
                "request_data": data
            }
            self.log(f"üîå {method} {endpoint} -> Connection Error", "ERROR")
            return error_result
            
        except Exception as e:
            error_result = {
                "success": False,
                "status_code": 0,
                "response": {"error": f"Unexpected error: {str(e)}"},
                "url": url,
                "method": method,
                "request_data": data
            }
            self.log(f"üí• {method} {endpoint} -> Unexpected Error: {e}", "ERROR")
            return error_result

    def test_endpoint(self, name: str, method: str, endpoint: str, 
                     data: Optional[Dict] = None, headers: Optional[Dict] = None,
                     expected_status: int = 200, description: str = "") -> Dict[str, Any]:
        """Test un endpoint sp√©cifique"""
        self.log(f"üß™ Test: {name}", "INFO")
        
        start_time = time.time()
        result = self.make_request(method, endpoint, data, headers)
        duration = round((time.time() - start_time) * 1000, 2)
        
        # √âvaluation du test
        test_passed = (
            result["success"] and 
            result["status_code"] == expected_status
        )
        
        test_result = {
            "name": name,
            "description": description,
            "endpoint": endpoint,
            "method": method,
            "expected_status": expected_status,
            "actual_status": result["status_code"],
            "passed": test_passed,
            "duration_ms": duration,
            "response": result["response"],
            "timestamp": datetime.now().isoformat()
        }
        
        self.test_results.append(test_result)
        
        if test_passed:
            self.log(f"‚úÖ {name} -> PASSED ({duration}ms)", "SUCCESS")
        else:
            self.log(f"‚ùå {name} -> FAILED ({duration}ms) - Status: {result['status_code']}", "FAIL")
            if self.verbose:
                self.log(f"   Response: {result['response']}", "DEBUG")
        
        return test_result

    def run_health_tests(self):
        """Tests des endpoints de sant√© syst√®me"""
        print("\n" + "="*60)
        print("ü©∫ TESTS DE SANT√â SYST√àME")
        print("="*60)
        
        # Test root endpoint
        self.test_endpoint(
            "Root API Info",
            "GET", "/",
            description="Endpoint racine avec informations API"
        )
        
        # Test health principal
        self.test_endpoint(
            "Health Check Principal",
            "GET", "/health",
            description="Health check global de l'API"
        )
        
        # Test health system
        self.test_endpoint(
            "System Health",
            "GET", "/v1/system/health",
            description="Health check syst√®me d√©taill√©"
        )
        
        # Test health logging
        self.test_endpoint(
            "Logging Health",
            "GET", "/v1/logging/health",
            description="Health check syst√®me de logging (CORRIG√â 404)"
        )
        
        # Test health admin
        self.test_endpoint(
            "Health Detailed", 
            "GET", "/v1/health/health",
            description="Health check d√©taill√© (CORRIG√â 404)"
        )

    def run_auth_tests(self):
        """Tests du syst√®me d'authentification"""
        print("\n" + "="*60)
        print("üîê TESTS D'AUTHENTIFICATION")
        print("="*60)
        
        # Test auth debug
        self.test_endpoint(
            "Auth Debug Info",
            "GET", "/v1/auth/debug",
            description="Diagnostics configuration authentification"
        )
        
        # Test login (sans credentials valides - expect 401)
        self.test_endpoint(
            "Login Test",
            "POST", "/v1/auth/login",
            data={
                "email": self.test_user_email,
                "password": "test_password_123"
            },
            expected_status=401,
            description="Test login (√©chec attendu sans compte valide)"
        )
        
        # Note: Pour les tests authentifi√©s, nous aurions besoin d'un vrai compte
        # ou d'un syst√®me de mock auth pour les tests

    def run_expert_public_tests(self):
        """Tests des endpoints expert publics (sans auth)"""
        print("\n" + "="*60)
        print("ü§ñ TESTS EXPERT SYST√àME (PUBLIC)")
        print("="*60)
        
        # Test topics (doit fonctionner sans auth)
        self.test_endpoint(
            "Expert Topics FR",
            "GET", "/v1/expert/topics?language=fr",
            description="Sujets sugg√©r√©s en fran√ßais"
        )
        
        self.test_endpoint(
            "Expert Topics EN",
            "GET", "/v1/expert/topics?language=en", 
            description="Sujets sugg√©r√©s en anglais"
        )
        
        self.test_endpoint(
            "Expert Topics ES",
            "GET", "/v1/expert/topics?language=es",
            description="Sujets sugg√©r√©s en espagnol"
        )
        
        # Test questions publiques avec cas UTF-8
        for test_name, question_text in self.utf8_test_cases.items():
            self.test_endpoint(
                f"Question Publique UTF-8: {test_name}",
                "POST", "/v1/expert/ask-public",
                data={
                    "text": question_text,
                    "language": "fr",
                    "speed_mode": "fast"
                },
                description=f"Test UTF-8 CORRIG√â: {question_text[:50]}..."
            )
        
        # Test feedback
        self.test_endpoint(
            "Feedback Submission",
            "POST", "/v1/expert/feedback",
            data={
                "rating": "positive",
                "comment": "Test feedback avec accents √©√†√ß√π",
                "conversation_id": str(uuid.uuid4())
            },
            description="Soumission feedback avec caract√®res UTF-8"
        )

    def run_expert_debug_tests(self):
        """Tests des endpoints de debug expert"""
        print("\n" + "="*60)
        print("üîß TESTS DEBUG EXPERT SYST√àME")
        print("="*60)
        
        # Test debug syst√®me
        self.test_endpoint(
            "Expert Debug System",
            "GET", "/v1/expert/debug-system",
            description="Diagnostics d√©taill√©s du syst√®me expert"
        )
        
        # Test debug auth
        self.test_endpoint(
            "Expert Debug Auth",
            "GET", "/v1/expert/debug-auth",
            description="Diagnostics rapides authentification"
        )
        
        # Test UTF-8 direct
        self.test_endpoint(
            "Expert Test UTF-8 Direct",
            "POST", "/v1/expert/test-utf8",
            data={
                "text": "Test direct UTF-8: √©√†√ß√π √±¬ø¬° 32¬∞C 95% ‚Ç¨",
                "language": "fr"
            },
            description="Test validation UTF-8 r√©√©crite"
        )

    def run_logging_tests(self):
        """Tests du syst√®me de logging"""
        print("\n" + "="*60)
        print("üìä TESTS SYST√àME DE LOGGING")
        print("="*60)
        
        # Test analytics (CORRIG√â 404)
        self.test_endpoint(
            "Logging Analytics",
            "GET", "/v1/logging/analytics?days=7",
            description="Analytics logging (ENDPOINT CORRIG√â 404)"
        )
        
        # Test admin stats (CORRIG√â 404)
        self.test_endpoint(
            "Logging Admin Stats",
            "GET", "/v1/logging/admin/stats",
            description="Statistiques admin (ENDPOINT CORRIG√â 404)"
        )
        
        # Test database info (CORRIG√â 404)
        self.test_endpoint(
            "Logging Database Info",
            "GET", "/v1/logging/database/info",
            description="Informations base de donn√©es (ENDPOINT CORRIG√â 404)"
        )
        
        # Test conversations utilisateur (CORRIG√â 404)
        test_user_id = "test_user_123"
        self.test_endpoint(
            "User Conversations",
            "GET", f"/v1/logging/conversations/{test_user_id}",
            description="Conversations utilisateur (ENDPOINT CORRIG√â 404)"
        )
        
        # Test cr√©ation conversation
        conversation_data = {
            "user_id": test_user_id,
            "question": "Test question avec accents √©√†√ß√π",
            "response": "Test r√©ponse avec caract√®res sp√©ciaux √±¬ø¬°",
            "conversation_id": str(uuid.uuid4()),
            "confidence_score": 0.85,
            "response_time_ms": 1500,
            "language": "fr",
            "rag_used": True
        }
        
        result = self.test_endpoint(
            "Create Conversation",
            "POST", "/v1/logging/conversations",
            data=conversation_data,
            expected_status=201,
            description="Cr√©ation conversation avec donn√©es UTF-8"
        )
        
        # Garder l'ID pour les tests suivants
        if result["passed"] and "conversation_id" in result["response"]:
            self.test_conversation_id = result["response"]["conversation_id"]

    def run_admin_tests(self):
        """Tests des endpoints d'administration"""
        print("\n" + "="*60)
        print("‚öôÔ∏è TESTS ADMINISTRATION")
        print("="*60)
        
        # Test dashboard admin
        self.test_endpoint(
            "Admin Dashboard",
            "GET", "/v1/admin/dashboard",
            description="Dashboard administrateur principal"
        )
        
        # Test users admin (CORRIG√â 404)
        self.test_endpoint(
            "Admin Users",
            "GET", "/v1/admin/users",
            description="Gestion utilisateurs (ENDPOINT CORRIG√â 404)"
        )
        
        # Test RAG diagnostics
        self.test_endpoint(
            "RAG Diagnostics",
            "GET", "/v1/admin/rag/diagnostics",
            description="Diagnostics syst√®me RAG"
        )
        
        # Test RAG status
        self.test_endpoint(
            "RAG Status",
            "GET", "/v1/admin/rag/status",
            description="Status d√©taill√© syst√®me RAG"
        )

    def run_comprehensive_utf8_validation(self):
        """Tests sp√©cialis√©s pour la validation UTF-8 corrig√©e"""
        print("\n" + "="*60)
        print("üî§ TESTS VALIDATION UTF-8 RENFORC√âE")
        print("="*60)
        
        # Test corrections debug
        self.test_endpoint(
            "Debug Corrections v3.5",
            "GET", "/debug/corrections",
            description="Informations sur les corrections appliqu√©es"
        )
        
        # Test UTF-8 debug
        self.test_endpoint(
            "Debug UTF-8 Test",
            "GET", "/debug/utf8-test",
            description="Test des corrections UTF-8 appliqu√©es"
        )
        
        # Cas de test UTF-8 extr√™mes
        extreme_utf8_cases = {
            "accents_multiples": "Contr√¥le qualit√© effectu√© √† 32¬∞C avec humidit√© relative de 65%",
            "spanish_complex": "Diagn√≥stico: nutrici√≥n deficiente en prote√≠nas (18% vs 22% requerido)",
            "symbols_heavy": "Co√ªt ‚Ç¨15/kg ‚Ä¢ Temp√©rature 32¬∞C ‚Ä¢ Efficacit√© ‚â•95% ‚Ä¢ pH‚âà6.5",
            "mixed_languages": "Temperature 32¬∞C pour √©levage - ¬øes normal? Efficacit√© 95%",
            "unicode_symbols": "üå°Ô∏è32¬∞C ‚û°Ô∏è üêîPoulets ‚úÖNormal ‚ùåProbl√®me üìäStats: 95%"
        }
        
        for test_name, question_text in extreme_utf8_cases.items():
            self.test_endpoint(
                f"UTF-8 Extr√™me: {test_name}",
                "POST", "/v1/expert/ask-public",
                data={
                    "text": question_text,
                    "language": "fr",
                    "speed_mode": "fast"
                },
                description=f"Test UTF-8 extr√™me: {question_text[:40]}..."
            )

    def run_genetic_line_neutrality_tests(self):
        """Tests pour v√©rifier la neutralit√© des lign√©es g√©n√©tiques"""
        print("\n" + "="*60)
        print("üß¨ TESTS NEUTRALIT√â LIGN√âES G√âN√âTIQUES")
        print("="*60)
        
        # Questions sans mention de lign√©e (doit √™tre g√©n√©rique)
        generic_questions = [
            "Quelle est la temp√©rature optimale pour poulets de chair ?",
            "Probl√®me de croissance chez mes poulets",
            "Mortalit√© √©lev√©e dans mon √©levage"
        ]
        
        for question in generic_questions:
            result = self.test_endpoint(
                f"Question G√©n√©rique: {question[:30]}...",
                "POST", "/v1/expert/ask-public",
                data={
                    "text": question,
                    "language": "fr",
                    "speed_mode": "fast"
                },
                description="Question g√©n√©rique - r√©ponse doit √™tre neutre"
            )
            
            # V√©rifier que la r√©ponse ne mentionne pas Ross/Cobb
            if result["passed"] and "response" in result["response"]:
                response_text = result["response"].get("response", "").lower()
                has_ross = "ross" in response_text
                has_cobb = "cobb" in response_text
                if has_ross or has_cobb:
                    self.log(f"‚ö†Ô∏è R√©ponse g√©n√©rique mentionne lign√©e sp√©cifique: Ross={has_ross}, Cobb={has_cobb}", "WARNING")
        
        # Questions avec mention explicite (doit garder la mention)
        specific_questions = [
            "Mes poulets Ross 308 ont un probl√®me de croissance",
            "Temp√©rature optimale pour Cobb 500 ?",
            "Protocole vaccination pour Ross 308"
        ]
        
        for question in specific_questions:
            result = self.test_endpoint(
                f"Question Sp√©cifique: {question[:30]}...",
                "POST", "/v1/expert/ask-public", 
                data={
                    "text": question,
                    "language": "fr",
                    "speed_mode": "fast"
                },
                description="Question sp√©cifique - lign√©e peut √™tre mentionn√©e"
            )

    def run_all_tests(self):
        """Ex√©cute tous les tests"""
        print("üöÄ D√âMARRAGE DES TESTS COMPLETS BACKEND INTELIA EXPERT")
        print(f"üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"üåê Backend URL: {self.base_url}")
        
        start_time = time.time()
        
        # S√©quence compl√®te de tests
        try:
            self.run_health_tests()
            self.run_auth_tests() 
            self.run_expert_public_tests()
            self.run_expert_debug_tests()
            self.run_logging_tests()
            self.run_admin_tests()
            self.run_comprehensive_utf8_validation()
            self.run_genetic_line_neutrality_tests()
            
        except KeyboardInterrupt:
            print("\n‚ö†Ô∏è Tests interrompus par l'utilisateur")
            
        except Exception as e:
            print(f"\nüí• Erreur critique pendant les tests: {e}")
        
        total_time = time.time() - start_time
        self.print_final_report(total_time)

    def print_final_report(self, total_time: float):
        """Affiche le rapport final des tests"""
        print("\n" + "="*80)
        print("üìä RAPPORT FINAL DES TESTS")
        print("="*80)
        
        total_tests = len(self.test_results)
        passed_tests = sum(1 for test in self.test_results if test["passed"])
        failed_tests = total_tests - passed_tests
        success_rate = (passed_tests / total_tests * 100) if total_tests > 0 else 0
        
        print(f"üìà STATISTIQUES G√âN√âRALES:")
        print(f"   ‚úÖ Tests r√©ussis: {passed_tests}")
        print(f"   ‚ùå Tests √©chou√©s: {failed_tests}")
        print(f"   üìä Total tests: {total_tests}")
        print(f"   üéØ Taux de succ√®s: {success_rate:.1f}%")
        print(f"   ‚è±Ô∏è Temps total: {total_time:.2f}s")
        
        # Analyse des performances
        response_times = [test["duration_ms"] for test in self.test_results if test["passed"]]
        if response_times:
            avg_response = sum(response_times) / len(response_times)
            max_response = max(response_times)
            print(f"   üìä Temps r√©ponse moyen: {avg_response:.1f}ms")
            print(f"   üìä Temps r√©ponse max: {max_response:.1f}ms")
        
        # Tests √©chou√©s d√©taill√©s
        if failed_tests > 0:
            print(f"\n‚ùå TESTS √âCHOU√âS ({failed_tests}):")
            for test in self.test_results:
                if not test["passed"]:
                    print(f"   ‚Ä¢ {test['name']} ({test['method']} {test['endpoint']}) -> {test['actual_status']}")
                    if "error" in test["response"]:
                        print(f"     Erreur: {test['response']['error']}")
        
        # Analyse sp√©ciale des corrections
        print(f"\nüîß ANALYSE DES CORRECTIONS v3.5:")
        
        # Tests UTF-8
        utf8_tests = [test for test in self.test_results if "UTF-8" in test["name"] or "utf8" in test["name"].lower()]
        utf8_success = sum(1 for test in utf8_tests if test["passed"])
        print(f"   üî§ Tests UTF-8: {utf8_success}/{len(utf8_tests)} r√©ussis")
        
        # Tests logging (endpoints 404 corrig√©s)
        logging_tests = [test for test in self.test_results if "logging" in test["endpoint"].lower()]
        logging_success = sum(1 for test in logging_tests if test["passed"])
        print(f"   üìä Tests Logging: {logging_success}/{len(logging_tests)} r√©ussis")
        
        # Tests authentification
        auth_tests = [test for test in self.test_results if "auth" in test["endpoint"].lower() or "Auth" in test["name"]]
        auth_success = sum(1 for test in auth_tests if test["passed"])
        print(f"   üîê Tests Auth: {auth_success}/{len(auth_tests)} r√©ussis")
        
        # Recommandations
        print(f"\nüí° RECOMMANDATIONS:")
        if success_rate >= 90:
            print("   üéâ Excellent! Le backend est tr√®s stable apr√®s les corrections.")
        elif success_rate >= 75:
            print("   ‚úÖ Bon! Le backend fonctionne bien avec quelques am√©liorations mineures.")
        elif success_rate >= 50:
            print("   ‚ö†Ô∏è Attention! Plusieurs probl√®mes d√©tect√©s, investigation n√©cessaire.")
        else:
            print("   üö® Critique! Le backend n√©cessite des corrections majeures.")
        
        if failed_tests > 0:
            print("   üîç Consultez les tests √©chou√©s ci-dessus pour les corrections.")
            print("   üìã V√©rifiez que le backend est d√©marr√© et accessible.")
            print("   üîß V√©rifiez la configuration des variables d'environnement.")
        
        print("\n‚úÖ Tests termin√©s!")

    def save_report_json(self, filename: str = None):
        """Sauvegarde le rapport en JSON"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"backend_test_report_{timestamp}.json"
        
        report_data = {
            "timestamp": datetime.now().isoformat(),
            "base_url": self.base_url,
            "total_tests": len(self.test_results),
            "passed_tests": sum(1 for test in self.test_results if test["passed"]),
            "failed_tests": sum(1 for test in self.test_results if not test["passed"]),
            "success_rate": (sum(1 for test in self.test_results if test["passed"]) / len(self.test_results) * 100) if self.test_results else 0,
            "test_results": self.test_results
        }
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, indent=2, ensure_ascii=False)
            print(f"üìÑ Rapport sauvegard√©: {filename}")
        except Exception as e:
            print(f"‚ùå Erreur sauvegarde rapport: {e}")

def main():
    parser = argparse.ArgumentParser(description="Test complet du backend Intelia Expert")
    parser.add_argument("--base-url", default="http://localhost:8080", 
                       help="URL de base du backend (d√©faut: http://localhost:8080)")
    parser.add_argument("--verbose", "-v", action="store_true",
                       help="Mode verbose pour plus de d√©tails")
    parser.add_argument("--save-report", action="store_true",
                       help="Sauvegarder le rapport en JSON")
    parser.add_argument("--timeout", type=int, default=30,
                       help="Timeout des requ√™tes en secondes (d√©faut: 30)")
    
    args = parser.parse_args()
    
    # Cr√©er et ex√©cuter le testeur
    tester = BackendTester(
        base_url=args.base_url,
        verbose=args.verbose
    )
    
    try:
        tester.run_all_tests()
        
        if args.save_report:
            tester.save_report_json()
            
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Tests interrompus par l'utilisateur")
        sys.exit(1)
    except Exception as e:
        print(f"\nüí• Erreur critique: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()