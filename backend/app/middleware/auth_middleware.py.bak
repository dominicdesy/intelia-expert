# app/middleware/auth_middleware.py
"""
Middleware d'authentification globale pour l'API Intelia Expert
Version 4.0 - IntÃ©gration du systÃ¨me de cache statistiques
ğŸš€ NOUVEAU: Support des endpoints de cache ultra-rapides
ğŸ”§ FIX: Support des endpoints /api/v1/auth/ (vrais endpoints du backend)
ğŸ”§ CORS FIX: Compatible avec credentials: 'include'
"""

from fastapi import HTTPException, Request
from fastapi.security import HTTPAuthorizationCredentials
from fastapi.responses import JSONResponse
import logging
from typing import Dict, Any, Optional

# Import de la fonction d'auth existante
from app.api.v1.auth import get_current_user, security

logger = logging.getLogger(__name__)

# ğŸ†• ENDPOINTS PUBLICS Ã‰TENDUS AVEC CACHE (pas d'auth requise)
PUBLIC_ENDPOINTS = {
    # === API ENDPOINTS PUBLICS ===
    "/api/ask-public",
    "/api/v1/ask-public", 
    "/api/v1/system-status", 
    "/api/v1/debug",
    "/api/rag/debug",
    "/api/rag/test",
    "/api/cors-test",
    "/api/",
    "/api/docs",
    "/api/redoc",
    "/api/openapi.json",
    "/api/v1/health",
    
    # === âœ… ENDPOINTS AUTH PUBLICS CORRIGES - VRAIS ENDPOINTS ===
    "/api/v1/auth/login",              # âœ… VRAI endpoint backend
    "/api/v1/auth/debug/jwt-config",   # âœ… VRAI endpoint backend
    "/api/v1/auth/test-direct",        # âœ… VRAI endpoint backend
    
    # === ğŸš€ NOUVEAU: ENDPOINTS CACHE PUBLICS (health check) ===
    "/api/v1/stats-fast/health",          # âœ… Health check du cache
    "/api/v1/stats/test",                  # âœ… Test du systÃ¨me cache (si montÃ©s dans main.py)
    
    # === AUTH TEMPORAIRE (auth-temp) ===
    "/api/auth-temp/login",            # âœ… Auth temp
    "/api/auth-temp/me",               # âœ… Auth temp
    "/api/auth-temp/test",             # âœ… Auth temp
    
    # === SYSTEM ENDPOINTS ===
    "/api/v1/system/health",           # âœ… System health
    "/api/v1/system/metrics",          # âœ… System metrics
    "/api/v1/system/status",           # âœ… System status
    "/api/deployment-debug",           # âœ… Deployment debug
    
    # === CONVERSATIONS PUBLIQUES ===
    "/api/v1/conversations/test-public",
    "/api/v1/conversations/test-public-post",
    
    # === ENDPOINTS SANS PREFIX /api (compatibilitÃ©) ===
    "/ask-public",
    "/v1/ask-public",
    "/system-status", 
    "/debug",
    "/rag/debug",
    "/rag/test",
    "/cors-test",
    "/",
    "/docs",
    "/redoc",
    "/openapi.json",
    "/health",
    "/metrics",                        # Monitoring
    "/admin/stats",                    # Stats admin publiques
    "/health/complete",                # Health check complet
    "/deployment-debug",               # Debug deployment
    
    # === ğŸš€ NOUVEAU: CACHE ENDPOINTS PUBLICS SANS PREFIX ===
    "/v1/stats-fast/health",              # âœ… Health check cache
    "/v1/stats/test",                     # âœ… Test cache
    "/admin/cache/status",                # âœ… Status cache (si public dans main.py)
    
    # === AUTH ENDPOINTS SANS PREFIX (compatibilitÃ©) ===
    "/v1/auth/login",                  # âœ… Version directe
    "/v1/auth/debug/jwt-config",       # âœ… Version directe
    "/v1/auth/test-direct",            # âœ… Version directe
    "/auth-temp/login",                # âœ… Auth temp sans /api
    "/auth-temp/me",                   # âœ… Auth temp sans /api
    "/auth-temp/test",                 # âœ… Auth temp sans /api
    
    # === CONVERSATIONS SANS PREFIX ===
    "/v1/conversations/test-public",
    "/v1/conversations/test-public-post"
}

# ğŸ”’ PATTERNS D'ENDPOINTS PROTÃ‰GÃ‰S Ã‰TENDUS (authentification requise)
PROTECTED_PATTERNS = [
    # === ENDPOINTS BUSINESS CORE ===
    "/api/v1/billing/",                # Facturation
    "/api/v1/logging/analytics/",      # Analytics
    "/api/v1/logging/questions",       # Questions (ancien endpoint)
    "/api/v1/conversations/",          # Conversations (sauf test-public)
    "/api/v1/expert/ask",              # Questions expert
    "/api/v1/admin/",                  # Administration
    "/api/v1/invitations/",            # Invitations
    
    # === ğŸš€ NOUVEAU: ENDPOINTS CACHE PROTÃ‰GÃ‰S (super admin) ===
    "/api/v1/stats-fast/",                # âœ… Endpoints ultra-rapides (admin+)
    "/api/v1/stats-admin/",               # âœ… Administration cache (super admin)
    "/api/v1/stats-fast/dashboard",       # âœ… Dashboard rapide
    "/api/v1/stats-fast/questions",      # âœ… Questions rapides
    "/api/v1/stats-fast/invitations/stats", # âœ… Invitations rapides
    "/api/v1/stats-fast/openai-costs/",  # âœ… CoÃ»ts OpenAI rapides
    "/api/v1/stats-fast/performance",    # âœ… Performance rapide
    "/api/v1/stats-fast/my-analytics",   # âœ… Analytics personnelles
    "/api/v1/stats-admin/force-update/", # âœ… Force update cache
    "/api/v1/stats-admin/cache/",        # âœ… ContrÃ´le cache
    "/api/v1/stats-admin/status",        # âœ… Status admin cache
    "/api/admin/cache/",                  # âœ… ContrÃ´le admin dans main.py
    
    # === âœ… ENDPOINTS AUTH PROTÃ‰GÃ‰S CORRIGES - VRAIS ENDPOINTS ===
    "/api/v1/auth/me",                 # âœ… Profil utilisateur (VRAI endpoint)
    "/api/v1/auth/delete-data",        # âœ… Suppression donnÃ©es RGPD (VRAI endpoint)
    
    # === AUTH TEMPORAIRE PROTÃ‰GÃ‰ ===
    "/api/auth-temp/me",               # âœ… Auth temp - profil
    
    # === PATTERNS SANS PREFIX (compatibilitÃ©) ===
    "/v1/billing/",
    "/v1/logging/analytics/",
    "/v1/logging/questions",           # Questions
    "/v1/conversations/",
    "/v1/expert/ask",
    "/v1/admin/",
    "/v1/invitations/",
    
    # === ğŸš€ NOUVEAU: CACHE SANS PREFIX ===
    "/v1/stats-fast/",                    # âœ… Endpoints cache rapides
    "/v1/stats-admin/",                   # âœ… Admin cache
    "/admin/cache/",                      # âœ… Admin cache direct
    
    "/v1/auth/me",                     # âœ… Sans /api
    "/v1/auth/delete-data",            # âœ… Sans /api
    "/auth-temp/me",                   # âœ… Auth temp sans /api
]

# âŒ PATTERNS D'ENDPOINTS INEXISTANTS (retourner 404 au lieu de 405)
NONEXISTENT_PATTERNS = [
    "/api/v1/analytics/",              # N'existe pas
    "/api/v1/user/",                   # N'existe pas
    "/api/v1/profile/",                # N'existe pas (utiliser /v1/auth/)
    "/api/v1/account/",                # N'existe pas (utiliser /v1/auth/)
    "/api/v1/users/",                  # N'existe pas (utiliser /v1/auth/)
    
    # âŒ ANCIENS ENDPOINTS CACHE INCORRECTS
    "/api/v1/stats/",                  # âŒ Ancien - maintenant /v1/stats-fast/ et /v1/stats-admin/
    "/api/v1/cache/",                  # âŒ N'existe pas - utiliser /v1/stats-admin/
    "/api/stats/",                     # âŒ Ancien pattern
    
    # âŒ ANCIENS ENDPOINTS AUTH INCORRECTS (n'existent plus)
    "/api/auth/login",                 # âŒ Ancien - maintenant /v1/auth/login
    "/api/auth/register",              # âŒ Ancien - n'existe pas
    "/api/auth/me",                    # âŒ Ancien - maintenant /v1/auth/me
    "/api/auth/debug/jwt-config",      # âŒ Ancien - maintenant /v1/auth/debug/jwt-config
    
    # Patterns sans prefix
    "/v1/analytics/",
    "/v1/user/",
    "/v1/profile/",
    "/v1/account/",
    "/v1/users/",
    "/v1/stats/",                      # âŒ Utiliser /v1/stats-fast/ ou /v1/stats-admin/
    "/v1/cache/",                      # âŒ Utiliser /v1/stats-admin/
    "/stats/",                         # âŒ Ancien
    "/cache/",                         # âŒ Ancien
    "/auth/login",                     # âŒ Ancien sans /api
    "/auth/register",                  # âŒ Ancien sans /api
    "/auth/me",                        # âŒ Ancien sans /api
    "/auth/debug/jwt-config",          # âŒ Ancien sans /api
]

# ğŸ†• PATTERNS PUBLICS Ã‰TENDUS AVEC CACHE (pour la fonction is_public_endpoint)
EXTENDED_PUBLIC_PATTERNS = [
    # === DOCUMENTATION ET MONITORING ===
    "/docs",
    "/redoc", 
    "/openapi.json",
    "/health",
    "/metrics",
    "/static/",
    
    # === âœ… AUTH PUBLICS CORRIGES - PATTERNS ===
    "/v1/auth/login",                  # âœ… Pattern login
    "/v1/auth/debug",                  # âœ… Pattern debug
    "/v1/auth/test-direct",            # âœ… Pattern test
    "/auth-temp/",                     # âœ… Pattern auth temporaire
    
    # === ğŸš€ NOUVEAU: PATTERNS CACHE PUBLICS ===
    "/v1/stats-fast/health",              # âœ… Health check cache
    "/v1/stats/test",                     # âœ… Test cache
    "/admin/cache/status",                # âœ… Status cache public (si configurÃ©)
    
    # === RAG ET TESTS ===
    "/rag/",
    "/cors-test",
    
    # === API PATTERNS ===
    "/api/docs",
    "/api/redoc",
    "/api/openapi.json", 
    "/api/v1/auth/login",              # âœ… Pattern login avec /api
    "/api/v1/auth/debug",              # âœ… Pattern debug avec /api
    "/api/v1/auth/test-direct",        # âœ… Pattern test avec /api
    "/api/auth-temp/",                 # âœ… Pattern auth temp avec /api
    
    # === ğŸš€ NOUVEAU: PATTERNS CACHE AVEC /API ===
    "/api/v1/stats-fast/health",          # âœ… Health cache
    "/api/v1/stats/test",                 # âœ… Test cache
    "/api/admin/cache/status",            # âœ… Status cache avec /api
    
    "/api/rag/",
    "/api/cors-test",
    "/api/v1/system",                  # âœ… Pattern system
    "/api/v1/debug",
    "/api/v1/ask-public",
    "/api/v1/conversations/test-public",
    "/api/ask-public",
    "/api/deployment-debug",
    
    # === PATTERNS SANS VERSION ===
    "/v1/conversations/test-public",
    "/v1/ask-public",
    "/ask-public",
    "/deployment-debug",
]

async def verify_supabase_token(request: Request) -> Dict[str, Any]:
    """
    Wrapper pour utiliser la logique d'auth existante dans api/v1/auth.py
    Maintient la compatibilitÃ© avec le systÃ¨me existant
    """
    try:
        # Extraire le token Authorization
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            logger.debug(f"ğŸ” Missing or invalid auth header for {request.url.path}")
            raise HTTPException(
                status_code=401, 
                detail="Missing or invalid authorization header"
            )
        
        # CrÃ©er l'objet credentials comme attendu par get_current_user
        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer",
            credentials=auth_header.replace("Bearer ", "")
        )
        
        # Utiliser la fonction existante (maintient la logique multi-secret)
        user_info = await get_current_user(credentials)
        
        logger.debug(f"âœ… Token verified for user: {user_info.get('email')}")
        return user_info
        
    except HTTPException:
        # Re-raise HTTPException as-is
        raise
    except Exception as e:
        logger.error(f"âŒ Token verification failed: {e}")
        raise HTTPException(
            status_code=401, 
            detail="Invalid or expired token"
        )

async def optional_auth(request: Request) -> Optional[Dict[str, Any]]:
    """
    Authentification optionnelle - ne lÃ¨ve pas d'erreur si pas de token
    Utile pour les endpoints qui peuvent fonctionner avec ou sans auth
    """
    try:
        return await verify_supabase_token(request)
    except HTTPException:
        logger.debug(f"ğŸ” Optional auth failed for {request.url.path} - continuing without auth")
        return None
    except Exception:
        return None

def is_public_endpoint(path: str) -> bool:
    """
    VÃ©rifie si un endpoint est public (pas d'authentification requise)
    
    Args:
        path: Chemin de l'endpoint Ã  vÃ©rifier
        
    Returns:
        bool: True si l'endpoint est public
    """
    # VÃ©rification exacte d'abord
    if path in PUBLIC_ENDPOINTS:
        logger.debug(f"âœ… Exact public endpoint match: {path}")
        return True
    
    # Puis vÃ©rification par patterns
    for pattern in EXTENDED_PUBLIC_PATTERNS:
        if path.startswith(pattern):
            logger.debug(f"âœ… Public pattern match: {path} -> {pattern}")
            return True
    
    logger.debug(f"ğŸ”’ Not a public endpoint: {path}")
    return False

def is_protected_endpoint(path: str) -> bool:
    """
    VÃ©rifie si un endpoint nÃ©cessite une authentification
    
    Args:
        path: Chemin de l'endpoint Ã  vÃ©rifier
        
    Returns:
        bool: True si l'endpoint nÃ©cessite une authentification
    """
    for pattern in PROTECTED_PATTERNS:
        if path.startswith(pattern):
            logger.debug(f"ğŸ”’ Protected pattern match: {path} -> {pattern}")
            return True
    
    logger.debug(f"ğŸ“„ Not a protected endpoint: {path}")
    return False

def is_nonexistent_endpoint(path: str) -> bool:
    """
    VÃ©rifie si c'est un endpoint qui n'existe pas (pour retourner 404)
    Ã‰vite les erreurs 405 Method Not Allowed pour des endpoints inexistants
    
    Args:
        path: Chemin de l'endpoint Ã  vÃ©rifier
        
    Returns:
        bool: True si l'endpoint n'existe pas
    """
    for pattern in NONEXISTENT_PATTERNS:
        if path.startswith(pattern):
            logger.debug(f"âŒ Nonexistent pattern match: {path} -> {pattern}")
            return True
    
    return False

def create_cors_headers(origin: str = None) -> Dict[str, str]:
    """
    ğŸ”§ CORS CORRIGÃ‰ - Compatible avec credentials: 'include'
    CrÃ©e les headers CORS standard pour les rÃ©ponses
    
    Args:
        origin: Origin de la requÃªte (pour Ã©viter le wildcard avec credentials)
        
    Returns:
        Dict: Headers CORS complets
    """
    # Liste des origins autorisÃ©s
    allowed_origins = [
        "https://expert.intelia.com",
        "https://expert-app-cngws.ondigitalocean.app", 
        "http://localhost:3000",
        "http://localhost:8080"
    ]
    
    # DÃ©terminer l'origin Ã  utiliser
    cors_origin = "*"  # Par dÃ©faut
    cors_credentials = "false"  # Par dÃ©faut
    
    if origin and origin in allowed_origins:
        cors_origin = origin  # Origin spÃ©cifique pour credentials
        cors_credentials = "true"  # Credentials autorisÃ©es pour origins spÃ©cifiques
    
    return {
        "Access-Control-Allow-Origin": cors_origin,
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS, PATCH",
        "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Session-ID, Accept, Origin, User-Agent",
        "Access-Control-Allow-Credentials": cors_credentials,
    }

# ğŸš€ NOUVEAU: Fonction pour vÃ©rifier les permissions cache
def has_cache_admin_permission(user_info: Dict[str, Any]) -> bool:
    """
    VÃ©rifie si l'utilisateur a les permissions pour les endpoints d'administration cache
    
    Args:
        user_info: Informations utilisateur depuis le token
        
    Returns:
        bool: True si l'utilisateur peut accÃ©der aux endpoints admin cache
    """
    user_type = user_info.get("user_type", "user")
    is_admin = user_info.get("is_admin", False)
    
    # Super admin ou admin avec flag explicite
    return user_type in ["super_admin", "admin"] or is_admin

def has_cache_view_permission(user_info: Dict[str, Any]) -> bool:
    """
    VÃ©rifie si l'utilisateur peut voir les statistiques en cache
    
    Args:
        user_info: Informations utilisateur depuis le token
        
    Returns:
        bool: True si l'utilisateur peut voir les stats
    """
    user_type = user_info.get("user_type", "user")
    
    # Admin+ ou utilisateur avec permissions analytics
    return user_type in ["super_admin", "admin", "moderator"]

async def auth_middleware(request: Request, call_next):
    """
    Middleware d'authentification globale pour l'API Intelia Expert - VERSION 4.0 AVEC CACHE
    
    Logique:
    1. GÃ¨re les endpoints inexistants (404)
    2. Skip l'auth pour les endpoints publics et OPTIONS
    3. VÃ©rifie l'auth pour les endpoints protÃ©gÃ©s
    4. ğŸš€ NOUVEAU: Gestion spÃ©ciale pour les endpoints de cache
    5. Laisse passer les autres endpoints (FastAPI gÃ¨re les 404)
    
    Args:
        request: Request FastAPI
        call_next: Fonction suivante dans la chaÃ®ne
        
    Returns:
        Response: RÃ©ponse HTTP appropriÃ©e
    """
    
    # ğŸ“Š LOG DE DEBUG DÃ‰TAILLÃ‰
    logger.debug(
        f"ğŸ” Auth middleware - Method: {request.method}, "
        f"Path: {request.url.path}, "
        f"Auth Header: {'Present' if request.headers.get('Authorization') else 'Missing'}, "
        f"Origin: {request.headers.get('Origin', 'None')}"
    )
    
    # RÃ©cupÃ©rer l'origin de la requÃªte pour CORS
    request_origin = request.headers.get("Origin")
    
    # ğŸš¨ Ã‰TAPE 1: GÃ©rer les endpoints inexistants AVANT toute autre logique
    if is_nonexistent_endpoint(request.url.path):
        logger.warning(f"âŒ Endpoint inexistant dÃ©tectÃ©: {request.url.path}")
        
        # ğŸš€ NOUVEAU: Message spÃ©cial pour les anciens endpoints cache
        suggestion = "VÃ©rifiez l'URL ou consultez /docs pour les endpoints disponibles"
        if "/stats/" in request.url.path and "/stats-fast/" not in request.url.path:
            suggestion = "Les endpoints stats sont maintenant sur /v1/stats-fast/ (ultra-rapides) et /v1/stats-admin/ (administration)"
        elif "/cache/" in request.url.path:
            suggestion = "Les endpoints cache sont sur /v1/stats-admin/ pour l'administration"
        elif "/auth/" in request.url.path and "/v1/auth/" not in request.url.path:
            suggestion = "Les endpoints auth sont maintenant sur /v1/auth/ et non /auth/"
        
        return JSONResponse(
            status_code=404,
            content={
                "detail": "Not Found", 
                "error": "endpoint_not_found",
                "path": request.url.path,
                "suggestion": suggestion,
                "available_cache_endpoints": [
                    "/v1/stats-fast/dashboard (ultra-rapide)",
                    "/v1/stats-fast/questions (ultra-rapide)", 
                    "/v1/stats-admin/status (administration)",
                    "/v1/stats-admin/force-update/all (force mise Ã  jour)"
                ] if "/stats/" in request.url.path or "/cache/" in request.url.path else None
            },
            headers=create_cors_headers(request_origin)
        )
    
    # âœ… Ã‰TAPE 2: Skip l'auth pour les endpoints publics et requÃªtes OPTIONS
    if is_public_endpoint(request.url.path) or request.method == "OPTIONS":
        logger.debug(f"âœ… Public endpoint ou OPTIONS - Skip auth: {request.url.path}")
        
        # Pour OPTIONS, retourner directement les headers CORS
        if request.method == "OPTIONS":
            return JSONResponse(
                status_code=200,
                content={"message": "OK"},
                headers=create_cors_headers(request_origin)
            )
        
        # Pour les endpoints publics, continuer sans auth
        response = await call_next(request)
        
        # Ajouter les headers CORS aux rÃ©ponses publiques
        for key, value in create_cors_headers(request_origin).items():
            response.headers[key] = value
            
        return response
    
    # ğŸ”’ Ã‰TAPE 3: VÃ©rifier l'auth pour les endpoints protÃ©gÃ©s
    if is_protected_endpoint(request.url.path):
        try:
            logger.debug(f"ğŸ”’ Protected endpoint detected: {request.url.path}")
            
            # VÃ©rifier le token d'authentification
            user_info = await verify_supabase_token(request)
            
            # ğŸš€ NOUVEAU: VÃ©rification spÃ©ciale pour les endpoints cache admin
            if "/stats-admin/" in request.url.path or "/admin/cache/" in request.url.path:
                if not has_cache_admin_permission(user_info):
                    logger.warning(f"ğŸ”’ Cache admin permission denied for {user_info.get('email')} on {request.url.path}")
                    return JSONResponse(
                        status_code=403,
                        content={
                            "detail": "Cache administration requires super_admin permissions",
                            "error": "insufficient_permissions",
                            "required_permission": "super_admin",
                            "user_type": user_info.get("user_type"),
                            "path": request.url.path
                        },
                        headers=create_cors_headers(request_origin)
                    )
            
            # ğŸš€ NOUVEAU: VÃ©rification pour les endpoints stats-fast
            elif "/stats-fast/" in request.url.path:
                if not has_cache_view_permission(user_info):
                    logger.warning(f"ğŸ”’ Cache view permission denied for {user_info.get('email')} on {request.url.path}")
                    return JSONResponse(
                        status_code=403,
                        content={
                            "detail": "Statistics access requires admin+ permissions",
                            "error": "insufficient_permissions", 
                            "required_permission": "admin",
                            "user_type": user_info.get("user_type"),
                            "path": request.url.path
                        },
                        headers=create_cors_headers(request_origin)
                    )
            
            # Ajouter les infos utilisateur Ã  la request pour les endpoints suivants
            request.state.user = user_info
            
            logger.info(
                f"âœ… User authenticated: {user_info.get('email')} "
                f"(type: {user_info.get('user_type')}) "
                f"for {request.url.path}"
            )
            
            # Continuer vers l'endpoint
            response = await call_next(request)
            
            # Ajouter les headers CORS aux rÃ©ponses protÃ©gÃ©es
            for key, value in create_cors_headers(request_origin).items():
                response.headers[key] = value
                
            return response
            
        except HTTPException as e:
            logger.warning(
                f"ğŸ”’ Auth failed for {request.url.path}: "
                f"Status {e.status_code} - {e.detail}"
            )
            return JSONResponse(
                status_code=e.status_code,
                content={
                    "detail": e.detail, 
                    "error": "authentication_failed",
                    "path": request.url.path
                },
                headers=create_cors_headers(request_origin)
            )
            
        except Exception as e:
            logger.error(f"âŒ Auth middleware unexpected error for {request.url.path}: {e}")
            return JSONResponse(
                status_code=401,
                content={
                    "detail": "Authentication failed", 
                    "error": "internal_auth_error",
                    "path": request.url.path
                },
                headers=create_cors_headers(request_origin)
            )
    
    # ğŸ“„ Ã‰TAPE 4: Pour tous les autres endpoints (non protÃ©gÃ©s, non publics)
    # Laisser passer - FastAPI gÃ©rera naturellement les 404 pour les routes inexistantes
    logger.debug(f"ğŸ“„ Endpoint non-protÃ©gÃ© - Passage libre: {request.url.path}")
    
    # Ajouter une authentification optionnelle pour ces endpoints
    try:
        user_info = await optional_auth(request)
        if user_info:
            request.state.user = user_info
            logger.debug(f"ğŸ” Optional auth successful for {request.url.path}")
    except Exception:
        # Ignorer les erreurs d'auth optionnelle
        pass
    
    response = await call_next(request)
    
    # Ajouter les headers CORS Ã  toutes les rÃ©ponses
    for key, value in create_cors_headers(request_origin).items():
        response.headers[key] = value
        
    return response

# ğŸ†• FONCTION UTILITAIRE POUR LES ENDPOINTS
def get_authenticated_user(request: Request) -> Dict[str, Any]:
    """
    RÃ©cupÃ¨re l'utilisateur authentifiÃ© depuis request.state
    Ã€ utiliser dans les endpoints qui nÃ©cessitent une authentification
    
    Args:
        request: Request FastAPI
        
    Returns:
        Dict: Informations utilisateur
        
    Raises:
        HTTPException: Si pas d'utilisateur authentifiÃ©
    """
    if not hasattr(request.state, 'user') or not request.state.user:
        raise HTTPException(
            status_code=401,
            detail="Authentication required"
        )
    
    return request.state.user

def get_optional_user(request: Request) -> Optional[Dict[str, Any]]:
    """
    RÃ©cupÃ¨re l'utilisateur authentifiÃ© si disponible, sinon None
    Ã€ utiliser dans les endpoints avec authentification optionnelle
    
    Args:
        request: Request FastAPI
        
    Returns:
        Optional[Dict]: Informations utilisateur ou None
    """
    return getattr(request.state, 'user', None)

# ğŸ”§ FONCTION DE DEBUG MISE Ã€ JOUR
def debug_middleware_config() -> Dict[str, Any]:
    """
    Retourne la configuration actuelle du middleware pour debug
    
    Returns:
        Dict: Configuration du middleware
    """
    return {
        "public_endpoints_count": len(PUBLIC_ENDPOINTS),
        "protected_patterns_count": len(PROTECTED_PATTERNS),
        "nonexistent_patterns_count": len(NONEXISTENT_PATTERNS),
        "extended_public_patterns_count": len(EXTENDED_PUBLIC_PATTERNS),
        "sample_public_endpoints": list(PUBLIC_ENDPOINTS)[:15],  # Plus d'exemples
        "sample_protected_patterns": PROTECTED_PATTERNS[:15],    # Plus d'exemples
        "cache_endpoints": {
            "stats_fast_public": [
                "/api/v1/stats-fast/health",
                "/v1/stats-fast/health"
            ],
            "stats_fast_protected": [
                "/api/v1/stats-fast/dashboard",
                "/api/v1/stats-fast/questions", 
                "/api/v1/stats-fast/invitations/stats",
                "/api/v1/stats-fast/openai-costs/",
                "/api/v1/stats-fast/performance"
            ],
            "stats_admin_protected": [
                "/api/v1/stats-admin/",
                "/api/v1/stats-admin/force-update/",
                "/api/v1/stats-admin/cache/",
                "/api/v1/stats-admin/status"
            ]
        },
        "auth_endpoints_corrected": [
            "/api/v1/auth/login",                    # âœ… NOUVEAU - VRAI endpoint
            "/api/v1/auth/debug/jwt-config",         # âœ… NOUVEAU - VRAI endpoint
            "/api/v1/auth/me",                       # âœ… NOUVEAU - VRAI endpoint
            "/api/v1/auth/delete-data",              # âœ… NOUVEAU - VRAI endpoint
        ],
        "auth_endpoints_removed": [
            "/api/auth/login",                       # âŒ SUPPRIMÃ‰ - ancien
            "/api/auth/register",                    # âŒ SUPPRIMÃ‰ - ancien
            "/api/auth/debug/jwt-config",            # âŒ SUPPRIMÃ‰ - ancien
        ],
        "cache_endpoints_removed": [
            "/api/v1/stats/",                        # âŒ SUPPRIMÃ‰ - utiliser /stats-fast/ et /stats-admin/
            "/api/v1/cache/",                        # âŒ SUPPRIMÃ‰ - utiliser /stats-admin/
        ],
        "cors_fixes": {
            "wildcard_removed": True,
            "credentials_support": True,
            "origin_specific": True,
            "compatible_with_include": True
        },
        "middleware_version": "4.0-with-stats-cache",  # ğŸš€ UPDATED
        "key_changes": [
            "âœ… Fixed: Added /api/v1/auth/* as public endpoints",
            "âŒ Removed: Old /api/auth/* endpoints marked as nonexistent", 
            "âœ… Added: Support for auth-temp endpoints",
            "ğŸ”§ FIXED: CORS handling compatible with credentials: 'include'",
            "âœ… Fixed: System endpoints support",
            "ğŸ”§ Updated: All patterns align with Swagger docs",
            "ğŸ”§ NEW: Origin-specific CORS headers for credentials support",
            "ğŸš€ NEW: Support for /v1/stats-fast/* endpoints (ultra-fast cache)",
            "ğŸš€ NEW: Support for /v1/stats-admin/* endpoints (cache administration)",
            "ğŸš€ NEW: Permission checking for cache admin endpoints", 
            "ğŸš€ NEW: Cache-specific error messages and suggestions",
            "âŒ Deprecated: /api/v1/stats/* patterns (use /stats-fast/ or /stats-admin/)"
        ]
    }