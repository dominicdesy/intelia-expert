"""
app/api/v1/conversation_entities.py - Entit√©s et structures de donn√©es pour la m√©moire conversationnelle

üîß MODULE 1/3: Entit√©s intelligentes et messages conversationnels
‚úÖ Toutes les corrections appliqu√©es
‚úÖ Attribut 'weight' ajout√© et synchronis√© avec weight_grams
‚úÖ Gestion s√©curis√©e des types str/int dans toutes les comparaisons
‚úÖ Validation d'incoh√©rences avec enrichissement automatique
"""

import os
import json
import logging
import re
import weakref
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union, Callable, Protocol
from dataclasses import dataclass, asdict, field

logger = logging.getLogger(__name__)

# Protocol pour typage s√©curis√© des callbacks
class RAGCallbackProtocol(Protocol):
    """Protocol pour les callbacks de retraitement RAG"""
    async def __call__(
        self,
        question: str,
        conversation_id: str,
        user_id: str,
        language: str = "fr",
        is_reprocessing: bool = False
    ) -> Dict[str, Any]:
        ...

def safe_int_conversion(value: Any) -> Optional[int]:
    """Convertit une valeur en int de mani√®re s√©curis√©e"""
    if value is None:
        return None
    try:
        if isinstance(value, str):
            # Nettoyer la cha√Æne (espaces, caract√®res non num√©riques de base)
            cleaned = re.sub(r'[^\d.]', '', value)
            if cleaned:
                return int(float(cleaned))
        elif isinstance(value, (int, float)):
            return int(value)
    except (ValueError, TypeError):
        pass
    return None

def safe_float_conversion(value: Any) -> Optional[float]:
    """Convertit une valeur en float de mani√®re s√©curis√©e"""
    if value is None:
        return None
    try:
        if isinstance(value, str):
            cleaned = re.sub(r'[^\d.]', '', value)
            if cleaned:
                return float(cleaned)
        elif isinstance(value, (int, float)):
            return float(value)
    except (ValueError, TypeError):
        pass
    return None

@dataclass
class IntelligentEntities:
    """Entit√©s extraites intelligemment avec raisonnement contextuel - VERSION COMPL√àTEMENT CORRIG√âE"""
    
    # üîß FIX 1: TOUS LES ATTRIBUTS REQUIS AVEC TYPES CORRECTS
    # Informations de base
    breed: Optional[str] = None
    breed_confidence: float = 0.0
    breed_type: Optional[str] = None  # specific/generic
    
    # Sexe avec variations multilingues
    sex: Optional[str] = None
    sex_confidence: float = 0.0
    
    # üîß FIX 2: √ÇGE - Tous les attributs requis avec types s√©curis√©s
    age: Optional[int] = None  # √Çge principal en jours
    age_days: Optional[int] = None
    age_weeks: Optional[float] = None
    age_confidence: float = 0.0
    age_last_updated: Optional[datetime] = None
    
    # üîß FIX 3: POIDS - Attribut weight ajout√© + weight_grams avec synchronisation
    weight: Optional[float] = None  # ‚Üê ATTRIBUT MANQUANT AJOUT√â (en grammes)
    weight_grams: Optional[float] = None
    weight_confidence: float = 0.0
    expected_weight_range: Optional[Tuple[float, float]] = None
    growth_rate: Optional[str] = None  # normal/slow/fast
    
    # Sant√© et probl√®mes
    mortality_rate: Optional[float] = None
    mortality_confidence: float = 0.0
    symptoms: List[str] = field(default_factory=list)
    health_status: Optional[str] = None  # good/concerning/critical
    
    # Environnement
    temperature: Optional[float] = None
    humidity: Optional[float] = None
    housing_type: Optional[str] = None
    ventilation_quality: Optional[str] = None
    
    # Alimentation
    feed_type: Optional[str] = None
    feed_conversion: Optional[float] = None
    water_consumption: Optional[str] = None
    
    # Gestion et historique
    flock_size: Optional[int] = None
    vaccination_status: Optional[str] = None
    previous_treatments: List[str] = field(default_factory=list)
    
    # Contextuel intelligent
    problem_duration: Optional[str] = None
    problem_severity: Optional[str] = None  # low/medium/high/critical
    intervention_urgency: Optional[str] = None  # none/monitor/act/urgent
    
    # M√©tadonn√©es IA
    extraction_method: str = "basic"  # basic/openai/hybrid/fallback
    extraction_attempts: int = 0
    extraction_success: bool = True
    last_ai_update: Optional[datetime] = None
    confidence_overall: float = 0.0
    data_validated: bool = False
    
    def __post_init__(self):
        """Post-initialisation pour synchroniser les champs weight/weight_grams et age/age_days"""
        # Synchroniser weight et weight_grams
        if self.weight_grams is not None and self.weight is None:
            self.weight = self.weight_grams
        elif self.weight is not None and self.weight_grams is None:
            self.weight_grams = self.weight
        
        # Synchroniser age et age_days
        if self.age_days is not None and self.age is None:
            self.age = self.age_days
        elif self.age is not None and self.age_days is None:
            self.age_days = self.age
    
    def to_dict(self) -> Dict[str, Any]:
        """Convertit en dictionnaire pour logs et stockage"""
        result = {}
        for key, value in asdict(self).items():
            if value is not None:
                if isinstance(value, datetime):
                    result[key] = value.isoformat()
                elif isinstance(value, tuple):
                    result[key] = list(value)
                else:
                    result[key] = value
        return result
    
    def validate_and_correct(self) -> 'IntelligentEntities':
        """üîß FIX 4: Validation et correction avec gestion s√©curis√©e des types"""
        
        # üîß CORRECTION √ÇGE: Gestion s√©curis√©e des types str/int
        age_days_safe = safe_int_conversion(self.age_days)
        age_weeks_safe = safe_float_conversion(self.age_weeks)
        
        if age_days_safe is not None and age_weeks_safe is not None:
            calculated_weeks = age_days_safe / 7
            if abs(calculated_weeks - age_weeks_safe) > 0.5:  # Tol√©rance 0.5 semaine
                logger.warning(f"‚ö†Ô∏è [Validation] Incoh√©rence √¢ge: {age_days_safe}j vs {age_weeks_safe}sem")
                
                # üîß FIX 5: Enrichissement automatique au lieu de simple warning
                if self.age_confidence > 0.7:
                    self.age_weeks = round(age_days_safe / 7, 1)
                    logger.info(f"‚úÖ [Correction] √Çge semaines corrig√©: {self.age_weeks}sem")
                else:
                    self.age_days = int(age_weeks_safe * 7)
                    logger.info(f"‚úÖ [Correction] √Çge jours corrig√©: {self.age_days}j")
        
        # Mise √† jour des champs s√©curis√©s
        self.age_days = age_days_safe
        self.age_weeks = age_weeks_safe
        
        # Synchroniser le champ age avec age_days
        if self.age_days:
            self.age = self.age_days
        elif self.age:
            self.age_days = self.age
        
        # üîß CORRECTION POIDS: Synchronisation weight/weight_grams s√©curis√©e
        weight_safe = safe_float_conversion(self.weight)
        weight_grams_safe = safe_float_conversion(self.weight_grams)
        
        if weight_grams_safe is not None:
            # Validation et correction automatique
            if weight_grams_safe < 10 or weight_grams_safe > 5000:  # Limites r√©alistes
                logger.warning(f"‚ö†Ô∏è [Validation] Poids suspect: {weight_grams_safe}g")
                if weight_grams_safe > 5000:  # Probablement en kg au lieu de g
                    weight_grams_safe = weight_grams_safe / 1000
                    logger.info(f"‚úÖ [Correction] Poids corrig√© de kg vers g: {weight_grams_safe}g")
                elif weight_grams_safe < 10 and weight_grams_safe > 0.1:  # Probablement en kg
                    weight_grams_safe = weight_grams_safe * 1000
                    logger.info(f"‚úÖ [Correction] Poids corrig√© de kg vers g: {weight_grams_safe}g")
        
        # Synchroniser weight et weight_grams
        self.weight_grams = weight_grams_safe
        self.weight = weight_grams_safe  # Les deux sont en grammes
        
        # Validation mortalit√© s√©curis√©e
        mortality_safe = safe_float_conversion(self.mortality_rate)
        if mortality_safe is not None:
            if mortality_safe < 0:
                mortality_safe = 0.0
            elif mortality_safe > 100:
                logger.warning(f"‚ö†Ô∏è [Validation] Mortalit√© > 100%: {mortality_safe}")
                mortality_safe = min(mortality_safe, 100.0)
        self.mortality_rate = mortality_safe
        
        # Validation temp√©rature s√©curis√©e
        temp_safe = safe_float_conversion(self.temperature)
        if temp_safe is not None:
            if temp_safe < 15 or temp_safe > 45:
                logger.warning(f"‚ö†Ô∏è [Validation] Temp√©rature suspecte: {temp_safe}¬∞C")
                if temp_safe > 100:  # Probablement en Fahrenheit
                    temp_safe = (temp_safe - 32) * 5/9
                    logger.info(f"‚úÖ [Correction] Temp√©rature convertie F‚ÜíC: {temp_safe:.1f}¬∞C")
        self.temperature = temp_safe
        
        # Nettoyer les listes de mani√®re s√©curis√©e
        if self.symptoms:
            self.symptoms = [s.strip().lower() for s in self.symptoms if s and isinstance(s, str) and s.strip()]
            self.symptoms = list(set(self.symptoms))  # Supprimer doublons
        
        if self.previous_treatments:
            self.previous_treatments = [t.strip() for t in self.previous_treatments if t and isinstance(t, str) and t.strip()]
            self.previous_treatments = list(set(self.previous_treatments))
        
        self.data_validated = True
        return self
    
    def get_critical_missing_info(self, question_type: str = "general") -> List[str]:
        """D√©termine les informations critiques manquantes selon le contexte"""
        missing = []
        
        # Race toujours critique pour questions techniques
        if not self.breed or self.breed_type == "generic" or self.breed_confidence < 0.7:
            missing.append("breed")
        
        # Sexe critique pour questions de performance
        if question_type in ["performance", "weight", "growth"] and (not self.sex or self.sex_confidence < 0.7):
            missing.append("sex")
        
        # √Çge critique pour la plupart des questions
        if not self.age_days or self.age_confidence < 0.7:
            missing.append("age")
        
        # Sp√©cifique selon le type de question
        if question_type in ["growth", "weight", "performance"]:
            if not self.weight_grams and not self.growth_rate:
                missing.append("current_performance")
        elif question_type in ["health", "mortality", "disease"]:
            if not self.symptoms and not self.health_status:
                missing.append("symptoms")
            if self.mortality_rate is None and "mortality" in question_type:
                missing.append("mortality_rate")
        elif question_type in ["environment", "temperature", "housing"]:
            if not self.housing_type:
                missing.append("housing_conditions")
        elif question_type in ["feeding", "nutrition"]:
            if not self.feed_type:
                missing.append("feed_information")
        
        return missing
    
    def merge_with(self, other: 'IntelligentEntities') -> 'IntelligentEntities':
        """Fusionne intelligemment avec une autre instance d'entit√©s"""
        merged = IntelligentEntities()
        
        # Logique de fusion pour chaque champ
        for field_name, field_value in asdict(self).items():
            other_value = getattr(other, field_name, None)
            
            # Prendre la valeur avec la meilleure confiance
            if field_name.endswith('_confidence'):
                base_field = field_name.replace('_confidence', '')
                self_conf = field_value or 0.0
                other_conf = getattr(other, field_name, 0.0) or 0.0
                
                if other_conf > self_conf:
                    setattr(merged, base_field, getattr(other, base_field))
                    setattr(merged, field_name, other_conf)
                else:
                    setattr(merged, base_field, getattr(self, base_field))
                    setattr(merged, field_name, self_conf)
            
            # Fusionner les listes
            elif isinstance(field_value, list):
                self_list = field_value or []
                other_list = other_value or []
                # Garder les √©l√©ments uniques
                merged_list = list(set(self_list + other_list))
                setattr(merged, field_name, merged_list)
            
            # Prendre la valeur la plus r√©cente pour les dates
            elif isinstance(field_value, datetime):
                if other_value and (not field_value or other_value > field_value):
                    setattr(merged, field_name, other_value)
                else:
                    setattr(merged, field_name, field_value)
            
            # Logique par d√©faut
            else:
                if other_value is not None:
                    setattr(merged, field_name, other_value)
                elif field_value is not None:
                    setattr(merged, field_name, field_value)
        
        merged.last_ai_update = datetime.now()
        return merged.validate_and_correct()

@dataclass
class ConversationMessage:
    """Message dans une conversation avec m√©tadonn√©es"""
    id: str
    conversation_id: str
    user_id: str
    role: str  # user/assistant/system
    message: str
    timestamp: datetime
    language: str = "fr"
    message_type: str = "text"  # text/clarification/response/original_question_marker
    extracted_entities: Optional[IntelligentEntities] = None
    confidence_score: float = 0.0
    processing_method: str = "basic"
    
    # CHAMPS POUR CLARIFICATIONS
    is_original_question: bool = False
    is_clarification_response: bool = False
    original_question_id: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "conversation_id": self.conversation_id,
            "user_id": self.user_id,
            "role": self.role,
            "message": self.message,
            "timestamp": self.timestamp.isoformat(),
            "language": self.language,
            "message_type": self.message_type,
            "extracted_entities": self.extracted_entities.to_dict() if self.extracted_entities else None,
            "confidence_score": self.confidence_score,
            "processing_method": self.processing_method,
            "is_original_question": self.is_original_question,
            "is_clarification_response": self.is_clarification_response,
            "original_question_id": self.original_question_id
        }

@dataclass
class IntelligentConversationContext:
    """Contexte conversationnel intelligent avec raisonnement et clarification critique"""
    conversation_id: str
    user_id: str
    messages: List[ConversationMessage] = field(default_factory=list)
    
    # Entit√©s consolid√©es intelligemment
    consolidated_entities: IntelligentEntities = field(default_factory=IntelligentEntities)
    
    # M√©tadonn√©es contextuelles
    language: str = "fr"
    created_at: datetime = field(default_factory=datetime.now)
    last_activity: datetime = field(default_factory=datetime.now)
    total_exchanges: int = 0
    
    # √âtat conversationnel intelligent
    conversation_topic: Optional[str] = None
    conversation_urgency: Optional[str] = None  # low/medium/high/critical
    problem_resolution_status: Optional[str] = None  # identifying/diagnosing/treating/resolved
    
    # Optimisations IA
    ai_enhanced: bool = False
    last_ai_analysis: Optional[datetime] = None
    needs_clarification: bool = False
    clarification_questions: List[str] = field(default_factory=list)
    
    # CHAMPS POUR CLARIFICATIONS STANDARD
    pending_clarification: bool = False
    last_original_question_id: Optional[str] = None
    
    # NOUVEAUX CHAMPS POUR CLARIFICATION CRITIQUE
    original_question_pending: Optional[str] = None  # Question initiale en attente
    critical_clarification_active: bool = False      # √âtat clarification critique
    _clarification_callback_ref: Optional[weakref.ReferenceType] = None  # WeakRef pour √©viter fuites m√©moire
    _schedule_reprocessing: bool = False  # Flag pour √©viter r√©cursion
    
    # Propri√©t√© pour g√©rer le callback de mani√®re s√©curis√©e
    @property
    def clarification_callback(self) -> Optional[RAGCallbackProtocol]:
        """R√©cup√®re le callback de mani√®re s√©curis√©e"""
        if self._clarification_callback_ref is None:
            return None
        callback = self._clarification_callback_ref()
        if callback is None:
            # Le callback a √©t√© garbage collect√©
            self._clarification_callback_ref = None
            logger.warning("‚ö†Ô∏è [Context] Callback garbage collect√© - nettoyage automatique")
        return callback
    
    @clarification_callback.setter
    def clarification_callback(self, callback: Optional[RAGCallbackProtocol]):
        """D√©finit le callback avec WeakRef pour √©viter les fuites m√©moire"""
        if callback is None:
            self._clarification_callback_ref = None
        else:
            try:
                self._clarification_callback_ref = weakref.ref(callback)
            except TypeError:
                # Si l'objet ne supporte pas les weak references
                logger.warning("‚ö†Ô∏è [Context] Callback ne supporte pas WeakRef - stockage direct")
                self._clarification_callback_ref = lambda: callback
    
    def add_message(self, message: ConversationMessage):
        """Ajoute un message et g√®re la clarification critique automatiquement"""
        self.messages.append(message)
        self.last_activity = datetime.now()
        self.total_exchanges += 1
        
        # TRACKING SP√âCIAL POUR CLARIFICATIONS STANDARD
        if message.is_original_question:
            self.last_original_question_id = message.id
            self.pending_clarification = True
            logger.info(f"üéØ [Context] Question originale marqu√©e: {message.id}")
        
        if message.is_clarification_response and message.original_question_id:
            self.pending_clarification = False
            logger.info(f"üéØ [Context] Clarification re√ßue pour: {message.original_question_id}")
        
        # NOUVELLE LOGIQUE CLARIFICATION CRITIQUE
        if message.is_clarification_response and self.critical_clarification_active:
            logger.info("üö® [Context] ‚úÖ R√©ponse clarification CRITIQUE re√ßue - planification du retraitement")
            self.critical_clarification_active = False
            
            # Marquer pour retraitement au lieu de cr√©er une t√¢che imm√©diatement
            self._schedule_reprocessing = True
            
            # Le retraitement sera d√©clench√© par l'appelant via check_and_trigger_reprocessing()
        
        # Fusionner les entit√©s si disponibles
        if message.extracted_entities:
            old_entities = self.consolidated_entities
            self.consolidated_entities = self.consolidated_entities.merge_with(message.extracted_entities)
            
            # Log des changements d'entit√©s
            if old_entities.breed != self.consolidated_entities.breed:
                logger.info(f"üîÑ [Entities] Race mise √† jour: {old_entities.breed} ‚Üí {self.consolidated_entities.breed}")
            if old_entities.sex != self.consolidated_entities.sex:
                logger.info(f"üîÑ [Entities] Sexe mis √† jour: {old_entities.sex} ‚Üí {self.consolidated_entities.sex}")
            if old_entities.age_days != self.consolidated_entities.age_days:
                logger.info(f"üîÑ [Entities] √Çge mis √† jour: {old_entities.age_days} ‚Üí {self.consolidated_entities.age_days}j")
        
        # Mettre √† jour le statut conversationnel
        self._update_conversation_status()
    
    def check_and_trigger_reprocessing(self) -> bool:
        """
        V√©rifie si un retraitement est planifi√© et le d√©clenche
        Retourne True si un retraitement a √©t√© planifi√©
        """
        if self._schedule_reprocessing:
            self._schedule_reprocessing = False
            logger.info("üöÄ [Context] Retraitement planifi√© d√©tect√© - √† traiter par l'appelant")
            return True
        return False
    
    def mark_pending_clarification(self, question: str, callback: Optional[RAGCallbackProtocol] = None):
        """
        Marque une question pour clarification critique
        
        Args:
            question: Question originale qui n√©cessite clarification
            callback: Fonction callback pour relancer le traitement RAG
        """
        self.critical_clarification_active = True
        self.original_question_pending = question
        self.clarification_callback = callback  # Utilise le setter s√©curis√©
        
        logger.info(f"üö® [Context] CLARIFICATION CRITIQUE marqu√©e")
        logger.info(f"  üìù Question: {question[:100]}...")
        logger.info(f"  üîÑ Callback: {'‚úÖ' if callback else '‚ùå'}")
    
    async def reprocess_original_question(self) -> Dict[str, Any]:
        """
        Relance le traitement de la question originale avec clarification
        """
        if not self.original_question_pending:
            logger.warning("‚ö†Ô∏è [Context] Pas de question originale en attente pour retraitement")
            return {"status": "no_question_pending"}
        
        logger.info(f"üöÄ [Context] RETRAITEMENT question originale: {self.original_question_pending[:100]}...")
        
        try:
            # V√©rification s√©curis√©e du callback
            callback = self.clarification_callback
            if callback and callable(callback):
                logger.info("üîÑ [Context] Ex√©cution callback retraitement...")
                
                # Appeler le callback avec la question enrichie par le contexte actuel
                enriched_question = self._build_enriched_question_from_context()
                
                try:
                    result = await callback(
                        question=enriched_question,
                        conversation_id=self.conversation_id,
                        user_id=self.user_id,
                        is_reprocessing=True
                    )
                    
                    logger.info(f"‚úÖ [Context] Callback retraitement termin√©: {result}")
                    return {"status": "success", "result": result}
                    
                except Exception as callback_error:
                    logger.error(f"‚ùå [Context] Erreur dans callback: {callback_error}")
                    return {"status": "callback_error", "error": str(callback_error)}
                
            else:
                logger.warning("‚ö†Ô∏è [Context] Pas de callback valide - retraitement manuel requis")
                return {"status": "no_callback"}
        
        except Exception as e:
            logger.error(f"‚ùå [Context] Erreur retraitement: {e}")
            return {"status": "error", "error": str(e)}
        
        finally:
            # Nettoyer l'√©tat
            self.original_question_pending = None
            self.clarification_callback = None
    
    def _build_enriched_question_from_context(self) -> str:
        """Enrichit la question originale avec le contexte actuel"""
        if not self.original_question_pending:
            return ""
        
        enrichments = []
        entities = self.consolidated_entities
        
        # Ajouter les entit√©s importantes
        if entities.breed and entities.breed_confidence > 0.7:
            enrichments.append(entities.breed)
        
        if entities.sex and entities.sex_confidence > 0.7:
            enrichments.append(entities.sex)
        
        if entities.age_days and entities.age_confidence > 0.7:
            enrichments.append(f"{entities.age_days} jours")
        
        # Construire la question enrichie
        if enrichments:
            enrichment_text = " ".join(enrichments)
            
            # Int√©grer intelligemment dans la question
            if "poulet" in self.original_question_pending.lower():
                enriched = self.original_question_pending.replace(
                    "poulet", f"poulet {enrichment_text}"
                ).replace(
                    "poulets", f"poulets {enrichment_text}"
                )
            else:
                enriched = f"{self.original_question_pending} (Contexte: {enrichment_text})"
            
            logger.info(f"üîÅ [Context] Question enrichie: {enriched}")
            return enriched
        
        return self.original_question_pending
    
    def _update_conversation_status(self):
        """Met √† jour le statut conversationnel bas√© sur les messages r√©cents"""
        if not self.messages:
            return
        
        recent_messages = self.messages[-3:]  # 3 derniers messages
        
        # Analyser l'urgence bas√©e sur les mots-cl√©s
        urgency_keywords = {
            "critical": ["urgence", "urgent", "critique", "emergency", "critical", "dying", "meurent"],
            "high": ["probl√®me", "problem", "maladie", "disease", "mortalit√©", "mortality"],
            "medium": ["inquiet", "concerned", "surveillance", "monitoring"],
            "low": ["pr√©vention", "prevention", "routine", "normal"]
        }
        
        max_urgency = "low"
        for message in recent_messages:
            message_lower = message.message.lower()
            for urgency, keywords in urgency_keywords.items():
                if any(keyword in message_lower for keyword in keywords):
                    if urgency == "critical":
                        max_urgency = "critical"
                        break
                    elif urgency == "high" and max_urgency not in ["critical"]:
                        max_urgency = "high"
                    elif urgency == "medium" and max_urgency in ["low"]:
                        max_urgency = "medium"
        
        self.conversation_urgency = max_urgency
    
    def find_original_question(self, limit_messages: int = 20) -> Optional[ConversationMessage]:
        """
        Trouve la question originale marqu√©e pour clarification
        """
        
        # Rechercher par ID si on a un last_original_question_id
        if self.last_original_question_id:
            for msg in reversed(self.messages[-limit_messages:]):
                if msg.id == self.last_original_question_id and msg.is_original_question:
                    logger.info(f"‚úÖ [Context] Question originale trouv√©e par ID: {msg.id}")
                    return msg
        
        # Rechercher par marqueur sp√©cial dans le message
        for msg in reversed(self.messages[-limit_messages:]):
            if msg.role == "system" and "ORIGINAL_QUESTION_FOR_CLARIFICATION:" in msg.message:
                # Extraire la question du marqueur
                question_text = msg.message.replace("ORIGINAL_QUESTION_FOR_CLARIFICATION: ", "")
                
                # Cr√©er un message virtuel pour la question originale
                original_msg = ConversationMessage(
                    id=f"original_{msg.id}",
                    conversation_id=self.conversation_id,
                    user_id=self.user_id,
                    role="user",
                    message=question_text,
                    timestamp=msg.timestamp,
                    language=self.language,
                    message_type="original_question",
                    is_original_question=True
                )
                
                logger.info(f"‚úÖ [Context] Question originale extraite du marqueur: {question_text}")
                return original_msg
        
        # Rechercher par flag is_original_question
        for msg in reversed(self.messages[-limit_messages:]):
            if msg.is_original_question and msg.role == "user":
                logger.info(f"‚úÖ [Context] Question originale trouv√©e par flag: {msg.message[:50]}...")
                return msg
        
        # Fallback: chercher la derni√®re question utilisateur avant demande clarification
        clarification_keywords = [
            "j'ai besoin de", "pouvez-vous pr√©ciser", "quelle est la race",
            "quel est le sexe", "breed", "sex", "clarification"
        ]
        
        for i, msg in enumerate(reversed(self.messages[-limit_messages:])):
            if msg.role == "assistant" and any(keyword in msg.message.lower() for keyword in clarification_keywords):
                # Chercher la question utilisateur juste avant cette clarification
                actual_index = len(self.messages) - 1 - i
                if actual_index > 0:
                    prev_msg = self.messages[actual_index - 1]
                    if prev_msg.role == "user":
                        logger.info(f"üîÑ [Context] Question originale trouv√©e par fallback: {prev_msg.message[:50]}...")
                        return prev_msg
        
        logger.warning("‚ö†Ô∏è [Context] Question originale non trouv√©e!")
        return None
    
    def get_last_user_question(self, exclude_clarifications: bool = True) -> Optional[ConversationMessage]:
        """
        R√©cup√®re la derni√®re question utilisateur
        """
        
        for msg in reversed(self.messages):
            if msg.role == "user":
                # Exclure les r√©ponses de clarification courtes si demand√©
                if exclude_clarifications:
                    # Si c'est tr√®s court et contient une race/sexe, c'est probablement une clarification
                    if len(msg.message.split()) <= 3:
                        breed_sex_patterns = [
                            r'ross\s*308', r'cobb\s*500', r'hubbard',
                            r'm√¢les?', r'femelles?', r'males?', r'females?',
                            r'mixte', r'mixed'
                        ]
                        if any(re.search(pattern, msg.message.lower()) for pattern in breed_sex_patterns):
                            continue  # Ignorer cette r√©ponse de clarification
                
                logger.info(f"üîÑ [Context] Derni√®re question utilisateur: {msg.message[:50]}...")
                return msg
        
        logger.warning("‚ö†Ô∏è [Context] Aucune question utilisateur trouv√©e!")
        return None
    
    def get_context_for_clarification(self) -> Dict[str, Any]:
        """Retourne le contexte optimis√© pour les clarifications"""
        
        # Inclure la question originale si trouv√©e
        original_question = self.find_original_question()
        
        context = {
            "breed": self.consolidated_entities.breed,
            "breed_type": self.consolidated_entities.breed_type,
            "sex": self.consolidated_entities.sex,
            "sex_confidence": self.consolidated_entities.sex_confidence,
            "age": self.consolidated_entities.age_days,
            "age_confidence": self.consolidated_entities.age_confidence,
            "weight": self.consolidated_entities.weight_grams,  # üîß FIX: Utiliser weight_grams existant
            "symptoms": self.consolidated_entities.symptoms,
            "housing": self.consolidated_entities.housing_type,
            "urgency": self.conversation_urgency,
            "topic": self.conversation_topic,
            "total_exchanges": self.total_exchanges,
            "missing_critical": self.consolidated_entities.get_critical_missing_info(),
            "overall_confidence": self.consolidated_entities.confidence_overall,
            
            # CHAMPS STANDARD
            "original_question": original_question.message if original_question else None,
            "original_question_id": original_question.id if original_question else None,
            "pending_clarification": self.pending_clarification,
            "last_original_question_id": self.last_original_question_id,
            
            # NOUVEAUX CHAMPS CRITIQUES
            "original_question_pending": self.original_question_pending,
            "critical_clarification_active": self.critical_clarification_active,
            "reprocessing_scheduled": self._schedule_reprocessing
        }
        
        return context
    
    def _safe_topic_check(self, keywords: List[str]) -> bool:
        """Helper s√©curis√© pour v√©rifier les mots-cl√©s dans conversation_topic"""
        if not self.conversation_topic:
            return False
        topic_lower = self.conversation_topic.lower()
        return any(keyword in topic_lower for keyword in keywords)

    def get_missing_entities_list(self) -> List[str]:
        """
        Retourne la liste des entit√©s manquantes
        
        Returns:
            List[str]: Liste des entit√©s manquantes
        """
        return list(self.get_missing_entities_dict().keys())
    
    def get_missing_entities_dict(self) -> Dict[str, str]:
        """
        Retourne les entit√©s manquantes avec leur niveau d'importance
        
        Returns:
            Dict[str, str]: Dictionnaire {entity: importance}
        """
        entities = self.consolidated_entities
        missing_with_importance = {}
        
        # Race - toujours critique pour questions techniques
        if not entities.breed or entities.breed_type == "generic" or entities.breed_confidence < 0.7:
            missing_with_importance["breed"] = "critique"
        
        # Sexe - critique pour performance, secondaire pour sant√©
        if not entities.sex or entities.sex_confidence < 0.7:
            # Protection None avec helper s√©curis√©
            if self._safe_topic_check(["performance", "weight", "growth", "croissance", "poids"]):
                missing_with_importance["sex"] = "critique"
            else:
                missing_with_importance["sex"] = "secondaire"
        
        # √Çge - critique pour la plupart des questions
        if not entities.age_days or entities.age_confidence < 0.7:
            missing_with_importance["age"] = "critique"
        
        # Poids - critique pour questions de performance
        if not entities.weight_grams and not entities.growth_rate:
            # Protection None avec helper s√©curis√©
            if self._safe_topic_check(["performance", "weight", "growth", "croissance", "poids"]):
                missing_with_importance["current_performance"] = "critique"
            else:
                missing_with_importance["current_performance"] = "secondaire"
        
        # Sympt√¥mes - critique pour questions de sant√©
        if not entities.symptoms and not entities.health_status:
            # Protection None avec helper s√©curis√©
            if self._safe_topic_check(["health", "mortality", "disease", "sant√©", "mortalit√©", "maladie"]):
                missing_with_importance["symptoms"] = "critique"
            else:
                missing_with_importance["symptoms"] = "secondaire"
        
        # Mortalit√© - critique si mentionn√©e dans la conversation
        if entities.mortality_rate is None:
            recent_messages_text = " ".join([msg.message.lower() for msg in self.messages[-3:]])
            if any(keyword in recent_messages_text for keyword in ["mortality", "mortalit√©", "meurent", "dying"]):
                missing_with_importance["mortality_rate"] = "critique"
        
        # Conditions environnementales - secondaire sauf si probl√®me mentionn√©
        if not entities.housing_type and not entities.temperature:
            # Protection None avec helper s√©curis√©
            if self._safe_topic_check(["environment", "temperature", "housing", "environnement", "temp√©rature"]):
                missing_with_importance["housing_conditions"] = "critique"
            else:
                missing_with_importance["housing_conditions"] = "secondaire"
        
        # Alimentation - secondaire sauf si probl√®me nutritionnel
        if not entities.feed_type:
            # Protection None avec helper s√©curis√©
            if self._safe_topic_check(["feeding", "nutrition", "alimentation", "nourriture"]):
                missing_with_importance["feed_information"] = "critique"
            else:
                missing_with_importance["feed_information"] = "secondaire"
        
        return missing_with_importance

    def get_missing_entities(self, include_importance: bool = False) -> Union[List[str], Dict[str, str]]:
        """
        M√âTHODE D√âPR√âCI√âE - Utilisez get_missing_entities_list() ou get_missing_entities_dict()
        
        Cette m√©thode est conserv√©e pour compatibilit√© mais d√©pr√©ci√©e
        """
        logger.warning("‚ö†Ô∏è [Deprecated] get_missing_entities() est d√©pr√©ci√©. Utilisez get_missing_entities_list() ou get_missing_entities_dict()")
        
        if include_importance:
            return self.get_missing_entities_dict()
        else:
            return self.get_missing_entities_list()

    def to_dict(self) -> Dict[str, Any]:
        return {
            "conversation_id": self.conversation_id,
            "user_id": self.user_id,
            "messages": [m.to_dict() for m in self.messages],
            "consolidated_entities": self.consolidated_entities.to_dict(),
            "language": self.language,
            "created_at": self.created_at.isoformat(),
            "last_activity": self.last_activity.isoformat(),
            "total_exchanges": self.total_exchanges,
            "conversation_topic": self.conversation_topic,
            "conversation_urgency": self.conversation_urgency,
            "problem_resolution_status": self.problem_resolution_status,
            "ai_enhanced": self.ai_enhanced,
            "last_ai_analysis": self.last_ai_analysis.isoformat() if self.last_ai_analysis else None,
            "needs_clarification": self.needs_clarification,
            "clarification_questions": self.clarification_questions,
            "pending_clarification": self.pending_clarification,
            "last_original_question_id": self.last_original_question_id,
            # NOUVEAUX CHAMPS
            "original_question_pending": self.original_question_pending,
            "critical_clarification_active": self.critical_clarification_active,
            "schedule_reprocessing": self._schedule_reprocessing
        }
