"""
app/api/v1/prompt_templates.py - TEMPLATES DE PROMPTS STRUCTURÃ‰S AVEC VALIDATION PYDANTIC

ğŸ¯ OBJECTIF: Centraliser et standardiser les prompts pour le systÃ¨me RAG
ğŸ”§ AMÃ‰LIORATION: Ã‰liminer les rÃ©fÃ©rences aux documents dans les rÃ©ponses
âœ¨ QUALITÃ‰: RÃ©ponses plus naturelles et professionnelles
ğŸ†• NOUVEAU: Prompt de contextualisation pour mode sÃ©mantique dynamique
ğŸ”§ NOUVEAU: Validation robuste des questions gÃ©nÃ©rÃ©es dynamiquement
ğŸ”§ NOUVEAU: Fallback intelligent si GPT Ã©choue
ğŸ¯ NOUVEAU: Filtrage avancÃ© des questions non pertinentes
ğŸ”§ MISE Ã€ JOUR: Message utilisateur neutre centralisÃ©
ğŸ†• NOUVELLE FONCTIONNALITÃ‰: Templates de clarification gÃ©nÃ©riques et spÃ©cifiques

âœ¨ AMÃ‰LIORATIONS VERSION 3.0:
- âœ… Validation Pydantic pour les rÃ©ponses JSON de GPT
- âœ… Injection dynamique du topic dans les prompts gÃ©nÃ©riques
- âœ… ModÃ¨les de donnÃ©es strictes pour les rÃ©ponses
- âœ… Validation automatique des formats JSON
- âœ… Enrichissement contextuel automatique
- âœ… Gestion d'erreurs renforcÃ©e avec types

NOUVELLES FONCTIONNALITÃ‰S V2:
- âœ… Template gÃ©nÃ©rique de clarification (clarification_generic)
- âœ… Template spÃ©cifique par contexte (clarification_specific)
- âœ… Injection dynamique des CRITICAL_ENTITIES
- âœ… Templates par sujet (santÃ©, nutrition, performance)
- âœ… Support multilingue pour tous les templates

CORRECTIONS APPORTÃ‰ES:
- âœ… Import manquant 'json' ajoutÃ©
- âœ… Gestion robuste des erreurs JSON avec fallback
- âœ… Validation du format des questions renforcÃ©e
- âœ… Gestion des exceptions lors de l'extraction du contexte
- âœ… Documentation des types de retour amÃ©liorÃ©e
- âœ… Logique de validation plus robuste
- âœ… Gestion des cas edge dans l'analyse des questions
"""

import logging
import re
import json
from typing import Dict, Any, Optional, List, Tuple, Union
from pydantic import BaseModel, Field, validator, ValidationError
from enum import Enum

# Import des entitÃ©s critiques (assumÃ© disponible)
try:
    from .clarification_entities import CRITICAL_ENTITIES
except ImportError:
    # Fallback si le module n'est pas disponible
    CRITICAL_ENTITIES = {
        "breed": {"fr": "race", "en": "breed", "es": "raza"},
        "age": {"fr": "Ã¢ge", "en": "age", "es": "edad"},
        "sex": {"fr": "sexe", "en": "sex", "es": "sexo"},
        "symptoms": {"fr": "symptÃ´mes", "en": "symptoms", "es": "sÃ­ntomas"},
        "housing_conditions": {"fr": "conditions d'Ã©levage", "en": "housing conditions", "es": "condiciones de alojamiento"}
    }

logger = logging.getLogger(__name__)

# =============================================================================
# ğŸ†• MODÃˆLES PYDANTIC POUR VALIDATION STRICTE
# =============================================================================

class LanguageEnum(str, Enum):
    """Ã‰numÃ©ration des langues supportÃ©es"""
    FRENCH = "fr"
    ENGLISH = "en"
    SPANISH = "es"

class TopicEnum(str, Enum):
    """Ã‰numÃ©ration des sujets/topics supportÃ©s"""
    HEALTH = "health"
    NUTRITION = "nutrition"
    PERFORMANCE = "performance"
    HOUSING = "housing"
    MANAGEMENT = "management"
    REPRODUCTION = "reproduction"
    GENERAL = "general"

class ClarificationQuestion(BaseModel):
    """ModÃ¨le pour une question de clarification individuelle"""
    text: str = Field(..., min_length=10, max_length=300, description="Texte de la question")
    
    @validator('text')
    def validate_question_text(cls, v):
        """Valide le format et le contenu de la question"""
        if not v or not isinstance(v, str):
            raise ValueError("La question doit Ãªtre une chaÃ®ne non vide")
        
        v = v.strip()
        if len(v) < 10:
            raise ValueError("La question doit contenir au moins 10 caractÃ¨res")
        
        # VÃ©rifier que c'est bien une question
        if not (v.endswith('?') or any(word in v.lower() for word in ['quel', 'what', 'quÃ©', 'comment', 'how', 'cÃ³mo'])):
            raise ValueError("Le texte doit Ãªtre une question valide")
        
        # Rejeter les questions gÃ©nÃ©riques
        generic_keywords = ['exemple', 'example', 'ejemplo', 'gÃ©nÃ©ralement', 'generally', 'generalmente']
        if any(keyword in v.lower() for keyword in generic_keywords):
            raise ValueError("Question trop gÃ©nÃ©rique dÃ©tectÃ©e")
        
        return v

class GPTClarificationResponse(BaseModel):
    """ModÃ¨le strict pour les rÃ©ponses de clarification de GPT"""
    clarification_questions: List[ClarificationQuestion] = Field(
        ..., 
        min_items=1, 
        max_items=4, 
        description="Liste des questions de clarification"
    )
    
    @validator('clarification_questions')
    def validate_questions_list(cls, v):
        """Valide la liste des questions"""
        if not v:
            raise ValueError("Au moins une question de clarification est requise")
        
        if len(v) > 4:
            raise ValueError("Maximum 4 questions de clarification autorisÃ©es")
        
        # VÃ©rifier l'unicitÃ© des questions
        questions_text = [q.text.lower().strip() for q in v]
        if len(questions_text) != len(set(questions_text)):
            raise ValueError("Les questions en doublon ne sont pas autorisÃ©es")
        
        return v

class ParsedGPTResponse(BaseModel):
    """ModÃ¨le pour le rÃ©sultat du parsing des rÃ©ponses GPT"""
    clarification_questions: List[str] = Field(default_factory=list, description="Questions extraites")
    parsing_success: bool = Field(default=False, description="SuccÃ¨s du parsing")
    validation_success: bool = Field(default=False, description="SuccÃ¨s de la validation Pydantic")
    raw_response: str = Field(default="", description="RÃ©ponse brute de GPT")
    error: Optional[str] = Field(default=None, description="Erreur rencontrÃ©e")
    validation_errors: List[str] = Field(default_factory=list, description="Erreurs de validation dÃ©taillÃ©es")

class PromptContext(BaseModel):
    """ModÃ¨le pour le contexte d'un prompt"""
    breed: str = Field(default="non spÃ©cifiÃ©e", description="Race/souche")
    sex: str = Field(default="non spÃ©cifiÃ©", description="Sexe")
    age: str = Field(default="non spÃ©cifiÃ©", description="Ã‚ge")
    lang: LanguageEnum = Field(default=LanguageEnum.FRENCH, description="Langue")
    topic: Optional[TopicEnum] = Field(default=None, description="Sujet identifiÃ©")
    
    @validator('breed', 'sex', 'age')
    def validate_context_fields(cls, v):
        """Valide les champs de contexte"""
        if v is None:
            return "non spÃ©cifiÃ©"
        return str(v).strip() if str(v).strip() else "non spÃ©cifiÃ©"

# âœ… Message utilisateur neutre centralisÃ©
USER_NEEDS_CLARIFICATION_MSG = (
    "Votre question manque de contexte. "
    "Un expert virtuel va vous poser quelques questions pour mieux comprendre la situation. "
    "ğŸ’¡ RÃ©pondez simplement dans le chat avec les informations demandÃ©es."
)

# =============================================================================
# ğŸ†• FONCTIONS PYDANTIC DE VALIDATION ET PARSING
# =============================================================================

def validate_gpt_response_with_pydantic(response_text: str) -> ParsedGPTResponse:
    """
    ğŸ†• NOUVEAU: Validation stricte des rÃ©ponses GPT avec Pydantic
    
    Args:
        response_text: RÃ©ponse brute de GPT
        
    Returns:
        ParsedGPTResponse: RÃ©sultat de parsing et validation avec types stricts
    """
    result = ParsedGPTResponse(raw_response=response_text)
    
    if not response_text or not isinstance(response_text, str):
        result.error = "RÃ©ponse vide ou invalide"
        return result
    
    try:
        # Ã‰tape 1: Nettoyer et parser le JSON
        cleaned_response = _clean_json_response(response_text)
        
        try:
            parsed_json = json.loads(cleaned_response)
        except json.JSONDecodeError as e:
            result.error = f"Erreur parsing JSON: {str(e)}"
            # Tentative de rÃ©cupÃ©ration avec regex
            return _fallback_regex_parsing(response_text, result)
        
        # Ã‰tape 2: Validation Pydantic stricte
        try:
            # PrÃ©paration des donnÃ©es pour Pydantic
            if isinstance(parsed_json, dict) and "clarification_questions" in parsed_json:
                questions_data = parsed_json["clarification_questions"]
                
                # Convertir en format attendu par Pydantic
                if isinstance(questions_data, list):
                    pydantic_questions = []
                    for q in questions_data:
                        if isinstance(q, str):
                            pydantic_questions.append({"text": q})
                        elif isinstance(q, dict) and "text" in q:
                            pydantic_questions.append(q)
                        else:
                            result.validation_errors.append(f"Format de question invalide: {q}")
                            continue
                    
                    # Validation Pydantic
                    validated_response = GPTClarificationResponse(
                        clarification_questions=pydantic_questions
                    )
                    
                    # Extraction des questions validÃ©es
                    result.clarification_questions = [q.text for q in validated_response.clarification_questions]
                    result.parsing_success = True
                    result.validation_success = True
                    
                    logger.info(f"âœ… [Pydantic Validation] Validation rÃ©ussie: {len(result.clarification_questions)} questions")
                    
                else:
                    result.error = "clarification_questions doit Ãªtre une liste"
                    result.validation_errors.append("Format de donnÃ©es invalide pour clarification_questions")
            else:
                result.error = "Structure JSON invalide - clÃ© 'clarification_questions' manquante"
                result.validation_errors.append("ClÃ© 'clarification_questions' manquante dans la rÃ©ponse")
                
        except ValidationError as e:
            result.error = f"Erreur validation Pydantic: {str(e)}"
            result.validation_errors = [str(error) for error in e.errors()]
            logger.warning(f"âš ï¸ [Pydantic Validation] Ã‰chec validation: {e}")
            
            # Tentative de rÃ©cupÃ©ration partielle
            if isinstance(parsed_json, dict) and "clarification_questions" in parsed_json:
                questions = parsed_json["clarification_questions"]
                if isinstance(questions, list):
                    # Filtrer et nettoyer les questions qui passent une validation basique
                    valid_questions = []
                    for q in questions:
                        if isinstance(q, str) and len(q.strip()) >= 10 and ('?' in q or any(word in q.lower() for word in ['quel', 'what', 'quÃ©'])):
                            valid_questions.append(q.strip())
                    
                    if valid_questions:
                        result.clarification_questions = valid_questions[:4]
                        result.parsing_success = True
                        logger.info(f"ğŸ”„ [Pydantic Validation] RÃ©cupÃ©ration partielle: {len(valid_questions)} questions")
                        
    except Exception as e:
        result.error = f"Erreur inattendue: {str(e)}"
        logger.error(f"âŒ [Pydantic Validation] Erreur validation: {e}")
        return _fallback_regex_parsing(response_text, result)
    
    return result

def _clean_json_response(response_text: str) -> str:
    """Nettoie la rÃ©ponse GPT pour extraction JSON"""
    cleaned = response_text.strip()
    
    # Enlever les balises markdown
    if cleaned.startswith("```json"):
        cleaned = cleaned[7:]
    elif cleaned.startswith("```"):
        cleaned = cleaned[3:]
    
    if cleaned.endswith("```"):
        cleaned = cleaned[:-3]
    
    return cleaned.strip()

def _fallback_regex_parsing(response_text: str, result: ParsedGPTResponse) -> ParsedGPTResponse:
    """Fallback avec parsing regex si JSON/Pydantic Ã©choue"""
    try:
        # Chercher des questions avec regex
        question_pattern = r'"([^"]*\?[^"]*)"'
        found_questions = re.findall(question_pattern, response_text)
        
        # Filtrer les questions valides
        valid_questions = []
        for q in found_questions:
            if len(q.strip()) >= 10 and not any(generic in q.lower() for generic in ['exemple', 'example', 'etc']):
                valid_questions.append(q.strip())
        
        if valid_questions:
            result.clarification_questions = valid_questions[:4]
            result.parsing_success = True
            result.error = f"RÃ©cupÃ©ration par regex - validation Pydantic Ã©chouÃ©e: {result.error}"
            logger.info(f"ğŸ”„ [Regex Fallback] RÃ©cupÃ©ration: {len(valid_questions)} questions")
        
    except Exception as regex_error:
        logger.error(f"âŒ [Regex Fallback] Ã‰chec rÃ©cupÃ©ration regex: {regex_error}")
        result.error = f"Ã‰chec parsing complet: {result.error} | Regex: {str(regex_error)}"
    
    return result

# =============================================================================
# ğŸ†• TEMPLATES DE CLARIFICATION AVEC INJECTION DYNAMIQUE DE TOPIC
# =============================================================================

def build_clarification_generic_prompt(
    user_question: str,
    conversation_context: str,
    missing_entities: List[str],
    language: LanguageEnum = LanguageEnum.FRENCH,
    topic: Optional[TopicEnum] = None
) -> str:
    """
    ğŸ†• NOUVEAU: Template gÃ©nÃ©rique de clarification avec injection dynamique du topic
    
    Args:
        user_question: Question originale de l'utilisateur
        conversation_context: Contexte de la conversation
        missing_entities: Liste des entitÃ©s manquantes
        language: Langue de rÃ©ponse
        topic: Sujet identifiÃ© (injection automatique si disponible)
        
    Returns:
        str: Prompt structurÃ© pour clarification gÃ©nÃ©rique enrichie
    """
    
    # Validation des paramÃ¨tres avec Pydantic
    try:
        context = PromptContext(
            lang=language,
            topic=topic
        )
        language = context.lang
        topic = context.topic
    except ValidationError as e:
        logger.warning(f"âš ï¸ [Generic Prompt] ParamÃ¨tres invalides, utilisation des dÃ©fauts: {e}")
        language = LanguageEnum.FRENCH
        topic = None
    
    # Validation et nettoyage des entrÃ©es
    if not isinstance(user_question, str):
        user_question = str(user_question) if user_question else "Question non spÃ©cifiÃ©e"
    
    if not isinstance(conversation_context, str):
        conversation_context = str(conversation_context) if conversation_context else "Aucun contexte"
    
    if not isinstance(missing_entities, list):
        missing_entities = []
    
    # Formatage des entitÃ©s manquantes
    missing_entities_text = _format_missing_entities(missing_entities, language.value)
    
    # ğŸ†• INJECTION DYNAMIQUE DU TOPIC si disponible
    topic_context = ""
    if topic and topic != TopicEnum.GENERAL:
        topic_translations = {
            TopicEnum.HEALTH: {"fr": "santÃ© animale", "en": "animal health", "es": "salud animal"},
            TopicEnum.NUTRITION: {"fr": "nutrition", "en": "nutrition", "es": "nutriciÃ³n"},
            TopicEnum.PERFORMANCE: {"fr": "performance", "en": "performance", "es": "rendimiento"},
            TopicEnum.HOUSING: {"fr": "logement", "en": "housing", "es": "alojamiento"},
            TopicEnum.MANAGEMENT: {"fr": "gestion d'Ã©levage", "en": "farm management", "es": "manejo de granja"},
            TopicEnum.REPRODUCTION: {"fr": "reproduction", "en": "reproduction", "es": "reproducciÃ³n"}
        }
        
        translated_topic = topic_translations.get(topic, {}).get(language.value, topic.value)
        
        topic_context_templates = {
            "fr": f"\n\nSUJET IDENTIFIÃ‰ : {translated_topic}\nAdaptez vos questions pour Ãªtre plus spÃ©cifiques au domaine {translated_topic}.",
            "en": f"\n\nIDENTIFIED TOPIC: {translated_topic}\nAdapt your questions to be more specific to the {translated_topic} domain.",
            "es": f"\n\nTEMA IDENTIFICADO: {translated_topic}\nAdapte sus preguntas para ser mÃ¡s especÃ­ficas al dominio {translated_topic}."
        }
        
        topic_context = topic_context_templates.get(language.value, topic_context_templates["fr"])
    
    templates = {
        "fr": f"""L'utilisateur a posÃ© la question : "{user_question}"

Contexte de la conversation : "{conversation_context}"

Les informations critiques manquantes sont : {missing_entities_text}{topic_context}

En tant qu'expert avicole avec 20 ans d'expÃ©rience, gÃ©nÃ¨re 1 Ã  3 questions CLAIRES et DIRECTES pour obtenir ces informations manquantes.

RÃˆGLES CRITIQUES :
- Questions courtes et prÃ©cises
- Pas d'exemples gÃ©nÃ©riques
- Focalise sur l'INFORMATION MANQUANTE uniquement
- Utilise un ton professionnel mais accessible
- Ne reformule PAS la question originale
- Si un sujet spÃ©cifique est identifiÃ©, utilise la terminologie appropriÃ©e

RÃ©ponds uniquement sous forme de liste de questions au format JSON :
{{
  "clarification_questions": [
    "Question 1",
    "Question 2"
  ]
}}""",

        "en": f"""The user asked the question: "{user_question}"

Conversation context: "{conversation_context}"

The critical missing information is: {missing_entities_text}{topic_context}

As a poultry expert with 20 years of experience, generate 1 to 3 CLEAR and DIRECT questions to obtain this missing information.

CRITICAL RULES:
- Short and precise questions
- No generic examples
- Focus on MISSING INFORMATION only
- Use a professional but accessible tone
- Do NOT rephrase the original question
- If a specific topic is identified, use appropriate terminology

Respond only as a list of questions in JSON format:
{{
  "clarification_questions": [
    "Question 1",
    "Question 2"
  ]
}}""",

        "es": f"""El usuario hizo la pregunta: "{user_question}"

Contexto de la conversaciÃ³n: "{conversation_context}"

La informaciÃ³n crÃ­tica faltante es: {missing_entities_text}{topic_context}

Como experto avÃ­cola con 20 aÃ±os de experiencia, genera 1 a 3 preguntas CLARAS y DIRECTAS para obtener esta informaciÃ³n faltante.

REGLAS CRÃTICAS:
- Preguntas cortas y precisas
- Sin ejemplos genÃ©ricos
- EnfÃ³cate solo en la INFORMACIÃ“N FALTANTE
- Usa un tono profesional pero accesible
- NO reformules la pregunta original
- Si se identifica un tema especÃ­fico, usa terminologÃ­a apropiada

Responde solo como lista de preguntas en formato JSON:
{{
  "clarification_questions": [
    "Pregunta 1",
    "Pregunta 2"
  ]
}}"""
    }
    
    return templates.get(language.value, templates["fr"])

def build_clarification_specific_prompt(
    user_question: str,
    topic: TopicEnum,
    conversation_context: str,
    missing_entities: List[str],
    language: LanguageEnum = LanguageEnum.FRENCH
) -> str:
    """
    ğŸ†• NOUVEAU: Template spÃ©cifique par contexte avec validation Pydantic
    
    Args:
        user_question: Question originale de l'utilisateur
        topic: Sujet identifiÃ© (validÃ© par enum)
        conversation_context: Contexte de la conversation
        missing_entities: Liste des entitÃ©s manquantes
        language: Langue de rÃ©ponse (validÃ© par enum)
        
    Returns:
        str: Prompt structurÃ© pour clarification spÃ©cifique
    """
    
    # Validation Pydantic automatique
    try:
        context = PromptContext(
            lang=language,
            topic=topic
        )
        language = context.lang
        topic = context.topic
    except ValidationError as e:
        logger.warning(f"âš ï¸ [Specific Prompt] ParamÃ¨tres invalides: {e}")
        language = LanguageEnum.FRENCH
        topic = TopicEnum.GENERAL
    
    # Validation et nettoyage des entrÃ©es
    if not isinstance(user_question, str):
        user_question = str(user_question) if user_question else "Question non spÃ©cifiÃ©e"
    
    if not isinstance(conversation_context, str):
        conversation_context = str(conversation_context) if conversation_context else "Aucun contexte"
    
    if not isinstance(missing_entities, list):
        missing_entities = []
    
    # Formatage des entitÃ©s manquantes
    missing_entities_text = _format_missing_entities(missing_entities, language.value)
    
    # Traduction du topic avec enum sÃ©curisÃ©
    topic_translations = {
        TopicEnum.HEALTH: {"fr": "santÃ© animale", "en": "animal health", "es": "salud animal"},
        TopicEnum.NUTRITION: {"fr": "nutrition", "en": "nutrition", "es": "nutriciÃ³n"},
        TopicEnum.PERFORMANCE: {"fr": "performance", "en": "performance", "es": "rendimiento"},
        TopicEnum.HOUSING: {"fr": "logement", "en": "housing", "es": "alojamiento"},
        TopicEnum.MANAGEMENT: {"fr": "gestion d'Ã©levage", "en": "farm management", "es": "manejo de granja"},
        TopicEnum.REPRODUCTION: {"fr": "reproduction", "en": "reproduction", "es": "reproducciÃ³n"},
        TopicEnum.GENERAL: {"fr": "gÃ©nÃ©ral", "en": "general", "es": "general"}
    }
    
    translated_topic = topic_translations.get(topic, {}).get(language.value, topic.value)
    
    templates = {
        "fr": f"""L'utilisateur a posÃ© la question : "{user_question}"

Sujet identifiÃ© : {translated_topic}

Contexte de la conversation : "{conversation_context}"

Les informations critiques manquantes sont : {missing_entities_text}

En tant qu'expert avicole spÃ©cialisÃ© en {translated_topic}, gÃ©nÃ¨re 1 Ã  3 questions ciblÃ©es pour obtenir ces informations.

INSTRUCTIONS SPÃ‰CIALISÃ‰ES :
- Questions techniques prÃ©cises pour le domaine {translated_topic}
- Utilise la terminologie professionnelle appropriÃ©e
- Focalise sur les paramÃ¨tres clÃ©s de {translated_topic}
- Ã‰vite les questions gÃ©nÃ©rales ou vagues
- Anticipe les besoins d'un diagnostic prÃ©cis

Utilise un ton professionnel et prÃ©cis.

RÃ©ponds uniquement sous forme de liste de questions au format JSON :
{{
  "clarification_questions": [
    "Question 1",
    "Question 2"
  ]
}}""",

        "en": f"""The user asked the question: "{user_question}"

Identified topic: {translated_topic}

Conversation context: "{conversation_context}"

The critical missing information is: {missing_entities_text}

As a poultry expert specialized in {translated_topic}, generate 1 to 3 targeted questions to obtain this information.

SPECIALIZED INSTRUCTIONS:
- Precise technical questions for the {translated_topic} domain
- Use appropriate professional terminology
- Focus on key parameters of {translated_topic}
- Avoid general or vague questions
- Anticipate the needs for precise diagnosis

Use a professional and precise tone.

Respond only as a list of questions in JSON format:
{{
  "clarification_questions": [
    "Question 1",
    "Question 2"
  ]
}}""",

        "es": f"""El usuario hizo la pregunta: "{user_question}"

Tema identificado: {translated_topic}

Contexto de la conversaciÃ³n: "{conversation_context}"

La informaciÃ³n crÃ­tica faltante es: {missing_entities_text}

Como experto avÃ­cola especializado en {translated_topic}, genera 1 a 3 preguntas dirigidas para obtener esta informaciÃ³n.

INSTRUCCIONES ESPECIALIZADAS:
- Preguntas tÃ©cnicas precisas para el dominio {translated_topic}
- Usa terminologÃ­a profesional apropiada
- EnfÃ³cate en parÃ¡metros clave de {translated_topic}
- Evita preguntas generales o vagas
- Anticipa las necesidades de un diagnÃ³stico preciso

Usa un tono profesional y preciso.

Responde solo como lista de preguntas en formato JSON:
{{
  "clarification_questions": [
    "Pregunta 1",
    "Pregunta 2"
  ]
}}"""
    }
    
    return templates.get(language.value, templates["fr"])

def _format_missing_entities(missing_entities: List[str], language: str) -> str:
    """
    ğŸ”§ UTILITAIRE: Formate les entitÃ©s manquantes pour injection dans les prompts
    
    Args:
        missing_entities: Liste des entitÃ©s manquantes
        language: Langue pour la traduction
        
    Returns:
        str: Texte formatÃ© des entitÃ©s manquantes
    """
    
    if not missing_entities:
        return {
            "fr": "aucune information spÃ©cifique",
            "en": "no specific information",
            "es": "ninguna informaciÃ³n especÃ­fica"
        }.get(language, "aucune information spÃ©cifique")
    
    # Traduire les entitÃ©s vers la langue cible
    translated_entities = []
    for entity in missing_entities:
        if entity in CRITICAL_ENTITIES:
            translated = CRITICAL_ENTITIES[entity].get(language, entity)
            translated_entities.append(translated)
        else:
            translated_entities.append(entity)
    
    # Formatage par langue
    if language == "en":
        if len(translated_entities) == 1:
            return translated_entities[0]
        elif len(translated_entities) == 2:
            return f"{translated_entities[0]} and {translated_entities[1]}"
        else:
            return ", ".join(translated_entities[:-1]) + f", and {translated_entities[-1]}"
    
    elif language == "es":
        if len(translated_entities) == 1:
            return translated_entities[0]
        elif len(translated_entities) == 2:
            return f"{translated_entities[0]} y {translated_entities[1]}"
        else:
            return ", ".join(translated_entities[:-1]) + f" y {translated_entities[-1]}"
    
    else:  # franÃ§ais
        if len(translated_entities) == 1:
            return translated_entities[0]
        elif len(translated_entities) == 2:
            return f"{translated_entities[0]} et {translated_entities[1]}"
        else:
            return ", ".join(translated_entities[:-1]) + f" et {translated_entities[-1]}"

# =============================================================================
# TEMPLATES EXISTANTS (CONSERVÃ‰S ET AMÃ‰LIORÃ‰S AVEC VALIDATION PYDANTIC)
# =============================================================================

def build_structured_prompt(documents: str, question: str, context: Dict[str, Any]) -> str:
    """
    ğŸ¯ PROMPT PRINCIPAL - Construit un prompt structurÃ© pour le RAG avec validation
    
    Args:
        documents: Contenu des documents trouvÃ©s
        question: Question de l'utilisateur
        context: Contexte extrait (breed, sex, age, lang, topic)
        
    Returns:
        str: Prompt structurÃ© pour le LLM
    """
    
    # Validation avec Pydantic
    try:
        validated_context = PromptContext(**context)
    except ValidationError as e:
        logger.warning(f"âš ï¸ [Structured Prompt] Contexte invalide, utilisation des dÃ©fauts: {e}")
        validated_context = PromptContext()
    
    # SÃ©curisation des paramÃ¨tres
    if not isinstance(documents, str):
        documents = str(documents) if documents else ""
    if not isinstance(question, str):
        question = str(question) if question else ""
    
    # Utilisation des valeurs validÃ©es
    breed = validated_context.breed
    sex = validated_context.sex
    age = validated_context.age
    language = validated_context.lang
    
    try:
        if language == LanguageEnum.ENGLISH:
            return _build_english_prompt(documents, question, breed, sex, age)
        elif language == LanguageEnum.SPANISH:
            return _build_spanish_prompt(documents, question, breed, sex, age)
        else:
            return _build_french_prompt(documents, question, breed, sex, age)
    except Exception as e:
        logger.error(f"âŒ [Prompt Build] Erreur construction prompt: {e}")
        return _build_french_prompt(documents, question, breed, sex, age)

def _build_french_prompt(documents: str, question: str, breed: str, sex: str, age: str) -> str:
    """Template franÃ§ais optimisÃ© avec validation"""
    
    # SÃ©curisation des paramÃ¨tres
    documents = str(documents) if documents else "Aucune information technique disponible"
    question = str(question) if question else "Question non spÃ©cifiÃ©e"
    breed = str(breed) if breed else "non spÃ©cifiÃ©e"
    sex = str(sex) if sex else "non spÃ©cifiÃ©"
    age = str(age) if age else "non spÃ©cifiÃ©"
    
    return f"""Vous Ãªtes un expert en production avicole avec 20 ans d'expÃ©rience terrain.

CONTEXTE SPÃ‰CIFIQUE :
- Race/souche : {breed}
- Sexe : {sex}
- Ã‚ge : {age}

INFORMATIONS TECHNIQUES DISPONIBLES :
{documents}

QUESTION Ã€ TRAITER :
{question}

INSTRUCTIONS CRITIQUES :
1. RÃ©pondez comme un expert qui maÃ®trise parfaitement ces informations techniques
2. NE mentionnez JAMAIS les termes "document", "source", "rÃ©fÃ©rence" ou "selon"
3. IntÃ©grez naturellement les donnÃ©es chiffrÃ©es et recommandations techniques
4. Si l'information est incomplÃ¨te, demandez des prÃ©cisions spÃ©cifiques
5. Utilisez un ton professionnel mais accessible
6. Incluez toujours les donnÃ©es de performance pertinentes (poids, FCR, mortalitÃ©, etc.)
7. Donnez des fourchettes de valeurs quand appropriÃ© (ex: 410-450g)

RÃ‰PONSE EXPERTE :"""

def _build_english_prompt(documents: str, question: str, breed: str, sex: str, age: str) -> str:
    """Template anglais optimisÃ© avec validation"""
    
    documents = str(documents) if documents else "No technical information available"
    question = str(question) if question else "Question not specified"
    breed = str(breed) if breed else "not specified"
    sex = str(sex) if sex else "not specified"
    age = str(age) if age else "not specified"
    
    return f"""You are a poultry production expert with 20 years of field experience.

SPECIFIC CONTEXT:
- Breed/strain: {breed}
- Sex: {sex}
- Age: {age}

TECHNICAL INFORMATION AVAILABLE:
{documents}

QUESTION TO ADDRESS:
{question}

CRITICAL INSTRUCTIONS:
1. Respond as an expert who perfectly masters this technical information
2. NEVER mention terms like "document", "source", "reference" or "according to"
3. Naturally integrate numerical data and technical recommendations
4. If information is incomplete, ask for specific clarifications
5. Use a professional but accessible tone
6. Always include relevant performance data (weight, FCR, mortality, etc.)
7. Provide value ranges when appropriate (e.g., 410-450g)

EXPERT RESPONSE:"""

def _build_spanish_prompt(documents: str, question: str, breed: str, sex: str, age: str) -> str:
    """Template espagnol optimisÃ© avec validation"""
    
    documents = str(documents) if documents else "No hay informaciÃ³n tÃ©cnica disponible"
    question = str(question) if question else "Pregunta no especificada"
    breed = str(breed) if breed else "no especificada"
    sex = str(sex) if sex else "no especificado"
    age = str(age) if age else "no especificada"
    
    return f"""Usted es un experto en producciÃ³n avÃ­cola con 20 aÃ±os de experiencia de campo.

CONTEXTO ESPECÃFICO:
- Raza/cepa: {breed}
- Sexe: {sex}
- Edad: {age}

INFORMACIÃ“N TÃ‰CNICA DISPONIBLE:
{documents}

PREGUNTA A TRATAR:
{question}

INSTRUCCIONES CRÃTICAS:
1. Responda como un experto que domina perfectamente esta informaciÃ³n tÃ©cnica
2. NUNCA mencione tÃ©rminos como "documento", "fuente", "referencia" o "segÃºn"
3. Integre naturalmente los datos numÃ©ricos y recomendaciones tÃ©cnicas
4. Si la informaciÃ³n estÃ¡ incompleta, pida aclaraciones especÃ­ficas
5. Use un tono profesional pero accesible
6. Incluya siempre datos de rendimiento relevantes (peso, conversiÃ³n, mortalidad, etc.)
7. Proporcione rangos de valores cuando sea apropiado (ej: 410-450g)

RESPUESTA EXPERTA:"""

def build_contextualization_prompt(user_question: str, language: LanguageEnum = LanguageEnum.FRENCH) -> str:
    """
    ğŸ†• AMÃ‰LIORÃ‰: Construit un prompt pour gÃ©nÃ©rer des questions de clarification avec validation Pydantic
    
    Args:
        user_question: Question originale de l'utilisateur
        language: Langue de rÃ©ponse (validÃ© par enum)
        
    Returns:
        str: Prompt structurÃ© pour GPT
        
    Raises:
        ValueError: Si la question utilisateur est vide
    """
    
    # Validation Pydantic
    try:
        context = PromptContext(lang=language)
        language = context.lang
    except ValidationError as e:
        logger.warning(f"âš ï¸ [Contextualization] Langue invalide: {e}")
        language = LanguageEnum.FRENCH
    
    # Validation de la question
    if not user_question or not isinstance(user_question, str):
        raise ValueError("user_question ne peut pas Ãªtre vide ou None")
    
    user_question = user_question.strip()
    if not user_question:
        raise ValueError("user_question ne peut pas Ãªtre une chaÃ®ne vide")
    
    if language == LanguageEnum.ENGLISH:
        return f"""You are a poultry farming expert specialized in providing practical advice.

Your task is to help another AI agent better understand the following question: "{user_question}"

Analyze the question and deduce its main theme (e.g., laying drop, mortality, temperature, feeding, etc.). Then generate between 2 and 4 **targeted and concrete** clarification questions to better understand the problem.

CRITICAL RULES:
- Do NOT propose generic examples or hypothetical scenarios
- Do NOT reformulate the question
- Do NOT answer the question
- Do NOT mention breeds or species that are not already cited by the user
- Focus on MISSING INFORMATION that would help provide a precise answer
- Ask for SPECIFIC details (exact age, specific breed, current conditions)

GOOD examples of targeted questions:
- "What exact breed/strain are you raising?" (if not specified)
- "What is their current age in days?" (if age missing)
- "What specific symptoms are you observing?" (for health issues)
- "What are the current housing conditions?" (for environment issues)

Respond in this JSON format:
{{
  "clarification_questions": [
    "Question 1",
    "Question 2",
    "Question 3"
  ]
}}"""

    elif language == LanguageEnum.SPANISH:
        return f"""Eres un experto en avicultura especializado en brindar asesorÃ­a prÃ¡ctica.

Tu tarea es ayudar a otro agente de IA a entender mejor la siguiente pregunta: "{user_question}"

Analiza la pregunta y deduce su tema principal (ej. caÃ­da de postura, mortalidad, temperatura, alimentaciÃ³n, etc.). Luego genera entre 2 y 4 preguntas de aclaraciÃ³n **dirigidas y concretas** para entender mejor el problema.

REGLAS CRÃTICAS:
- NO propongas ejemplos genÃ©ricos o escenarios hipotÃ©ticos
- NO reformules la pregunta
- NO respondas la pregunta
- NO menciones razas o especies que no hayan sido ya citadas por el usuario
- EnfÃ³cate en INFORMACIÃ“N FALTANTE que ayudarÃ­a a proporcionar una respuesta precisa
- Pregunta por detalles ESPECÃFICOS (edad exacta, raza especÃ­fica, condiciones actuales)

Ejemplos BUENOS de preguntas dirigidas:
- "Â¿QuÃ© raza/cepa exacta estÃ¡ criando?" (si no especificado)
- "Â¿CuÃ¡l es su edad actual en dÃ­as?" (si falta la edad)
- "Â¿QuÃ© sÃ­ntomas especÃ­ficos estÃ¡ observando?" (para problemas de salud)
- "Â¿CuÃ¡les son las condiciones actuales de alojamiento?" (para problemas ambientales)

Responde en este formato JSON:
{{
  "clarification_questions": [
    "Pregunta 1",
    "Pregunta 2",
    "Pregunta 3"
  ]
}}"""

    else:  # franÃ§ais
        return f"""Tu es un expert en aviculture spÃ©cialisÃ© dans les conseils pratiques.

Ta tÃ¢che est d'aider un autre agent IA Ã  mieux comprendre la question suivante : "{user_question}"

Analyse la question et dÃ©duis son thÃ¨me principal (ex. baisse de ponte, mortalitÃ©, tempÃ©rature, alimentation, etc.). Puis gÃ©nÃ¨re entre 2 et 4 questions de clarification **ciblÃ©es et concrÃ¨tes** pour mieux comprendre le problÃ¨me.

RÃˆGLES CRITIQUES :
- Ne propose PAS d'exemples gÃ©nÃ©riques ou de scÃ©narios hypothÃ©tiques
- Ne reformule PAS la question
- Ne rÃ©ponds PAS Ã  la question
- Ne mentionne PAS de races ou d'espÃ¨ces qui ne sont pas dÃ©jÃ  citÃ©es par l'utilisateur
- Concentre-toi sur l'INFORMATION MANQUANTE qui aiderait Ã  fournir une rÃ©ponse prÃ©cise
- Demande des dÃ©tails SPÃ‰CIFIQUES (Ã¢ge exact, race spÃ©cifique, conditions actuelles)

Exemples BONS de questions ciblÃ©es :
- "Quelle race/souche exacte Ã©levez-vous ?" (si non spÃ©cifiÃ©)
- "Quel est leur Ã¢ge actuel en jours ?" (si Ã¢ge manquant)
- "Quels symptÃ´mes spÃ©cifiques observez-vous ?" (pour problÃ¨mes de santÃ©)
- "Quelles sont les conditions actuelles de logement ?" (pour problÃ¨mes environnementaux)

RÃ©ponds dans ce format JSON :
{{
  "clarification_questions": [
    "Question 1",
    "Question 2",
    "Question 3"
  ]
}}"""

# =============================================================================
# FONCTIONS UTILITAIRES CONSERVÃ‰ES AVEC AMÃ‰LIORATIONS PYDANTIC
# =============================================================================

def extract_context_from_entities(extracted_entities: Dict[str, Any]) -> Dict[str, str]:
    """
    ğŸ” EXTRACTION - Extrait le contexte depuis les entitÃ©s avec validation Pydantic
    
    Args:
        extracted_entities: Dictionnaire d'entitÃ©s extraites
        
    Returns:
        Dict[str, str]: Contexte formatÃ© pour le prompt
    """
    
    # Initialiser avec les valeurs par dÃ©faut
    base_context = {
        "breed": "non spÃ©cifiÃ©e",
        "sex": "non spÃ©cifiÃ©", 
        "age": "non spÃ©cifiÃ©",
        "lang": "fr",
        "topic": None
    }
    
    if not extracted_entities or not isinstance(extracted_entities, dict):
        logger.warning("âš ï¸ [Context Extraction] EntitÃ©s manquantes ou invalides")
        return base_context
    
    try:
        # Extraire et valider avec Pydantic
        context_data = base_context.copy()
        
        # Breed/Race
        if "breed" in extracted_entities and extracted_entities["breed"]:
            breed_value = extracted_entities["breed"]
            if breed_value and str(breed_value).strip():
                context_data["breed"] = str(breed_value).strip()
        
        # Sex/Sexe  
        if "sex" in extracted_entities and extracted_entities["sex"]:
            sex_value = extracted_entities["sex"]
            if sex_value and str(sex_value).strip():
                context_data["sex"] = str(sex_value).strip()
        
        # Age/Ã‚ge - formats multiples
        age_candidates = ["age", "days", "weeks", "jours", "semaines"]
        for candidate in age_candidates:
            if candidate in extracted_entities and extracted_entities[candidate]:
                age_value = extracted_entities[candidate]
                try:
                    if isinstance(age_value, (int, float)) and age_value > 0:
                        if candidate in ["weeks", "semaines"]:
                            context_data["age"] = f"{age_value} semaine{'s' if age_value > 1 else ''}"
                        else:
                            context_data["age"] = f"{age_value} jour{'s' if age_value > 1 else ''}"
                    elif age_value and str(age_value).strip():
                        context_data["age"] = str(age_value).strip()
                    break
                except (TypeError, ValueError) as e:
                    logger.warning(f"âš ï¸ [Context Extraction] Erreur conversion Ã¢ge {age_value}: {e}")
                    continue
        
        # Langue
        if "language" in extracted_entities and extracted_entities["language"]:
            lang_value = extracted_entities["language"]
            if lang_value and str(lang_value).strip().lower() in ["fr", "en", "es"]:
                context_data["lang"] = str(lang_value).strip().lower()
        
        # Topic si disponible
        if "topic" in extracted_entities and extracted_entities["topic"]:
            topic_value = extracted_entities["topic"]
            if topic_value and isinstance(topic_value, str):
                # Mapper vers TopicEnum si possible
                topic_mapping = {
                    "health": "health",
                    "nutrition": "nutrition", 
                    "performance": "performance",
                    "housing": "housing",
                    "management": "management",
                    "reproduction": "reproduction"
                }
                mapped_topic = topic_mapping.get(topic_value.lower(), "general")
                context_data["topic"] = mapped_topic
        
        # Validation finale avec Pydantic
        try:
            validated_context = PromptContext(**context_data)
            result = {
                "breed": validated_context.breed,
                "sex": validated_context.sex,
                "age": validated_context.age,
                "lang": validated_context.lang.value,
                "topic": validated_context.topic.value if validated_context.topic else None
            }
        except ValidationError as e:
            logger.warning(f"âš ï¸ [Context Extraction] Validation Pydantic Ã©chouÃ©e: {e}")
            result = base_context
        
    except Exception as e:
        logger.error(f"âŒ [Context Extraction] Erreur extraction contexte: {e}")
        result = base_context
    
    logger.info(f"ğŸ” [Prompt Context] Contexte extrait et validÃ©: {result}")
    
    return result

# =============================================================================
# LOGGING ET CONFIGURATION
# =============================================================================

logger.info("âœ… [Prompt Templates] Templates de prompts VERSION 3.0 - Validation Pydantic + Injection dynamique")
logger.info("ğŸ¯ [Prompt Templates] FonctionnalitÃ©s disponibles:")
logger.info("   - ğŸ‡«ğŸ‡· Prompts franÃ§ais optimisÃ©s")
logger.info("   - ğŸ‡¬ğŸ‡§ Prompts anglais optimisÃ©s") 
logger.info("   - ğŸ‡ªğŸ‡¸ Prompts espagnols optimisÃ©s")
logger.info("   - ğŸ¯ Prompts pour questions floues")
logger.info("   - ğŸ” Extraction contexte depuis entitÃ©s")
logger.info("   - âœ… Validation qualitÃ© contexte")
logger.info("ğŸ†• [Prompt Templates] NOUVEAUX MODÃˆLES PYDANTIC:")
logger.info("   - ğŸ“‹ ClarificationQuestion - Validation stricte des questions")
logger.info("   - ğŸ·ï¸ GPTClarificationResponse - Format de rÃ©ponse strict")
logger.info("   - ğŸ“Š ParsedGPTResponse - RÃ©sultat de parsing dÃ©taillÃ©")
logger.info("   - ğŸ¯ PromptContext - Contexte validÃ© avec Ã©numÃ©rations")
logger.info("   - ğŸŒ LanguageEnum & TopicEnum - Types stricts")
logger.info("ğŸ”§ [Prompt Templates] VALIDATION PYDANTIC INTÃ‰GRÃ‰E:")
logger.info("   - âœ… Validation automatique des rÃ©ponses JSON de GPT")
logger.info("   - ğŸ›¡ï¸ Types stricts avec Ã©numÃ©rations pour langues et topics")
logger.info("   - ğŸ“ Validation des questions (longueur, format, contenu)")
logger.info("   - ğŸš« Rejet automatique des questions gÃ©nÃ©riques")
logger.info("   - ğŸ”„ Fallback intelligent avec rÃ©cupÃ©ration partielle")
logger.info("ğŸ†• [Prompt Templates] INJECTION DYNAMIQUE DE TOPIC:")
logger.info("   - ğŸ­ Topic injectÃ© automatiquement dans prompts gÃ©nÃ©riques")
logger.info("   - ğŸ¯ Adaptation contextuelle automatique des questions")
logger.info("   - ğŸ“Š Enrichissement intelligent du contexte")
logger.info("   - ğŸ”„ Passage fluide gÃ©nÃ©rique â†’ spÃ©cialisÃ©")
logger.info("ğŸ”§ [Prompt Templates] AMÃ‰LIORATIONS APPLIQUÃ‰ES:")
logger.info("   - âœ… ContrÃ´le explicite du format JSON via Pydantic")
logger.info("   - âœ… Injection dynamique du topic dans prompts gÃ©nÃ©riques")
logger.info("   - âœ… Validation stricte des types avec enums")
logger.info("   - âœ… Gestion d'erreurs renforcÃ©e avec rÃ©cupÃ©ration")
logger.info("   - âœ… Documentation des modÃ¨les de donnÃ©es")
logger.info("   - âœ… Logging dÃ©taillÃ© des validations")
logger.info("âœ¨ [Prompt Templates] RÃ‰SULTAT: Robustesse maximale + FlexibilitÃ© contextuelle")
logger.info("ğŸš€ [Prompt Templates] STATUT: Version 3.0 - Production Ready avec Pydantic")