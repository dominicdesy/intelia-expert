"""
app/api/v1/prompt_templates.py - TEMPLATES DE PROMPTS STRUCTURÉS AVEC VALIDATION PYDANTIC

🎯 OBJECTIF: Centraliser et standardiser les prompts pour le système RAG
🔧 AMÉLIORATION: Éliminer les références aux documents dans les réponses
✨ QUALITÉ: Réponses plus naturelles et professionnelles
🆕 NOUVEAU: Prompt de contextualisation pour mode sémantique dynamique
🔧 NOUVEAU: Validation robuste des questions générées dynamiquement
🔧 NOUVEAU: Fallback intelligent si GPT échoue
🎯 NOUVEAU: Filtrage avancé des questions non pertinentes
🔧 MISE À JOUR: Message utilisateur neutre centralisé
🆕 NOUVELLE FONCTIONNALITÉ: Templates de clarification génériques et spécifiques

✨ AMÉLIORATIONS VERSION 3.0:
- ✅ Validation Pydantic pour les réponses JSON de GPT
- ✅ Injection dynamique du topic dans les prompts génériques
- ✅ Modèles de données strictes pour les réponses
- ✅ Validation automatique des formats JSON
- ✅ Enrichissement contextuel automatique
- ✅ Gestion d'erreurs renforcée avec types

NOUVELLES FONCTIONNALITÉS V2:
- ✅ Template générique de clarification (clarification_generic)
- ✅ Template spécifique par contexte (clarification_specific)
- ✅ Injection dynamique des CRITICAL_ENTITIES
- ✅ Templates par sujet (santé, nutrition, performance)
- ✅ Support multilingue pour tous les templates

CORRECTIONS APPORTÉES:
- ✅ Import manquant 'json' ajouté
- ✅ Gestion robuste des erreurs JSON avec fallback
- ✅ Validation du format des questions renforcée
- ✅ Gestion des exceptions lors de l'extraction du contexte
- ✅ Documentation des types de retour améliorée
- ✅ Logique de validation plus robuste
- ✅ Gestion des cas edge dans l'analyse des questions
"""

import logging
import re
import json
from typing import Dict, Any, Optional, List, Tuple, Union
from pydantic import BaseModel, Field, validator, ValidationError
from enum import Enum

# Import des entités critiques (assumé disponible)
try:
    from .clarification_entities import CRITICAL_ENTITIES
except ImportError:
    # Fallback si le module n'est pas disponible
    CRITICAL_ENTITIES = {
        "breed": {"fr": "race", "en": "breed", "es": "raza"},
        "age": {"fr": "âge", "en": "age", "es": "edad"},
        "sex": {"fr": "sexe", "en": "sex", "es": "sexo"},
        "symptoms": {"fr": "symptômes", "en": "symptoms", "es": "síntomas"},
        "housing_conditions": {"fr": "conditions d'élevage", "en": "housing conditions", "es": "condiciones de alojamiento"}
    }

logger = logging.getLogger(__name__)

# =============================================================================
# 🆕 MODÈLES PYDANTIC POUR VALIDATION STRICTE
# =============================================================================

class LanguageEnum(str, Enum):
    """Énumération des langues supportées"""
    FRENCH = "fr"
    ENGLISH = "en"
    SPANISH = "es"

class TopicEnum(str, Enum):
    """Énumération des sujets/topics supportés"""
    HEALTH = "health"
    NUTRITION = "nutrition"
    PERFORMANCE = "performance"
    HOUSING = "housing"
    MANAGEMENT = "management"
    REPRODUCTION = "reproduction"
    GENERAL = "general"

class ClarificationQuestion(BaseModel):
    """Modèle pour une question de clarification individuelle"""
    text: str = Field(..., min_length=10, max_length=300, description="Texte de la question")
    
    @validator('text')
    def validate_question_text(cls, v):
        """Valide le format et le contenu de la question"""
        if not v or not isinstance(v, str):
            raise ValueError("La question doit être une chaîne non vide")
        
        v = v.strip()
        if len(v) < 10:
            raise ValueError("La question doit contenir au moins 10 caractères")
        
        # Vérifier que c'est bien une question
        if not (v.endswith('?') or any(word in v.lower() for word in ['quel', 'what', 'qué', 'comment', 'how', 'cómo'])):
            raise ValueError("Le texte doit être une question valide")
        
        # Rejeter les questions génériques
        generic_keywords = ['exemple', 'example', 'ejemplo', 'généralement', 'generally', 'generalmente']
        if any(keyword in v.lower() for keyword in generic_keywords):
            raise ValueError("Question trop générique détectée")
        
        return v

class GPTClarificationResponse(BaseModel):
    """Modèle strict pour les réponses de clarification de GPT"""
    clarification_questions: List[ClarificationQuestion] = Field(
        ..., 
        min_items=1, 
        max_items=4, 
        description="Liste des questions de clarification"
    )
    
    @validator('clarification_questions')
    def validate_questions_list(cls, v):
        """Valide la liste des questions"""
        if not v:
            raise ValueError("Au moins une question de clarification est requise")
        
        if len(v) > 4:
            raise ValueError("Maximum 4 questions de clarification autorisées")
        
        # Vérifier l'unicité des questions
        questions_text = [q.text.lower().strip() for q in v]
        if len(questions_text) != len(set(questions_text)):
            raise ValueError("Les questions en doublon ne sont pas autorisées")
        
        return v

class ParsedGPTResponse(BaseModel):
    """Modèle pour le résultat du parsing des réponses GPT"""
    clarification_questions: List[str] = Field(default_factory=list, description="Questions extraites")
    parsing_success: bool = Field(default=False, description="Succès du parsing")
    validation_success: bool = Field(default=False, description="Succès de la validation Pydantic")
    raw_response: str = Field(default="", description="Réponse brute de GPT")
    error: Optional[str] = Field(default=None, description="Erreur rencontrée")
    validation_errors: List[str] = Field(default_factory=list, description="Erreurs de validation détaillées")

class PromptContext(BaseModel):
    """Modèle pour le contexte d'un prompt"""
    breed: str = Field(default="non spécifiée", description="Race/souche")
    sex: str = Field(default="non spécifié", description="Sexe")
    age: str = Field(default="non spécifié", description="Âge")
    lang: LanguageEnum = Field(default=LanguageEnum.FRENCH, description="Langue")
    topic: Optional[TopicEnum] = Field(default=None, description="Sujet identifié")
    
    @validator('breed', 'sex', 'age')
    def validate_context_fields(cls, v):
        """Valide les champs de contexte"""
        if v is None:
            return "non spécifié"
        return str(v).strip() if str(v).strip() else "non spécifié"

# ✅ Message utilisateur neutre centralisé
USER_NEEDS_CLARIFICATION_MSG = (
    "Votre question manque de contexte. "
    "Un expert virtuel va vous poser quelques questions pour mieux comprendre la situation. "
    "💡 Répondez simplement dans le chat avec les informations demandées."
)

# =============================================================================
# 🆕 FONCTIONS PYDANTIC DE VALIDATION ET PARSING
# =============================================================================

def validate_gpt_response_with_pydantic(response_text: str) -> ParsedGPTResponse:
    """
    🆕 NOUVEAU: Validation stricte des réponses GPT avec Pydantic
    
    Args:
        response_text: Réponse brute de GPT
        
    Returns:
        ParsedGPTResponse: Résultat de parsing et validation avec types stricts
    """
    result = ParsedGPTResponse(raw_response=response_text)
    
    if not response_text or not isinstance(response_text, str):
        result.error = "Réponse vide ou invalide"
        return result
    
    try:
        # Étape 1: Nettoyer et parser le JSON
        cleaned_response = _clean_json_response(response_text)
        
        try:
            parsed_json = json.loads(cleaned_response)
        except json.JSONDecodeError as e:
            result.error = f"Erreur parsing JSON: {str(e)}"
            # Tentative de récupération avec regex
            return _fallback_regex_parsing(response_text, result)
        
        # Étape 2: Validation Pydantic stricte
        try:
            # Préparation des données pour Pydantic
            if isinstance(parsed_json, dict) and "clarification_questions" in parsed_json:
                questions_data = parsed_json["clarification_questions"]
                
                # Convertir en format attendu par Pydantic
                if isinstance(questions_data, list):
                    pydantic_questions = []
                    for q in questions_data:
                        if isinstance(q, str):
                            pydantic_questions.append({"text": q})
                        elif isinstance(q, dict) and "text" in q:
                            pydantic_questions.append(q)
                        else:
                            result.validation_errors.append(f"Format de question invalide: {q}")
                            continue
                    
                    # Validation Pydantic
                    validated_response = GPTClarificationResponse(
                        clarification_questions=pydantic_questions
                    )
                    
                    # Extraction des questions validées
                    result.clarification_questions = [q.text for q in validated_response.clarification_questions]
                    result.parsing_success = True
                    result.validation_success = True
                    
                    logger.info(f"✅ [Pydantic Validation] Validation réussie: {len(result.clarification_questions)} questions")
                    
                else:
                    result.error = "clarification_questions doit être une liste"
                    result.validation_errors.append("Format de données invalide pour clarification_questions")
            else:
                result.error = "Structure JSON invalide - clé 'clarification_questions' manquante"
                result.validation_errors.append("Clé 'clarification_questions' manquante dans la réponse")
                
        except ValidationError as e:
            result.error = f"Erreur validation Pydantic: {str(e)}"
            result.validation_errors = [str(error) for error in e.errors()]
            logger.warning(f"⚠️ [Pydantic Validation] Échec validation: {e}")
            
            # Tentative de récupération partielle
            if isinstance(parsed_json, dict) and "clarification_questions" in parsed_json:
                questions = parsed_json["clarification_questions"]
                if isinstance(questions, list):
                    # Filtrer et nettoyer les questions qui passent une validation basique
                    valid_questions = []
                    for q in questions:
                        if isinstance(q, str) and len(q.strip()) >= 10 and ('?' in q or any(word in q.lower() for word in ['quel', 'what', 'qué'])):
                            valid_questions.append(q.strip())
                    
                    if valid_questions:
                        result.clarification_questions = valid_questions[:4]
                        result.parsing_success = True
                        logger.info(f"🔄 [Pydantic Validation] Récupération partielle: {len(valid_questions)} questions")
                        
    except Exception as e:
        result.error = f"Erreur inattendue: {str(e)}"
        logger.error(f"❌ [Pydantic Validation] Erreur validation: {e}")
        return _fallback_regex_parsing(response_text, result)
    
    return result

def _clean_json_response(response_text: str) -> str:
    """Nettoie la réponse GPT pour extraction JSON"""
    cleaned = response_text.strip()
    
    # Enlever les balises markdown
    if cleaned.startswith("```json"):
        cleaned = cleaned[7:]
    elif cleaned.startswith("```"):
        cleaned = cleaned[3:]
    
    if cleaned.endswith("```"):
        cleaned = cleaned[:-3]
    
    return cleaned.strip()

def _fallback_regex_parsing(response_text: str, result: ParsedGPTResponse) -> ParsedGPTResponse:
    """Fallback avec parsing regex si JSON/Pydantic échoue"""
    try:
        # Chercher des questions avec regex
        question_pattern = r'"([^"]*\?[^"]*)"'
        found_questions = re.findall(question_pattern, response_text)
        
        # Filtrer les questions valides
        valid_questions = []
        for q in found_questions:
            if len(q.strip()) >= 10 and not any(generic in q.lower() for generic in ['exemple', 'example', 'etc']):
                valid_questions.append(q.strip())
        
        if valid_questions:
            result.clarification_questions = valid_questions[:4]
            result.parsing_success = True
            result.error = f"Récupération par regex - validation Pydantic échouée: {result.error}"
            logger.info(f"🔄 [Regex Fallback] Récupération: {len(valid_questions)} questions")
        
    except Exception as regex_error:
        logger.error(f"❌ [Regex Fallback] Échec récupération regex: {regex_error}")
        result.error = f"Échec parsing complet: {result.error} | Regex: {str(regex_error)}"
    
    return result

# =============================================================================
# 🆕 TEMPLATES DE CLARIFICATION AVEC INJECTION DYNAMIQUE DE TOPIC
# =============================================================================

def build_clarification_generic_prompt(
    user_question: str,
    conversation_context: str,
    missing_entities: List[str],
    language: LanguageEnum = LanguageEnum.FRENCH,
    topic: Optional[TopicEnum] = None
) -> str:
    """
    🆕 NOUVEAU: Template générique de clarification avec injection dynamique du topic
    
    Args:
        user_question: Question originale de l'utilisateur
        conversation_context: Contexte de la conversation
        missing_entities: Liste des entités manquantes
        language: Langue de réponse
        topic: Sujet identifié (injection automatique si disponible)
        
    Returns:
        str: Prompt structuré pour clarification générique enrichie
    """
    
    # Validation des paramètres avec Pydantic
    try:
        context = PromptContext(
            lang=language,
            topic=topic
        )
        language = context.lang
        topic = context.topic
    except ValidationError as e:
        logger.warning(f"⚠️ [Generic Prompt] Paramètres invalides, utilisation des défauts: {e}")
        language = LanguageEnum.FRENCH
        topic = None
    
    # Validation et nettoyage des entrées
    if not isinstance(user_question, str):
        user_question = str(user_question) if user_question else "Question non spécifiée"
    
    if not isinstance(conversation_context, str):
        conversation_context = str(conversation_context) if conversation_context else "Aucun contexte"
    
    if not isinstance(missing_entities, list):
        missing_entities = []
    
    # Formatage des entités manquantes
    missing_entities_text = _format_missing_entities(missing_entities, language.value)
    
    # 🆕 INJECTION DYNAMIQUE DU TOPIC si disponible
    topic_context = ""
    if topic and topic != TopicEnum.GENERAL:
        topic_translations = {
            TopicEnum.HEALTH: {"fr": "santé animale", "en": "animal health", "es": "salud animal"},
            TopicEnum.NUTRITION: {"fr": "nutrition", "en": "nutrition", "es": "nutrición"},
            TopicEnum.PERFORMANCE: {"fr": "performance", "en": "performance", "es": "rendimiento"},
            TopicEnum.HOUSING: {"fr": "logement", "en": "housing", "es": "alojamiento"},
            TopicEnum.MANAGEMENT: {"fr": "gestion d'élevage", "en": "farm management", "es": "manejo de granja"},
            TopicEnum.REPRODUCTION: {"fr": "reproduction", "en": "reproduction", "es": "reproducción"}
        }
        
        translated_topic = topic_translations.get(topic, {}).get(language.value, topic.value)
        
        topic_context_templates = {
            "fr": f"\n\nSUJET IDENTIFIÉ : {translated_topic}\nAdaptez vos questions pour être plus spécifiques au domaine {translated_topic}.",
            "en": f"\n\nIDENTIFIED TOPIC: {translated_topic}\nAdapt your questions to be more specific to the {translated_topic} domain.",
            "es": f"\n\nTEMA IDENTIFICADO: {translated_topic}\nAdapte sus preguntas para ser más específicas al dominio {translated_topic}."
        }
        
        topic_context = topic_context_templates.get(language.value, topic_context_templates["fr"])
    
    templates = {
        "fr": f"""L'utilisateur a posé la question : "{user_question}"

Contexte de la conversation : "{conversation_context}"

Les informations critiques manquantes sont : {missing_entities_text}{topic_context}

En tant qu'expert avicole avec 20 ans d'expérience, génère 1 à 3 questions CLAIRES et DIRECTES pour obtenir ces informations manquantes.

RÈGLES CRITIQUES :
- Questions courtes et précises
- Pas d'exemples génériques
- Focalise sur l'INFORMATION MANQUANTE uniquement
- Utilise un ton professionnel mais accessible
- Ne reformule PAS la question originale
- Si un sujet spécifique est identifié, utilise la terminologie appropriée

Réponds uniquement sous forme de liste de questions au format JSON :
{{
  "clarification_questions": [
    "Question 1",
    "Question 2"
  ]
}}""",

        "en": f"""The user asked the question: "{user_question}"

Conversation context: "{conversation_context}"

The critical missing information is: {missing_entities_text}{topic_context}

As a poultry expert with 20 years of experience, generate 1 to 3 CLEAR and DIRECT questions to obtain this missing information.

CRITICAL RULES:
- Short and precise questions
- No generic examples
- Focus on MISSING INFORMATION only
- Use a professional but accessible tone
- Do NOT rephrase the original question
- If a specific topic is identified, use appropriate terminology

Respond only as a list of questions in JSON format:
{{
  "clarification_questions": [
    "Question 1",
    "Question 2"
  ]
}}""",

        "es": f"""El usuario hizo la pregunta: "{user_question}"

Contexto de la conversación: "{conversation_context}"

La información crítica faltante es: {missing_entities_text}{topic_context}

Como experto avícola con 20 años de experiencia, genera 1 a 3 preguntas CLARAS y DIRECTAS para obtener esta información faltante.

REGLAS CRÍTICAS:
- Preguntas cortas y precisas
- Sin ejemplos genéricos
- Enfócate solo en la INFORMACIÓN FALTANTE
- Usa un tono profesional pero accesible
- NO reformules la pregunta original
- Si se identifica un tema específico, usa terminología apropiada

Responde solo como lista de preguntas en formato JSON:
{{
  "clarification_questions": [
    "Pregunta 1",
    "Pregunta 2"
  ]
}}"""
    }
    
    return templates.get(language.value, templates["fr"])

def build_clarification_specific_prompt(
    user_question: str,
    topic: TopicEnum,
    conversation_context: str,
    missing_entities: List[str],
    language: LanguageEnum = LanguageEnum.FRENCH
) -> str:
    """
    🆕 NOUVEAU: Template spécifique par contexte avec validation Pydantic
    
    Args:
        user_question: Question originale de l'utilisateur
        topic: Sujet identifié (validé par enum)
        conversation_context: Contexte de la conversation
        missing_entities: Liste des entités manquantes
        language: Langue de réponse (validé par enum)
        
    Returns:
        str: Prompt structuré pour clarification spécifique
    """
    
    # Validation Pydantic automatique
    try:
        context = PromptContext(
            lang=language,
            topic=topic
        )
        language = context.lang
        topic = context.topic
    except ValidationError as e:
        logger.warning(f"⚠️ [Specific Prompt] Paramètres invalides: {e}")
        language = LanguageEnum.FRENCH
        topic = TopicEnum.GENERAL
    
    # Validation et nettoyage des entrées
    if not isinstance(user_question, str):
        user_question = str(user_question) if user_question else "Question non spécifiée"
    
    if not isinstance(conversation_context, str):
        conversation_context = str(conversation_context) if conversation_context else "Aucun contexte"
    
    if not isinstance(missing_entities, list):
        missing_entities = []
    
    # Formatage des entités manquantes
    missing_entities_text = _format_missing_entities(missing_entities, language.value)
    
    # Traduction du topic avec enum sécurisé
    topic_translations = {
        TopicEnum.HEALTH: {"fr": "santé animale", "en": "animal health", "es": "salud animal"},
        TopicEnum.NUTRITION: {"fr": "nutrition", "en": "nutrition", "es": "nutrición"},
        TopicEnum.PERFORMANCE: {"fr": "performance", "en": "performance", "es": "rendimiento"},
        TopicEnum.HOUSING: {"fr": "logement", "en": "housing", "es": "alojamiento"},
        TopicEnum.MANAGEMENT: {"fr": "gestion d'élevage", "en": "farm management", "es": "manejo de granja"},
        TopicEnum.REPRODUCTION: {"fr": "reproduction", "en": "reproduction", "es": "reproducción"},
        TopicEnum.GENERAL: {"fr": "général", "en": "general", "es": "general"}
    }
    
    translated_topic = topic_translations.get(topic, {}).get(language.value, topic.value)
    
    templates = {
        "fr": f"""L'utilisateur a posé la question : "{user_question}"

Sujet identifié : {translated_topic}

Contexte de la conversation : "{conversation_context}"

Les informations critiques manquantes sont : {missing_entities_text}

En tant qu'expert avicole spécialisé en {translated_topic}, génère 1 à 3 questions ciblées pour obtenir ces informations.

INSTRUCTIONS SPÉCIALISÉES :
- Questions techniques précises pour le domaine {translated_topic}
- Utilise la terminologie professionnelle appropriée
- Focalise sur les paramètres clés de {translated_topic}
- Évite les questions générales ou vagues
- Anticipe les besoins d'un diagnostic précis

Utilise un ton professionnel et précis.

Réponds uniquement sous forme de liste de questions au format JSON :
{{
  "clarification_questions": [
    "Question 1",
    "Question 2"
  ]
}}""",

        "en": f"""The user asked the question: "{user_question}"

Identified topic: {translated_topic}

Conversation context: "{conversation_context}"

The critical missing information is: {missing_entities_text}

As a poultry expert specialized in {translated_topic}, generate 1 to 3 targeted questions to obtain this information.

SPECIALIZED INSTRUCTIONS:
- Precise technical questions for the {translated_topic} domain
- Use appropriate professional terminology
- Focus on key parameters of {translated_topic}
- Avoid general or vague questions
- Anticipate the needs for precise diagnosis

Use a professional and precise tone.

Respond only as a list of questions in JSON format:
{{
  "clarification_questions": [
    "Question 1",
    "Question 2"
  ]
}}""",

        "es": f"""El usuario hizo la pregunta: "{user_question}"

Tema identificado: {translated_topic}

Contexto de la conversación: "{conversation_context}"

La información crítica faltante es: {missing_entities_text}

Como experto avícola especializado en {translated_topic}, genera 1 a 3 preguntas dirigidas para obtener esta información.

INSTRUCCIONES ESPECIALIZADAS:
- Preguntas técnicas precisas para el dominio {translated_topic}
- Usa terminología profesional apropiada
- Enfócate en parámetros clave de {translated_topic}
- Evita preguntas generales o vagas
- Anticipa las necesidades de un diagnóstico preciso

Usa un tono profesional y preciso.

Responde solo como lista de preguntas en formato JSON:
{{
  "clarification_questions": [
    "Pregunta 1",
    "Pregunta 2"
  ]
}}"""
    }
    
    return templates.get(language.value, templates["fr"])

def _format_missing_entities(missing_entities: List[str], language: str) -> str:
    """
    🔧 UTILITAIRE: Formate les entités manquantes pour injection dans les prompts
    
    Args:
        missing_entities: Liste des entités manquantes
        language: Langue pour la traduction
        
    Returns:
        str: Texte formaté des entités manquantes
    """
    
    if not missing_entities:
        return {
            "fr": "aucune information spécifique",
            "en": "no specific information",
            "es": "ninguna información específica"
        }.get(language, "aucune information spécifique")
    
    # Traduire les entités vers la langue cible
    translated_entities = []
    for entity in missing_entities:
        if entity in CRITICAL_ENTITIES:
            translated = CRITICAL_ENTITIES[entity].get(language, entity)
            translated_entities.append(translated)
        else:
            translated_entities.append(entity)
    
    # Formatage par langue
    if language == "en":
        if len(translated_entities) == 1:
            return translated_entities[0]
        elif len(translated_entities) == 2:
            return f"{translated_entities[0]} and {translated_entities[1]}"
        else:
            return ", ".join(translated_entities[:-1]) + f", and {translated_entities[-1]}"
    
    elif language == "es":
        if len(translated_entities) == 1:
            return translated_entities[0]
        elif len(translated_entities) == 2:
            return f"{translated_entities[0]} y {translated_entities[1]}"
        else:
            return ", ".join(translated_entities[:-1]) + f" y {translated_entities[-1]}"
    
    else:  # français
        if len(translated_entities) == 1:
            return translated_entities[0]
        elif len(translated_entities) == 2:
            return f"{translated_entities[0]} et {translated_entities[1]}"
        else:
            return ", ".join(translated_entities[:-1]) + f" et {translated_entities[-1]}"

# =============================================================================
# TEMPLATES EXISTANTS (CONSERVÉS ET AMÉLIORÉS AVEC VALIDATION PYDANTIC)
# =============================================================================

def build_structured_prompt(documents: str, question: str, context: Dict[str, Any]) -> str:
    """
    🎯 PROMPT PRINCIPAL - Construit un prompt structuré pour le RAG avec validation
    
    Args:
        documents: Contenu des documents trouvés
        question: Question de l'utilisateur
        context: Contexte extrait (breed, sex, age, lang, topic)
        
    Returns:
        str: Prompt structuré pour le LLM
    """
    
    # Validation avec Pydantic
    try:
        validated_context = PromptContext(**context)
    except ValidationError as e:
        logger.warning(f"⚠️ [Structured Prompt] Contexte invalide, utilisation des défauts: {e}")
        validated_context = PromptContext()
    
    # Sécurisation des paramètres
    if not isinstance(documents, str):
        documents = str(documents) if documents else ""
    if not isinstance(question, str):
        question = str(question) if question else ""
    
    # Utilisation des valeurs validées
    breed = validated_context.breed
    sex = validated_context.sex
    age = validated_context.age
    language = validated_context.lang
    
    try:
        if language == LanguageEnum.ENGLISH:
            return _build_english_prompt(documents, question, breed, sex, age)
        elif language == LanguageEnum.SPANISH:
            return _build_spanish_prompt(documents, question, breed, sex, age)
        else:
            return _build_french_prompt(documents, question, breed, sex, age)
    except Exception as e:
        logger.error(f"❌ [Prompt Build] Erreur construction prompt: {e}")
        return _build_french_prompt(documents, question, breed, sex, age)

def _build_french_prompt(documents: str, question: str, breed: str, sex: str, age: str) -> str:
    """Template français optimisé avec validation"""
    
    # Sécurisation des paramètres
    documents = str(documents) if documents else "Aucune information technique disponible"
    question = str(question) if question else "Question non spécifiée"
    breed = str(breed) if breed else "non spécifiée"
    sex = str(sex) if sex else "non spécifié"
    age = str(age) if age else "non spécifié"
    
    return f"""Vous êtes un expert en production avicole avec 20 ans d'expérience terrain.

CONTEXTE SPÉCIFIQUE :
- Race/souche : {breed}
- Sexe : {sex}
- Âge : {age}

INFORMATIONS TECHNIQUES DISPONIBLES :
{documents}

QUESTION À TRAITER :
{question}

INSTRUCTIONS CRITIQUES :
1. Répondez comme un expert qui maîtrise parfaitement ces informations techniques
2. NE mentionnez JAMAIS les termes "document", "source", "référence" ou "selon"
3. Intégrez naturellement les données chiffrées et recommandations techniques
4. Si l'information est incomplète, demandez des précisions spécifiques
5. Utilisez un ton professionnel mais accessible
6. Incluez toujours les données de performance pertinentes (poids, FCR, mortalité, etc.)
7. Donnez des fourchettes de valeurs quand approprié (ex: 410-450g)

RÉPONSE EXPERTE :"""

def _build_english_prompt(documents: str, question: str, breed: str, sex: str, age: str) -> str:
    """Template anglais optimisé avec validation"""
    
    documents = str(documents) if documents else "No technical information available"
    question = str(question) if question else "Question not specified"
    breed = str(breed) if breed else "not specified"
    sex = str(sex) if sex else "not specified"
    age = str(age) if age else "not specified"
    
    return f"""You are a poultry production expert with 20 years of field experience.

SPECIFIC CONTEXT:
- Breed/strain: {breed}
- Sex: {sex}
- Age: {age}

TECHNICAL INFORMATION AVAILABLE:
{documents}

QUESTION TO ADDRESS:
{question}

CRITICAL INSTRUCTIONS:
1. Respond as an expert who perfectly masters this technical information
2. NEVER mention terms like "document", "source", "reference" or "according to"
3. Naturally integrate numerical data and technical recommendations
4. If information is incomplete, ask for specific clarifications
5. Use a professional but accessible tone
6. Always include relevant performance data (weight, FCR, mortality, etc.)
7. Provide value ranges when appropriate (e.g., 410-450g)

EXPERT RESPONSE:"""

def _build_spanish_prompt(documents: str, question: str, breed: str, sex: str, age: str) -> str:
    """Template espagnol optimisé avec validation"""
    
    documents = str(documents) if documents else "No hay información técnica disponible"
    question = str(question) if question else "Pregunta no especificada"
    breed = str(breed) if breed else "no especificada"
    sex = str(sex) if sex else "no especificado"
    age = str(age) if age else "no especificada"
    
    return f"""Usted es un experto en producción avícola con 20 años de experiencia de campo.

CONTEXTO ESPECÍFICO:
- Raza/cepa: {breed}
- Sexe: {sex}
- Edad: {age}

INFORMACIÓN TÉCNICA DISPONIBLE:
{documents}

PREGUNTA A TRATAR:
{question}

INSTRUCCIONES CRÍTICAS:
1. Responda como un experto que domina perfectamente esta información técnica
2. NUNCA mencione términos como "documento", "fuente", "referencia" o "según"
3. Integre naturalmente los datos numéricos y recomendaciones técnicas
4. Si la información está incompleta, pida aclaraciones específicas
5. Use un tono profesional pero accesible
6. Incluya siempre datos de rendimiento relevantes (peso, conversión, mortalidad, etc.)
7. Proporcione rangos de valores cuando sea apropiado (ej: 410-450g)

RESPUESTA EXPERTA:"""

def build_contextualization_prompt(user_question: str, language: LanguageEnum = LanguageEnum.FRENCH) -> str:
    """
    🆕 AMÉLIORÉ: Construit un prompt pour générer des questions de clarification avec validation Pydantic
    
    Args:
        user_question: Question originale de l'utilisateur
        language: Langue de réponse (validé par enum)
        
    Returns:
        str: Prompt structuré pour GPT
        
    Raises:
        ValueError: Si la question utilisateur est vide
    """
    
    # Validation Pydantic
    try:
        context = PromptContext(lang=language)
        language = context.lang
    except ValidationError as e:
        logger.warning(f"⚠️ [Contextualization] Langue invalide: {e}")
        language = LanguageEnum.FRENCH
    
    # Validation de la question
    if not user_question or not isinstance(user_question, str):
        raise ValueError("user_question ne peut pas être vide ou None")
    
    user_question = user_question.strip()
    if not user_question:
        raise ValueError("user_question ne peut pas être une chaîne vide")
    
    if language == LanguageEnum.ENGLISH:
        return f"""You are a poultry farming expert specialized in providing practical advice.

Your task is to help another AI agent better understand the following question: "{user_question}"

Analyze the question and deduce its main theme (e.g., laying drop, mortality, temperature, feeding, etc.). Then generate between 2 and 4 **targeted and concrete** clarification questions to better understand the problem.

CRITICAL RULES:
- Do NOT propose generic examples or hypothetical scenarios
- Do NOT reformulate the question
- Do NOT answer the question
- Do NOT mention breeds or species that are not already cited by the user
- Focus on MISSING INFORMATION that would help provide a precise answer
- Ask for SPECIFIC details (exact age, specific breed, current conditions)

GOOD examples of targeted questions:
- "What exact breed/strain are you raising?" (if not specified)
- "What is their current age in days?" (if age missing)
- "What specific symptoms are you observing?" (for health issues)
- "What are the current housing conditions?" (for environment issues)

Respond in this JSON format:
{{
  "clarification_questions": [
    "Question 1",
    "Question 2",
    "Question 3"
  ]
}}"""

    elif language == LanguageEnum.SPANISH:
        return f"""Eres un experto en avicultura especializado en brindar asesoría práctica.

Tu tarea es ayudar a otro agente de IA a entender mejor la siguiente pregunta: "{user_question}"

Analiza la pregunta y deduce su tema principal (ej. caída de postura, mortalidad, temperatura, alimentación, etc.). Luego genera entre 2 y 4 preguntas de aclaración **dirigidas y concretas** para entender mejor el problema.

REGLAS CRÍTICAS:
- NO propongas ejemplos genéricos o escenarios hipotéticos
- NO reformules la pregunta
- NO respondas la pregunta
- NO menciones razas o especies que no hayan sido ya citadas por el usuario
- Enfócate en INFORMACIÓN FALTANTE que ayudaría a proporcionar una respuesta precisa
- Pregunta por detalles ESPECÍFICOS (edad exacta, raza específica, condiciones actuales)

Ejemplos BUENOS de preguntas dirigidas:
- "¿Qué raza/cepa exacta está criando?" (si no especificado)
- "¿Cuál es su edad actual en días?" (si falta la edad)
- "¿Qué síntomas específicos está observando?" (para problemas de salud)
- "¿Cuáles son las condiciones actuales de alojamiento?" (para problemas ambientales)

Responde en este formato JSON:
{{
  "clarification_questions": [
    "Pregunta 1",
    "Pregunta 2",
    "Pregunta 3"
  ]
}}"""

    else:  # français
        return f"""Tu es un expert en aviculture spécialisé dans les conseils pratiques.

Ta tâche est d'aider un autre agent IA à mieux comprendre la question suivante : "{user_question}"

Analyse la question et déduis son thème principal (ex. baisse de ponte, mortalité, température, alimentation, etc.). Puis génère entre 2 et 4 questions de clarification **ciblées et concrètes** pour mieux comprendre le problème.

RÈGLES CRITIQUES :
- Ne propose PAS d'exemples génériques ou de scénarios hypothétiques
- Ne reformule PAS la question
- Ne réponds PAS à la question
- Ne mentionne PAS de races ou d'espèces qui ne sont pas déjà citées par l'utilisateur
- Concentre-toi sur l'INFORMATION MANQUANTE qui aiderait à fournir une réponse précise
- Demande des détails SPÉCIFIQUES (âge exact, race spécifique, conditions actuelles)

Exemples BONS de questions ciblées :
- "Quelle race/souche exacte élevez-vous ?" (si non spécifié)
- "Quel est leur âge actuel en jours ?" (si âge manquant)
- "Quels symptômes spécifiques observez-vous ?" (pour problèmes de santé)
- "Quelles sont les conditions actuelles de logement ?" (pour problèmes environnementaux)

Réponds dans ce format JSON :
{{
  "clarification_questions": [
    "Question 1",
    "Question 2",
    "Question 3"
  ]
}}"""

# =============================================================================
# FONCTIONS UTILITAIRES CONSERVÉES AVEC AMÉLIORATIONS PYDANTIC
# =============================================================================

def extract_context_from_entities(extracted_entities: Dict[str, Any]) -> Dict[str, str]:
    """
    🔍 EXTRACTION - Extrait le contexte depuis les entités avec validation Pydantic
    
    Args:
        extracted_entities: Dictionnaire d'entités extraites
        
    Returns:
        Dict[str, str]: Contexte formaté pour le prompt
    """
    
    # Initialiser avec les valeurs par défaut
    base_context = {
        "breed": "non spécifiée",
        "sex": "non spécifié", 
        "age": "non spécifié",
        "lang": "fr",
        "topic": None
    }
    
    if not extracted_entities or not isinstance(extracted_entities, dict):
        logger.warning("⚠️ [Context Extraction] Entités manquantes ou invalides")
        return base_context
    
    try:
        # Extraire et valider avec Pydantic
        context_data = base_context.copy()
        
        # Breed/Race
        if "breed" in extracted_entities and extracted_entities["breed"]:
            breed_value = extracted_entities["breed"]
            if breed_value and str(breed_value).strip():
                context_data["breed"] = str(breed_value).strip()
        
        # Sex/Sexe  
        if "sex" in extracted_entities and extracted_entities["sex"]:
            sex_value = extracted_entities["sex"]
            if sex_value and str(sex_value).strip():
                context_data["sex"] = str(sex_value).strip()
        
        # Age/Âge - formats multiples
        age_candidates = ["age", "days", "weeks", "jours", "semaines"]
        for candidate in age_candidates:
            if candidate in extracted_entities and extracted_entities[candidate]:
                age_value = extracted_entities[candidate]
                try:
                    if isinstance(age_value, (int, float)) and age_value > 0:
                        if candidate in ["weeks", "semaines"]:
                            context_data["age"] = f"{age_value} semaine{'s' if age_value > 1 else ''}"
                        else:
                            context_data["age"] = f"{age_value} jour{'s' if age_value > 1 else ''}"
                    elif age_value and str(age_value).strip():
                        context_data["age"] = str(age_value).strip()
                    break
                except (TypeError, ValueError) as e:
                    logger.warning(f"⚠️ [Context Extraction] Erreur conversion âge {age_value}: {e}")
                    continue
        
        # Langue
        if "language" in extracted_entities and extracted_entities["language"]:
            lang_value = extracted_entities["language"]
            if lang_value and str(lang_value).strip().lower() in ["fr", "en", "es"]:
                context_data["lang"] = str(lang_value).strip().lower()
        
        # Topic si disponible
        if "topic" in extracted_entities and extracted_entities["topic"]:
            topic_value = extracted_entities["topic"]
            if topic_value and isinstance(topic_value, str):
                # Mapper vers TopicEnum si possible
                topic_mapping = {
                    "health": "health",
                    "nutrition": "nutrition", 
                    "performance": "performance",
                    "housing": "housing",
                    "management": "management",
                    "reproduction": "reproduction"
                }
                mapped_topic = topic_mapping.get(topic_value.lower(), "general")
                context_data["topic"] = mapped_topic
        
        # Validation finale avec Pydantic
        try:
            validated_context = PromptContext(**context_data)
            result = {
                "breed": validated_context.breed,
                "sex": validated_context.sex,
                "age": validated_context.age,
                "lang": validated_context.lang.value,
                "topic": validated_context.topic.value if validated_context.topic else None
            }
        except ValidationError as e:
            logger.warning(f"⚠️ [Context Extraction] Validation Pydantic échouée: {e}")
            result = base_context
        
    except Exception as e:
        logger.error(f"❌ [Context Extraction] Erreur extraction contexte: {e}")
        result = base_context
    
    logger.info(f"🔍 [Prompt Context] Contexte extrait et validé: {result}")
    
    return result

# =============================================================================
# LOGGING ET CONFIGURATION
# =============================================================================

logger.info("✅ [Prompt Templates] Templates de prompts VERSION 3.0 - Validation Pydantic + Injection dynamique")
logger.info("🎯 [Prompt Templates] Fonctionnalités disponibles:")
logger.info("   - 🇫🇷 Prompts français optimisés")
logger.info("   - 🇬🇧 Prompts anglais optimisés") 
logger.info("   - 🇪🇸 Prompts espagnols optimisés")
logger.info("   - 🎯 Prompts pour questions floues")
logger.info("   - 🔍 Extraction contexte depuis entités")
logger.info("   - ✅ Validation qualité contexte")
logger.info("🆕 [Prompt Templates] NOUVEAUX MODÈLES PYDANTIC:")
logger.info("   - 📋 ClarificationQuestion - Validation stricte des questions")
logger.info("   - 🏷️ GPTClarificationResponse - Format de réponse strict")
logger.info("   - 📊 ParsedGPTResponse - Résultat de parsing détaillé")
logger.info("   - 🎯 PromptContext - Contexte validé avec énumérations")
logger.info("   - 🌐 LanguageEnum & TopicEnum - Types stricts")
logger.info("🔧 [Prompt Templates] VALIDATION PYDANTIC INTÉGRÉE:")
logger.info("   - ✅ Validation automatique des réponses JSON de GPT")
logger.info("   - 🛡️ Types stricts avec énumérations pour langues et topics")
logger.info("   - 📝 Validation des questions (longueur, format, contenu)")
logger.info("   - 🚫 Rejet automatique des questions génériques")
logger.info("   - 🔄 Fallback intelligent avec récupération partielle")
logger.info("🆕 [Prompt Templates] INJECTION DYNAMIQUE DE TOPIC:")
logger.info("   - 🎭 Topic injecté automatiquement dans prompts génériques")
logger.info("   - 🎯 Adaptation contextuelle automatique des questions")
logger.info("   - 📊 Enrichissement intelligent du contexte")
logger.info("   - 🔄 Passage fluide générique → spécialisé")
logger.info("🔧 [Prompt Templates] AMÉLIORATIONS APPLIQUÉES:")
logger.info("   - ✅ Contrôle explicite du format JSON via Pydantic")
logger.info("   - ✅ Injection dynamique du topic dans prompts génériques")
logger.info("   - ✅ Validation stricte des types avec enums")
logger.info("   - ✅ Gestion d'erreurs renforcée avec récupération")
logger.info("   - ✅ Documentation des modèles de données")
logger.info("   - ✅ Logging détaillé des validations")
logger.info("✨ [Prompt Templates] RÉSULTAT: Robustesse maximale + Flexibilité contextuelle")
logger.info("🚀 [Prompt Templates] STATUT: Version 3.0 - Production Ready avec Pydantic")