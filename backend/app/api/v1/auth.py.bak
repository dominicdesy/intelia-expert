import os
import jwt
import logging
from typing import Optional, Dict, Any
from datetime import datetime

from fastapi import APIRouter, HTTPException, Depends, Request, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from pydantic import BaseModel, EmailStr

# Imports Supabase
try:
    from supabase import create_client, Client
    SUPABASE_AVAILABLE = True
except ImportError:
    SUPABASE_AVAILABLE = False

logger = logging.getLogger(__name__)

# Configuration
SUPABASE_URL = os.getenv('SUPABASE_URL')
SUPABASE_ANON_KEY = os.getenv('SUPABASE_ANON_KEY')
SUPABASE_JWT_SECRET = os.getenv('SUPABASE_JWT_SECRET')

# Client Supabase
supabase_client = None
if SUPABASE_AVAILABLE and SUPABASE_URL and SUPABASE_ANON_KEY:
    try:
        supabase_client = create_client(SUPABASE_URL, SUPABASE_ANON_KEY)
    except Exception as e:
        logger.error(f"Erreur Supabase: {e}")

# JWT Validation
security = HTTPBearer(auto_error=False)

def verify_jwt_token(token: str) -> Optional[Dict[str, Any]]:
    """Valide un token JWT Supabase"""
    if not SUPABASE_JWT_SECRET:
        return None
    
    try:
        payload = jwt.decode(
            token,
            SUPABASE_JWT_SECRET,
            algorithms=["HS256"],
            audience="authenticated"
        )
        return {
            "user_id": payload.get("sub"),
            "email": payload.get("email"),
            "role": payload.get("role", "authenticated")
        }
    except:
        return None

async def get_current_user(request: Request, credentials: HTTPAuthorizationCredentials = Depends(security)) -> Dict[str, Any]:
    """Dependency pour utilisateur authentifié"""
    if not credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token d'authentification requis"
        )
    
    user = verify_jwt_token(credentials.credentials)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token invalide"
        )
    
    request.state.user = user
    return user

# Modèles
class LoginRequest(BaseModel):
    email: EmailStr
    password: str

# Router
router = APIRouter(prefix="/auth")

@router.post("/login")
async def login(request: LoginRequest):
    """User login avec Supabase"""
    if not supabase_client:
        raise HTTPException(status_code=500, detail="Service d'authentification indisponible")
    
    try:
        response = supabase_client.auth.sign_in_with_password({
            "email": request.email,
            "password": request.password
        })
        
        if response.user and response.session:
            return {
                "success": True,
                "user": {
                    "id": response.user.id,
                    "email": response.user.email
                },
                "session": {
                    "access_token": response.session.access_token,
                    "refresh_token": response.session.refresh_token,
                    "expires_at": response.session.expires_at
                }
            }
        else:
            raise HTTPException(status_code=401, detail="Email ou mot de passe incorrect")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erreur login: {e}")
        raise HTTPException(status_code=401, detail="Erreur de connexion")

@router.post("/logout")
async def logout(current_user: Dict = Depends(get_current_user)):
    """User logout"""
    try:
        if supabase_client:
            supabase_client.auth.sign_out()
        return {"success": True, "message": "Déconnexion réussie"}
    except Exception as e:
        logger.error(f"Erreur logout: {e}")
        return {"success": True, "message": "Déconnexion locale réussie"}

@router.get("/profile")
async def get_profile(current_user: Dict = Depends(get_current_user)):
    """Get user profile"""
    try:
        if supabase_client:
            user_response = supabase_client.auth.get_user()
            if user_response.user:
                return {
                    "id": user_response.user.id,
                    "email": user_response.user.email,
                    "created_at": user_response.user.created_at
                }
        
        # Fallback avec données du token
        return {
            "id": current_user.get("user_id"),
            "email": current_user.get("email"),
            "created_at": "Non disponible"
        }
        
    except Exception as e:
        logger.error(f"Erreur profile: {e}")
        return {
            "id": current_user.get("user_id"),
            "email": current_user.get("email"),
            "created_at": "Non disponible"
        }

@router.post("/delete-data")
async def delete_user_data(current_user: Dict = Depends(get_current_user)):
    """Delete user data for GDPR compliance"""
    user_id = current_user.get("user_id")
    user_email = current_user.get("email")
    
    # Log pour traitement RGPD manuel
    logger.warning(f"Demande suppression RGPD: {user_email} ({user_id})")
    
    return {
        "success": True,
        "message": "Demande de suppression enregistrée",
        "note": "Vos données seront supprimées sous 30 jours",
        "timestamp": datetime.now().isoformat()
    }