"""
app/api/v1/expert_models.py - MOD√àLES PYDANTIC POUR EXPERT SYSTEM

Tous les mod√®les de donn√©es pour le syst√®me expert
VERSION AM√âLIOR√âE : Ajout des nouvelles fonctionnalit√©s API + RESPONSE_VERSIONS + SEMANTIC_DYNAMIC
üß® CORRECTION v3.6.1: Ajout du champ clarification_processing
üöÄ NOUVEAU v3.7.0: Support response_versions pour concision backend
üÜï NOUVEAU v3.9.0: Support mode s√©mantique dynamique avec DynamicClarification
"""

from typing import Optional, List, Dict, Any, Literal
from pydantic import BaseModel, Field, ConfigDict
from enum import Enum

# =============================================================================
# NOUVEAUX ENUMS POUR LES AM√âLIORATIONS + CONCISION + SEMANTIC DYNAMIC
# =============================================================================

class ResponseFormat(str, Enum):
    """Formats de r√©ponse attendus"""
    TEXT = "text"
    TABLE = "table"  
    SUMMARY = "summary"
    PLAN = "plan"
    COMPARISON = "comparison"
    NUMERICAL_DATA = "numerical_data"

class ConfidenceLevel(str, Enum):
    """Niveaux de confiance"""
    VERY_LOW = "very_low"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    VERY_HIGH = "very_high"

class QuestionClarity(str, Enum):
    """Niveaux de clart√© des questions"""
    CLEAR = "clear"
    PARTIALLY_CLEAR = "partially_clear"
    UNCLEAR = "unclear"
    VERY_UNCLEAR = "very_unclear"

# üöÄ Enum pour les niveaux de concision
class ConcisionLevel(str, Enum):
    """Niveaux de concision pour les r√©ponses"""
    ULTRA_CONCISE = "ultra_concise"  # R√©ponse minimale (ex: "350-400g")
    CONCISE = "concise"              # R√©ponse courte (1-2 phrases)
    STANDARD = "standard"            # R√©ponse √©quilibr√©e 
    DETAILED = "detailed"            # R√©ponse compl√®te et d√©taill√©e

# =============================================================================
# NOUVEAUX MOD√àLES POUR LES AM√âLIORATIONS (CONSERV√âS)
# =============================================================================

class ResponsePreferences(BaseModel):
    """Pr√©f√©rences de formatage de r√©ponse"""
    include_ranges: bool = True
    show_male_female_split: bool = False
    include_confidence_scores: bool = False
    preferred_units: Optional[str] = Field("metric", description="metric/imperial")
    detail_level: str = Field("standard", description="minimal/standard/detailed")

    model_config = ConfigDict(extra="ignore")

# üöÄ Configuration pour la concision
class ConcisionPreferences(BaseModel):
    """Pr√©f√©rences de concision pour les r√©ponses"""
    level: ConcisionLevel = Field(ConcisionLevel.CONCISE, description="Niveau de concision souhait√©")
    generate_all_versions: bool = Field(True, description="G√©n√©rer toutes les versions de concision")
    auto_detect_optimal: bool = Field(True, description="D√©tecter automatiquement le niveau optimal")
    cache_versions: bool = Field(True, description="Mettre en cache les versions g√©n√©r√©es")

    model_config = ConfigDict(extra="ignore")

# üÜï NOUVEAU: Configuration pour le mode s√©mantique dynamique
class SemanticDynamicPreferences(BaseModel):
    """Pr√©f√©rences pour le mode s√©mantique dynamique"""
    enabled: bool = Field(False, description="Activer le mode s√©mantique dynamique")
    max_questions: int = Field(4, description="Nombre maximum de questions √† g√©n√©rer")
    fallback_enabled: bool = Field(True, description="Utiliser questions de fallback si g√©n√©ration √©choue")
    context_aware: bool = Field(True, description="G√©n√©ration contextuelle intelligente")

    model_config = ConfigDict(extra="ignore")

class DocumentRelevance(BaseModel):
    """Score de pertinence d√©taill√© du document RAG"""
    score: float = Field(..., ge=0.0, le=1.0, description="Score de pertinence du document")
    source_document: Optional[str] = Field(None, description="Nom du document source")
    matched_section: Optional[str] = Field(None, description="Section correspondante")
    confidence_level: ConfidenceLevel = Field(ConfidenceLevel.MEDIUM, description="Niveau de confiance")
    chunk_used: Optional[str] = Field(None, description="Extrait utilis√© pour la r√©ponse")
    alternative_documents: Optional[List[str]] = Field(None, description="Documents alternatifs consid√©r√©s")
    search_query_used: Optional[str] = Field(None, description="Requ√™te de recherche utilis√©e")

    model_config = ConfigDict(extra="ignore")

class ContextCoherence(BaseModel):
    """V√©rification de coh√©rence entre contexte et RAG"""
    entities_match: bool = Field(..., description="Les entit√©s contextuelles correspondent au RAG")
    missing_critical_info: List[str] = Field(default_factory=list, description="Informations critiques manquantes")
    rag_assumptions: Dict[str, str] = Field(default_factory=dict, description="Hypoth√®ses faites par le RAG")
    coherence_score: float = Field(..., ge=0.0, le=1.0, description="Score de coh√©rence global")
    warnings: List[str] = Field(default_factory=list, description="Alertes de coh√©rence")
    recommended_clarification: Optional[str] = Field(None, description="Clarification recommand√©e")
    entities_used_in_rag: Dict[str, Any] = Field(default_factory=dict, description="Entit√©s utilis√©es par le RAG")

    model_config = ConfigDict(extra="ignore")

class VaguenessDetection(BaseModel):
    """D√©tection de questions floues ou impr√©cises"""
    is_vague: bool = Field(..., description="La question est-elle floue")
    vagueness_score: float = Field(..., ge=0.0, le=1.0, description="Score de flou (1.0 = tr√®s flou)")
    missing_specifics: List[str] = Field(default_factory=list, description="√âl√©ments manquants")
    question_clarity: QuestionClarity = Field(QuestionClarity.UNCLEAR, description="Niveau de clart√©")
    suggested_clarification: Optional[str] = Field(None, description="Clarification sugg√©r√©e")
    actionable: bool = Field(True, description="La question peut-elle recevoir une r√©ponse actionnable")
    detected_patterns: List[str] = Field(default_factory=list, description="Patterns de flou d√©tect√©s")

    model_config = ConfigDict(extra="ignore")

class EnhancedFallbackDetails(BaseModel):
    """D√©tails enrichis pour les fallbacks"""
    failure_point: str = Field(..., description="Point d'√©chec dans le pipeline")
    last_known_entities: Dict[str, Any] = Field(default_factory=dict, description="Derni√®res entit√©s extraites")
    confidence_at_failure: float = Field(..., ge=0.0, le=1.0, description="Confiance au moment de l'√©chec")
    rag_attempts: List[str] = Field(default_factory=list, description="Tentatives RAG effectu√©es")
    error_category: str = Field("unknown", description="Cat√©gorie d'erreur")
    recovery_suggestions: List[str] = Field(default_factory=list, description="Suggestions de r√©cup√©ration")
    alternative_approaches: List[str] = Field(default_factory=list, description="Approches alternatives")
    technical_details: Optional[str] = Field(None, description="D√©tails techniques de l'erreur")

    model_config = ConfigDict(extra="ignore")

class QualityMetrics(BaseModel):
    """M√©triques de qualit√© d√©taill√©es"""
    response_completeness: float = Field(..., ge=0.0, le=1.0, description="Compl√©tude de la r√©ponse")
    information_accuracy: float = Field(..., ge=0.0, le=1.0, description="Pr√©cision des informations")
    contextual_relevance: float = Field(..., ge=0.0, le=1.0, description="Pertinence contextuelle")
    user_satisfaction_prediction: float = Field(..., ge=0.0, le=1.0, description="Pr√©diction de satisfaction")
    response_length_appropriateness: float = Field(..., ge=0.0, le=1.0, description="Pertinence de la longueur")
    technical_accuracy: Optional[float] = Field(None, ge=0.0, le=1.0, description="Pr√©cision technique")

    model_config = ConfigDict(extra="ignore")

# üöÄ M√©triques sp√©cifiques √† la concision
class ConcisionMetrics(BaseModel):
    """M√©triques pour √©valuer la qualit√© des versions de concision"""
    generation_time_ms: int = Field(..., description="Temps de g√©n√©ration des versions en ms")
    versions_generated: int = Field(..., description="Nombre de versions g√©n√©r√©es")
    cache_hit: bool = Field(False, description="Versions r√©cup√©r√©es depuis le cache")
    fallback_used: bool = Field(False, description="Fallback utilis√© pour certaines versions")
    compression_ratios: Dict[str, float] = Field(default_factory=dict, description="Ratios de compression par version")
    quality_scores: Dict[str, float] = Field(default_factory=dict, description="Scores de qualit√© par version")

    model_config = ConfigDict(extra="ignore")

# üÜï NOUVEAU: Mod√®le pour clarification s√©mantique dynamique
class DynamicClarification(BaseModel):
    """Clarification g√©n√©r√©e dynamiquement via mode s√©mantique"""
    original_question: str = Field(..., description="Question originale de l'utilisateur")
    clarification_questions: List[str] = Field(..., description="Questions de clarification g√©n√©r√©es")
    confidence: float = Field(0.9, ge=0.0, le=1.0, description="Confiance dans la g√©n√©ration")
    generation_method: str = Field("gpt_semantic", description="M√©thode de g√©n√©ration utilis√©e")
    generation_time_ms: Optional[int] = Field(None, description="Temps de g√©n√©ration en ms")
    fallback_used: bool = Field(False, description="Questions de fallback utilis√©es")

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# MOD√àLES DE REQU√äTE AM√âLIOR√âS AVEC CONCISION + SEMANTIC DYNAMIC
# =============================================================================

class EnhancedQuestionRequest(BaseModel):
    """Request model am√©lior√© avec nouvelles fonctionnalit√©s + concision + semantic dynamic"""
    text: str = Field(..., min_length=1, max_length=5000)
    language: Optional[str] = Field("fr", description="Response language")
    speed_mode: Optional[str] = Field("balanced", description="Speed mode")
    
    # Contexte conversationnel (existant)
    conversation_id: Optional[str] = Field(None, description="Conversation ID")
    user_id: Optional[str] = Field(None, description="User ID")
    
    # Champs pour clarification (existant)
    is_clarification_response: Optional[bool] = Field(False, description="Is this a response to clarification?")
    original_question: Optional[str] = Field(None, description="Original question if this is clarification response")
    clarification_context: Optional[Dict[str, Any]] = Field(None, description="Clarification context")
    clarification_entities: Optional[Dict[str, str]] = Field(None, description="Entit√©s extraites (race, sexe)")
    force_reprocess: Optional[bool] = Field(False, description="Force reprocessing even if no clarification needed")

    # üöÄ Champs concision (conserv√©s)
    concision_level: Optional[ConcisionLevel] = Field(
        ConcisionLevel.CONCISE, 
        description="Niveau de concision souhait√© pour la r√©ponse principale"
    )
    generate_all_versions: Optional[bool] = Field(
        True, 
        description="G√©n√©rer toutes les versions de concision (ultra_concise, concise, standard, detailed)"
    )
    concision_preferences: Optional[ConcisionPreferences] = Field(
        default_factory=ConcisionPreferences,
        description="Pr√©f√©rences avanc√©es de concision"
    )

    # üÜï NOUVEAU: Champs mode s√©mantique dynamique
    semantic_dynamic_mode: Optional[bool] = Field(
        False,
        description="Activer le mode s√©mantique dynamique pour la clarification"
    )
    semantic_dynamic_preferences: Optional[SemanticDynamicPreferences] = Field(
        default_factory=SemanticDynamicPreferences,
        description="Pr√©f√©rences du mode s√©mantique dynamique"
    )

    # Fonctionnalit√©s existantes (conserv√©es)
    expected_response_format: Optional[ResponseFormat] = Field(ResponseFormat.TEXT, description="Format de r√©ponse attendu")
    response_preferences: Optional[ResponsePreferences] = Field(default_factory=ResponsePreferences, description="Pr√©f√©rences de r√©ponse")
    enable_vagueness_detection: bool = Field(True, description="Activer la d√©tection de questions floues")
    require_coherence_check: bool = Field(True, description="Exiger la v√©rification de coh√©rence")
    detailed_rag_scoring: bool = Field(False, description="Scoring RAG d√©taill√©")
    enable_quality_metrics: bool = Field(False, description="Activer les m√©triques de qualit√©")
    debug_mode: bool = Field(False, description="Mode debug pour d√©veloppeurs")

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_default=True,
        extra="ignore"
    )

class FeedbackRequest(BaseModel):
    """Feedback model standard"""
    rating: str = Field(..., description="Rating: positive, negative, neutral")
    comment: Optional[str] = Field(None, description="Optional comment")
    conversation_id: Optional[str] = Field(None, description="Conversation ID")
    quality_feedback: Optional[Dict[str, float]] = Field(None, description="Feedback d√©taill√© sur la qualit√©")

    model_config = ConfigDict(
        str_strip_whitespace=True,
        extra="ignore"
    )

    def model_post_init(self, __context) -> None:
        if self.rating not in ['positive', 'negative', 'neutral']:
            self.rating = 'neutral'

# =============================================================================
# MOD√àLES DE R√âPONSE AM√âLIOR√âS AVEC RESPONSE_VERSIONS + SEMANTIC DYNAMIC
# =============================================================================

class EnhancedExpertResponse(BaseModel):
    """Response model am√©lior√© avec toutes les nouvelles fonctionnalit√©s + response_versions + semantic_dynamic"""
    
    # ‚úÖ CHAMPS EXISTANTS (CONSERV√âS)
    question: str
    response: str
    conversation_id: str
    rag_used: bool
    rag_score: Optional[float] = None
    timestamp: str
    language: str
    response_time_ms: int
    mode: str
    user: Optional[str] = None
    logged: bool = False
    validation_passed: Optional[bool] = None
    validation_confidence: Optional[float] = None
    
    # üöÄ Champ principal: Toutes les versions de concision (conserv√©)
    response_versions: Optional[Dict[str, str]] = Field(
        None,
        description="Toutes les versions de concision de la r√©ponse",
        example={
            "ultra_concise": "350-400g",
            "concise": "Le poids normal est de 350-400g √† cet √¢ge.",
            "standard": "Le poids normal d'un poulet √† 20 jours est de 350-400g. Surveillez la croissance r√©guli√®rement.",
            "detailed": "Le poids normal d'un poulet Ross 308 √† 20 jours se situe entre 350-400g pour les m√¢les et 320-380g pour les femelles. Il est important de surveiller la croissance hebdomadairement et d'ajuster l'alimentation si n√©cessaire. Contactez votre v√©t√©rinaire si les √©carts d√©passent 15%."
        }
    )
    
    # üöÄ M√©triques de concision (conserv√©)
    concision_metrics: Optional[ConcisionMetrics] = Field(
        None,
        description="M√©triques d√©taill√©es sur la g√©n√©ration des versions de concision"
    )
    
    # üÜï NOUVEAU: Informations clarification s√©mantique dynamique
    dynamic_clarification: Optional[DynamicClarification] = Field(
        None,
        description="Informations sur la clarification s√©mantique dynamique g√©n√©r√©e"
    )
    
    # ‚úÖ CHAMPS EXISTANTS AM√âLIOR√âS (CONSERV√âS)
    clarification_result: Optional[Dict[str, Any]] = None
    reprocessed_after_clarification: Optional[bool] = None
    conversation_state: Optional[str] = None
    extracted_entities: Optional[Dict[str, Any]] = None
    confidence_overall: Optional[float] = None
    processing_steps: Optional[List[str]] = None
    ai_enhancements_used: Optional[List[str]] = None
    clarification_processing: Optional[Dict[str, Any]] = Field(None, description="M√©tadonn√©es traitement clarification")
    
    # ‚úÖ FONCTIONNALIT√âS EXISTANTES (CONSERV√âES)
    document_relevance: Optional[DocumentRelevance] = Field(None, description="Score de pertinence d√©taill√©")
    context_coherence: Optional[ContextCoherence] = Field(None, description="V√©rification de coh√©rence")
    vagueness_detection: Optional[VaguenessDetection] = Field(None, description="D√©tection de questions floues")
    fallback_details: Optional[EnhancedFallbackDetails] = Field(None, description="D√©tails de fallback enrichis")
    response_format_applied: Optional[str] = Field(None, description="Format appliqu√© √† la r√©ponse")
    quality_metrics: Optional[QualityMetrics] = Field(None, description="M√©triques de qualit√© d√©taill√©es")
    
    # ‚úÖ INFORMATIONS DE DEBUG (CONSERV√âES)
    debug_info: Optional[Dict[str, Any]] = Field(None, description="Informations de debug")
    rag_debug: Optional[Dict[str, Any]] = Field(None, description="Debug d√©taill√© du RAG")
    performance_breakdown: Optional[Dict[str, int]] = Field(None, description="Breakdown des temps de traitement")

    # üÜï NOUVEAU: Informations sp√©cifiques nouvelles fonctionnalit√©s
    concision_info: Optional[Dict[str, Any]] = Field(None, description="Informations syst√®me de concision")
    original_response: Optional[str] = Field(None, description="R√©ponse originale avant concision")
    taxonomy_info: Optional[Dict[str, Any]] = Field(None, description="Informations taxonomiques")
    semantic_dynamic_info: Optional[Dict[str, Any]] = Field(None, description="Informations mode s√©mantique dynamique")

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# MOD√àLES UTILITAIRES (CONSERV√âS)
# =============================================================================

class ValidationResult(BaseModel):
    """R√©sultat de validation"""
    is_valid: bool
    rejection_message: str = ""
    confidence: float = 0.0
    validation_details: Optional[Dict[str, Any]] = None

    model_config = ConfigDict(extra="ignore")

class ProcessingContext(BaseModel):
    """Contexte de traitement"""
    user_id: str
    conversation_id: str
    request_ip: str
    processing_steps: List[str] = Field(default_factory=list)
    ai_enhancements_used: List[str] = Field(default_factory=list)
    start_time: Optional[float] = None
    enhancement_flags: Dict[str, bool] = Field(default_factory=dict)

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# MOD√àLES DE STATS AM√âLIOR√âS (CONSERV√âS + SEMANTIC DYNAMIC)
# =============================================================================

class SystemStats(BaseModel):
    """Statistiques syst√®me"""
    system_available: bool
    timestamp: str
    components: Dict[str, bool]
    enhanced_capabilities: List[str]
    enhanced_endpoints: List[str]
    quality_metrics_enabled: bool = False
    debug_mode_available: bool = False
    # üöÄ Existant
    concision_system_enabled: bool = Field(True, description="Syst√®me de concision activ√©")
    # üÜï NOUVEAU
    semantic_dynamic_enabled: bool = Field(True, description="Mode s√©mantique dynamique activ√©")

    model_config = ConfigDict(extra="ignore")

class TestResult(BaseModel):
    """R√©sultat de test"""
    question: str
    conversation_id: str
    user_id: str
    timestamp: str
    components_tested: Dict[str, Any]
    test_successful: bool
    errors: List[str]
    enhancement_results: Optional[Dict[str, Any]] = None
    # üöÄ Existant
    concision_test_results: Optional[Dict[str, Any]] = Field(None, description="R√©sultats test concision")
    # üÜï NOUVEAU
    semantic_dynamic_test_results: Optional[Dict[str, Any]] = Field(None, description="R√©sultats test mode s√©mantique dynamique")

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# MOD√àLES POUR R√âPONSES SP√âCIALIS√âES (CONSERV√âS + SEMANTIC DYNAMIC)
# =============================================================================

class VaguenessResponse(BaseModel):
    """R√©ponse sp√©cialis√©e pour questions floues"""
    question: str
    response: str
    conversation_id: str
    vagueness_detection: VaguenessDetection
    suggested_improvements: List[str]
    example_questions: List[str]
    timestamp: str
    language: str
    response_time_ms: int

    model_config = ConfigDict(extra="ignore")

class CoherenceWarningResponse(BaseModel):
    """R√©ponse avec avertissements de coh√©rence"""
    original_response: str
    coherence_warnings: List[str]
    suggested_clarifications: List[str]
    confidence_impact: float
    should_ask_clarification: bool

    model_config = ConfigDict(extra="ignore")

# üöÄ Mod√®le sp√©cialis√© pour les r√©ponses avec versions multiples (conserv√©)
class ConcisionResponse(BaseModel):
    """R√©ponse sp√©cialis√©e avec focus sur les versions de concision"""
    question: str
    selected_response: str
    selected_level: ConcisionLevel
    all_versions: Dict[str, str]
    conversation_id: str
    generation_details: ConcisionMetrics
    timestamp: str
    language: str
    response_time_ms: int

    model_config = ConfigDict(extra="ignore")

# üÜï NOUVEAU: Mod√®le sp√©cialis√© pour les r√©ponses de clarification s√©mantique dynamique
class SemanticDynamicResponse(BaseModel):
    """R√©ponse sp√©cialis√©e pour clarification s√©mantique dynamique"""
    question: str
    clarification_questions: List[str]
    conversation_id: str
    dynamic_clarification: DynamicClarification
    generation_method: str
    confidence_score: float
    timestamp: str
    language: str
    response_time_ms: int

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# üÜï NOUVEAUX MOD√àLES POUR CONFIGURATION SYST√àME
# =============================================================================

class SemanticDynamicConfig(BaseModel):
    """Configuration du syst√®me s√©mantique dynamique"""
    enabled: bool = True
    max_questions: int = 4
    supported_languages: List[str] = ["fr", "en", "es"]
    gpt_model: str = "gpt-4o-mini"
    fallback_enabled: bool = True
    context_aware: bool = True
    timeout_seconds: int = 25

    model_config = ConfigDict(extra="ignore")

class TaxonomicFilteringConfig(BaseModel):
    """Configuration du filtrage taxonomique"""
    enabled: bool = True
    supported_taxonomies: List[str] = ["broiler", "layer", "swine", "dairy", "general"]
    auto_detection: bool = True
    filter_fallback: bool = True
    question_enhancement: bool = True

    model_config = ConfigDict(extra="ignore")

class EnhancedSystemConfig(BaseModel):
    """Configuration syst√®me compl√®te"""
    concision_config: Optional[Dict[str, Any]] = None
    semantic_dynamic_config: Optional[SemanticDynamicConfig] = Field(default_factory=SemanticDynamicConfig)
    taxonomic_filtering_config: Optional[TaxonomicFilteringConfig] = Field(default_factory=TaxonomicFilteringConfig)
    response_versions_enabled: bool = True
    advanced_clarification_enabled: bool = True

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# CONFIGURATION ET LOGGING
# =============================================================================

import logging
logger = logging.getLogger(__name__)

logger.info("‚úÖ [Expert Models] Mod√®les Pydantic charg√©s avec am√©liorations API + Response Versions + Semantic Dynamic")
logger.info("üÜï [Expert Models] Nouvelles fonctionnalit√©s disponibles:")
logger.info("   - üìä DocumentRelevance: Scoring RAG d√©taill√©")
logger.info("   - üîç ContextCoherence: V√©rification de coh√©rence")
logger.info("   - üéØ VaguenessDetection: D√©tection de questions floues")
logger.info("   - üîß EnhancedFallbackDetails: Fallback enrichi")
logger.info("   - üìà QualityMetrics: M√©triques de qualit√©")
logger.info("   - üêõ Debug mode: Support pour d√©veloppeurs")
logger.info("   - üß® clarification_processing: Support m√©tadonn√©es clarification v3.6.1")
logger.info("üöÄ [Expert Models] FONCTIONNALIT√âS v3.7.0 - RESPONSE VERSIONS:")
logger.info("   - üìù ConcisionLevel: 4 niveaux (ultra_concise, concise, standard, detailed)")
logger.info("   - üéõÔ∏è response_versions: Toutes les versions dans la r√©ponse")
logger.info("   - üìä ConcisionMetrics: M√©triques g√©n√©ration versions")
logger.info("   - ‚öôÔ∏è ConcisionPreferences: Configuration avanc√©e")
logger.info("   - üîÑ generate_all_versions: G√©n√©ration automatique par d√©faut")
logger.info("üÜï [Expert Models] NOUVELLES FONCTIONNALIT√âS v3.9.0 - SEMANTIC DYNAMIC:")
logger.info("   - üé≠ DynamicClarification: Mod√®le pour clarification s√©mantique dynamique")
logger.info("   - ü§ñ semantic_dynamic_mode: Param√®tre d'activation dans les requ√™tes")
logger.info("   - ‚öôÔ∏è SemanticDynamicPreferences: Configuration avanc√©e mode s√©mantique")
logger.info("   - üìä SemanticDynamicResponse: R√©ponse sp√©cialis√©e clarification dynamique")
logger.info("   - üîß SemanticDynamicConfig: Configuration syst√®me")
logger.info("   - üìà semantic_dynamic_info: Informations dans les r√©ponses")
logger.info("   - üéØ EnhancedSystemConfig: Configuration syst√®me compl√®te")
logger.info("‚ú® [Expert Models] R√âSULTAT: Support complet mode s√©mantique dynamique dans les mod√®les Pydantic!")