"""
app/api/v1/expert_models.py - MOD√àLES PYDANTIC POUR EXPERT SYSTEM

Tous les mod√®les de donn√©es pour le syst√®me expert
VERSION AM√âLIOR√âE : Ajout des nouvelles fonctionnalit√©s API + RESPONSE_VERSIONS
üß® CORRECTION v3.6.1: Ajout du champ clarification_processing
üöÄ NOUVEAU v3.7.0: Support response_versions pour concision backend
"""

from typing import Optional, List, Dict, Any, Literal
from pydantic import BaseModel, Field, ConfigDict
from enum import Enum

# =============================================================================
# NOUVEAUX ENUMS POUR LES AM√âLIORATIONS + CONCISION
# =============================================================================

class ResponseFormat(str, Enum):
    """Formats de r√©ponse attendus"""
    TEXT = "text"
    TABLE = "table"  
    SUMMARY = "summary"
    PLAN = "plan"
    COMPARISON = "comparison"
    NUMERICAL_DATA = "numerical_data"

class ConfidenceLevel(str, Enum):
    """Niveaux de confiance"""
    VERY_LOW = "very_low"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    VERY_HIGH = "very_high"

class QuestionClarity(str, Enum):
    """Niveaux de clart√© des questions"""
    CLEAR = "clear"
    PARTIALLY_CLEAR = "partially_clear"
    UNCLEAR = "unclear"
    VERY_UNCLEAR = "very_unclear"

# üöÄ NOUVEAU: Enum pour les niveaux de concision
class ConcisionLevel(str, Enum):
    """Niveaux de concision pour les r√©ponses"""
    ULTRA_CONCISE = "ultra_concise"  # R√©ponse minimale (ex: "350-400g")
    CONCISE = "concise"              # R√©ponse courte (1-2 phrases)
    STANDARD = "standard"            # R√©ponse √©quilibr√©e 
    DETAILED = "detailed"            # R√©ponse compl√®te et d√©taill√©e

# =============================================================================
# NOUVEAUX MOD√àLES POUR LES AM√âLIORATIONS (CONSERV√âS)
# =============================================================================

class ResponsePreferences(BaseModel):
    """Pr√©f√©rences de formatage de r√©ponse"""
    include_ranges: bool = True
    show_male_female_split: bool = False
    include_confidence_scores: bool = False
    preferred_units: Optional[str] = Field("metric", description="metric/imperial")
    detail_level: str = Field("standard", description="minimal/standard/detailed")

    model_config = ConfigDict(extra="ignore")

# üöÄ NOUVEAU: Configuration pour la concision
class ConcisionPreferences(BaseModel):
    """Pr√©f√©rences de concision pour les r√©ponses"""
    level: ConcisionLevel = Field(ConcisionLevel.CONCISE, description="Niveau de concision souhait√©")
    generate_all_versions: bool = Field(True, description="G√©n√©rer toutes les versions de concision")
    auto_detect_optimal: bool = Field(True, description="D√©tecter automatiquement le niveau optimal")
    cache_versions: bool = Field(True, description="Mettre en cache les versions g√©n√©r√©es")

    model_config = ConfigDict(extra="ignore")

class DocumentRelevance(BaseModel):
    """Score de pertinence d√©taill√© du document RAG"""
    score: float = Field(..., ge=0.0, le=1.0, description="Score de pertinence du document")
    source_document: Optional[str] = Field(None, description="Nom du document source")
    matched_section: Optional[str] = Field(None, description="Section correspondante")
    confidence_level: ConfidenceLevel = Field(ConfidenceLevel.MEDIUM, description="Niveau de confiance")
    chunk_used: Optional[str] = Field(None, description="Extrait utilis√© pour la r√©ponse")
    alternative_documents: Optional[List[str]] = Field(None, description="Documents alternatifs consid√©r√©s")
    search_query_used: Optional[str] = Field(None, description="Requ√™te de recherche utilis√©e")

    model_config = ConfigDict(extra="ignore")

class ContextCoherence(BaseModel):
    """V√©rification de coh√©rence entre contexte et RAG"""
    entities_match: bool = Field(..., description="Les entit√©s contextuelles correspondent au RAG")
    missing_critical_info: List[str] = Field(default_factory=list, description="Informations critiques manquantes")
    rag_assumptions: Dict[str, str] = Field(default_factory=dict, description="Hypoth√®ses faites par le RAG")
    coherence_score: float = Field(..., ge=0.0, le=1.0, description="Score de coh√©rence global")
    warnings: List[str] = Field(default_factory=list, description="Alertes de coh√©rence")
    recommended_clarification: Optional[str] = Field(None, description="Clarification recommand√©e")
    entities_used_in_rag: Dict[str, Any] = Field(default_factory=dict, description="Entit√©s utilis√©es par le RAG")

    model_config = ConfigDict(extra="ignore")

class VaguenessDetection(BaseModel):
    """D√©tection de questions floues ou impr√©cises"""
    is_vague: bool = Field(..., description="La question est-elle floue")
    vagueness_score: float = Field(..., ge=0.0, le=1.0, description="Score de flou (1.0 = tr√®s flou)")
    missing_specifics: List[str] = Field(default_factory=list, description="√âl√©ments manquants")
    question_clarity: QuestionClarity = Field(QuestionClarity.UNCLEAR, description="Niveau de clart√©")
    suggested_clarification: Optional[str] = Field(None, description="Clarification sugg√©r√©e")
    actionable: bool = Field(True, description="La question peut-elle recevoir une r√©ponse actionnable")
    detected_patterns: List[str] = Field(default_factory=list, description="Patterns de flou d√©tect√©s")

    model_config = ConfigDict(extra="ignore")

class EnhancedFallbackDetails(BaseModel):
    """D√©tails enrichis pour les fallbacks"""
    failure_point: str = Field(..., description="Point d'√©chec dans le pipeline")
    last_known_entities: Dict[str, Any] = Field(default_factory=dict, description="Derni√®res entit√©s extraites")
    confidence_at_failure: float = Field(..., ge=0.0, le=1.0, description="Confiance au moment de l'√©chec")
    rag_attempts: List[str] = Field(default_factory=list, description="Tentatives RAG effectu√©es")
    error_category: str = Field("unknown", description="Cat√©gorie d'erreur")
    recovery_suggestions: List[str] = Field(default_factory=list, description="Suggestions de r√©cup√©ration")
    alternative_approaches: List[str] = Field(default_factory=list, description="Approches alternatives")
    technical_details: Optional[str] = Field(None, description="D√©tails techniques de l'erreur")

    model_config = ConfigDict(extra="ignore")

class QualityMetrics(BaseModel):
    """M√©triques de qualit√© d√©taill√©es"""
    response_completeness: float = Field(..., ge=0.0, le=1.0, description="Compl√©tude de la r√©ponse")
    information_accuracy: float = Field(..., ge=0.0, le=1.0, description="Pr√©cision des informations")
    contextual_relevance: float = Field(..., ge=0.0, le=1.0, description="Pertinence contextuelle")
    user_satisfaction_prediction: float = Field(..., ge=0.0, le=1.0, description="Pr√©diction de satisfaction")
    response_length_appropriateness: float = Field(..., ge=0.0, le=1.0, description="Pertinence de la longueur")
    technical_accuracy: Optional[float] = Field(None, ge=0.0, le=1.0, description="Pr√©cision technique")

    model_config = ConfigDict(extra="ignore")

# üöÄ NOUVEAU: M√©triques sp√©cifiques √† la concision
class ConcisionMetrics(BaseModel):
    """M√©triques pour √©valuer la qualit√© des versions de concision"""
    generation_time_ms: int = Field(..., description="Temps de g√©n√©ration des versions en ms")
    versions_generated: int = Field(..., description="Nombre de versions g√©n√©r√©es")
    cache_hit: bool = Field(False, description="Versions r√©cup√©r√©es depuis le cache")
    fallback_used: bool = Field(False, description="Fallback utilis√© pour certaines versions")
    compression_ratios: Dict[str, float] = Field(default_factory=dict, description="Ratios de compression par version")
    quality_scores: Dict[str, float] = Field(default_factory=dict, description="Scores de qualit√© par version")

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# MOD√àLES DE REQU√äTE AM√âLIOR√âS AVEC CONCISION
# =============================================================================

class EnhancedQuestionRequest(BaseModel):
    """Request model am√©lior√© avec nouvelles fonctionnalit√©s + concision"""
    text: str = Field(..., min_length=1, max_length=5000)
    language: Optional[str] = Field("fr", description="Response language")
    speed_mode: Optional[str] = Field("balanced", description="Speed mode")
    
    # Contexte conversationnel (existant)
    conversation_id: Optional[str] = Field(None, description="Conversation ID")
    user_id: Optional[str] = Field(None, description="User ID")
    
    # Champs pour clarification (existant)
    is_clarification_response: Optional[bool] = Field(False, description="Is this a response to clarification?")
    original_question: Optional[str] = Field(None, description="Original question if this is clarification response")
    clarification_context: Optional[Dict[str, Any]] = Field(None, description="Clarification context")
    clarification_entities: Optional[Dict[str, str]] = Field(None, description="Entit√©s extraites (race, sexe)")
    force_reprocess: Optional[bool] = Field(False, description="Force reprocessing even if no clarification needed")

    # üöÄ NOUVEAUX CHAMPS CONCISION
    concision_level: Optional[ConcisionLevel] = Field(
        ConcisionLevel.CONCISE, 
        description="Niveau de concision souhait√© pour la r√©ponse principale"
    )
    generate_all_versions: Optional[bool] = Field(
        True, 
        description="G√©n√©rer toutes les versions de concision (ultra_concise, concise, standard, detailed)"
    )
    concision_preferences: Optional[ConcisionPreferences] = Field(
        default_factory=ConcisionPreferences,
        description="Pr√©f√©rences avanc√©es de concision"
    )

    # Fonctionnalit√©s existantes (conserv√©es)
    expected_response_format: Optional[ResponseFormat] = Field(ResponseFormat.TEXT, description="Format de r√©ponse attendu")
    response_preferences: Optional[ResponsePreferences] = Field(default_factory=ResponsePreferences, description="Pr√©f√©rences de r√©ponse")
    enable_vagueness_detection: bool = Field(True, description="Activer la d√©tection de questions floues")
    require_coherence_check: bool = Field(True, description="Exiger la v√©rification de coh√©rence")
    detailed_rag_scoring: bool = Field(False, description="Scoring RAG d√©taill√©")
    enable_quality_metrics: bool = Field(False, description="Activer les m√©triques de qualit√©")
    debug_mode: bool = Field(False, description="Mode debug pour d√©veloppeurs")

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_default=True,
        extra="ignore"
    )

class FeedbackRequest(BaseModel):
    """Feedback model standard"""
    rating: str = Field(..., description="Rating: positive, negative, neutral")
    comment: Optional[str] = Field(None, description="Optional comment")
    conversation_id: Optional[str] = Field(None, description="Conversation ID")
    quality_feedback: Optional[Dict[str, float]] = Field(None, description="Feedback d√©taill√© sur la qualit√©")

    model_config = ConfigDict(
        str_strip_whitespace=True,
        extra="ignore"
    )

    def model_post_init(self, __context) -> None:
        if self.rating not in ['positive', 'negative', 'neutral']:
            self.rating = 'neutral'

# =============================================================================
# MOD√àLES DE R√âPONSE AM√âLIOR√âS AVEC RESPONSE_VERSIONS
# =============================================================================

class EnhancedExpertResponse(BaseModel):
    """Response model am√©lior√© avec toutes les nouvelles fonctionnalit√©s + response_versions"""
    
    # ‚úÖ CHAMPS EXISTANTS (CONSERV√âS)
    question: str
    response: str
    conversation_id: str
    rag_used: bool
    rag_score: Optional[float] = None
    timestamp: str
    language: str
    response_time_ms: int
    mode: str
    user: Optional[str] = None
    logged: bool = False
    validation_passed: Optional[bool] = None
    validation_confidence: Optional[float] = None
    
    # üöÄ NOUVEAU CHAMP PRINCIPAL: Toutes les versions de concision
    response_versions: Optional[Dict[str, str]] = Field(
        None,
        description="Toutes les versions de concision de la r√©ponse",
        example={
            "ultra_concise": "350-400g",
            "concise": "Le poids normal est de 350-400g √† cet √¢ge.",
            "standard": "Le poids normal d'un poulet √† 20 jours est de 350-400g. Surveillez la croissance r√©guli√®rement.",
            "detailed": "Le poids normal d'un poulet Ross 308 √† 20 jours se situe entre 350-400g pour les m√¢les et 320-380g pour les femelles. Il est important de surveiller la croissance hebdomadairement et d'ajuster l'alimentation si n√©cessaire. Contactez votre v√©t√©rinaire si les √©carts d√©passent 15%."
        }
    )
    
    # üöÄ NOUVEAU: M√©triques de concision
    concision_metrics: Optional[ConcisionMetrics] = Field(
        None,
        description="M√©triques d√©taill√©es sur la g√©n√©ration des versions de concision"
    )
    
    # ‚úÖ CHAMPS EXISTANTS AM√âLIOR√âS (CONSERV√âS)
    clarification_result: Optional[Dict[str, Any]] = None
    reprocessed_after_clarification: Optional[bool] = None
    conversation_state: Optional[str] = None
    extracted_entities: Optional[Dict[str, Any]] = None
    confidence_overall: Optional[float] = None
    processing_steps: Optional[List[str]] = None
    ai_enhancements_used: Optional[List[str]] = None
    clarification_processing: Optional[Dict[str, Any]] = Field(None, description="M√©tadonn√©es traitement clarification")
    
    # ‚úÖ FONCTIONNALIT√âS EXISTANTES (CONSERV√âES)
    document_relevance: Optional[DocumentRelevance] = Field(None, description="Score de pertinence d√©taill√©")
    context_coherence: Optional[ContextCoherence] = Field(None, description="V√©rification de coh√©rence")
    vagueness_detection: Optional[VaguenessDetection] = Field(None, description="D√©tection de questions floues")
    fallback_details: Optional[EnhancedFallbackDetails] = Field(None, description="D√©tails de fallback enrichis")
    response_format_applied: Optional[str] = Field(None, description="Format appliqu√© √† la r√©ponse")
    quality_metrics: Optional[QualityMetrics] = Field(None, description="M√©triques de qualit√© d√©taill√©es")
    
    # ‚úÖ INFORMATIONS DE DEBUG (CONSERV√âES)
    debug_info: Optional[Dict[str, Any]] = Field(None, description="Informations de debug")
    rag_debug: Optional[Dict[str, Any]] = Field(None, description="Debug d√©taill√© du RAG")
    performance_breakdown: Optional[Dict[str, int]] = Field(None, description="Breakdown des temps de traitement")

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# MOD√àLES UTILITAIRES (CONSERV√âS)
# =============================================================================

class ValidationResult(BaseModel):
    """R√©sultat de validation"""
    is_valid: bool
    rejection_message: str = ""
    confidence: float = 0.0
    validation_details: Optional[Dict[str, Any]] = None

    model_config = ConfigDict(extra="ignore")

class ProcessingContext(BaseModel):
    """Contexte de traitement"""
    user_id: str
    conversation_id: str
    request_ip: str
    processing_steps: List[str] = Field(default_factory=list)
    ai_enhancements_used: List[str] = Field(default_factory=list)
    start_time: Optional[float] = None
    enhancement_flags: Dict[str, bool] = Field(default_factory=dict)

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# MOD√àLES DE STATS AM√âLIOR√âS (CONSERV√âS)
# =============================================================================

class SystemStats(BaseModel):
    """Statistiques syst√®me"""
    system_available: bool
    timestamp: str
    components: Dict[str, bool]
    enhanced_capabilities: List[str]
    enhanced_endpoints: List[str]
    quality_metrics_enabled: bool = False
    debug_mode_available: bool = False
    # üöÄ NOUVEAU
    concision_system_enabled: bool = Field(True, description="Syst√®me de concision activ√©")

    model_config = ConfigDict(extra="ignore")

class TestResult(BaseModel):
    """R√©sultat de test"""
    question: str
    conversation_id: str
    user_id: str
    timestamp: str
    components_tested: Dict[str, Any]
    test_successful: bool
    errors: List[str]
    enhancement_results: Optional[Dict[str, Any]] = None
    # üöÄ NOUVEAU
    concision_test_results: Optional[Dict[str, Any]] = Field(None, description="R√©sultats test concision")

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# MOD√àLES POUR R√âPONSES SP√âCIALIS√âES (CONSERV√âS)
# =============================================================================

class VaguenessResponse(BaseModel):
    """R√©ponse sp√©cialis√©e pour questions floues"""
    question: str
    response: str
    conversation_id: str
    vagueness_detection: VaguenessDetection
    suggested_improvements: List[str]
    example_questions: List[str]
    timestamp: str
    language: str
    response_time_ms: int

    model_config = ConfigDict(extra="ignore")

class CoherenceWarningResponse(BaseModel):
    """R√©ponse avec avertissements de coh√©rence"""
    original_response: str
    coherence_warnings: List[str]
    suggested_clarifications: List[str]
    confidence_impact: float
    should_ask_clarification: bool

    model_config = ConfigDict(extra="ignore")

# üöÄ NOUVEAU: Mod√®le sp√©cialis√© pour les r√©ponses avec versions multiples
class ConcisionResponse(BaseModel):
    """R√©ponse sp√©cialis√©e avec focus sur les versions de concision"""
    question: str
    selected_response: str
    selected_level: ConcisionLevel
    all_versions: Dict[str, str]
    conversation_id: str
    generation_details: ConcisionMetrics
    timestamp: str
    language: str
    response_time_ms: int

    model_config = ConfigDict(extra="ignore")

# =============================================================================
# CONFIGURATION ET LOGGING
# =============================================================================

import logging
logger = logging.getLogger(__name__)

logger.info("‚úÖ [Expert Models] Mod√®les Pydantic charg√©s avec am√©liorations API + Response Versions")
logger.info("üÜï [Expert Models] Nouvelles fonctionnalit√©s disponibles:")
logger.info("   - üìä DocumentRelevance: Scoring RAG d√©taill√©")
logger.info("   - üîç ContextCoherence: V√©rification de coh√©rence")
logger.info("   - üéØ VaguenessDetection: D√©tection de questions floues")
logger.info("   - üîß EnhancedFallbackDetails: Fallback enrichi")
logger.info("   - üìà QualityMetrics: M√©triques de qualit√©")
logger.info("   - üêõ Debug mode: Support pour d√©veloppeurs")
logger.info("   - üß® clarification_processing: Support m√©tadonn√©es clarification v3.6.1")
logger.info("üöÄ [Expert Models] NOUVEAU v3.7.0 - RESPONSE VERSIONS:")
logger.info("   - üìù ConcisionLevel: 4 niveaux (ultra_concise, concise, standard, detailed)")
logger.info("   - üéõÔ∏è response_versions: Toutes les versions dans la r√©ponse")
logger.info("   - üìä ConcisionMetrics: M√©triques g√©n√©ration versions")
logger.info("   - ‚öôÔ∏è ConcisionPreferences: Configuration avanc√©e")
logger.info("   - üîÑ generate_all_versions: G√©n√©ration automatique par d√©faut")