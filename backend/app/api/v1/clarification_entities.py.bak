"""
app/api/v1/clarification_entities.py - CLASSES DE DONNÉES + RECONNAISSANCE SOUCHES

Contient:
- ExtractedEntities avec normalisation souches
- ClarificationResult 
- Enums (ClarificationMode, ClarificationState)
- Utilitaires de reconnaissance
- Gestion centralisée des entités critiques
"""

import logging
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum

logger = logging.getLogger(__name__)

# ==================== CONSTANTES ENTITÉS CRITIQUES ====================

CRITICAL_ENTITIES = ["breed", "age", "sex", "symptoms", "environment", "feed"]

def is_critical_entity(entity_name: str) -> bool:
    """
    Vérifie si une entité est considérée comme critique
    
    Args:
        entity_name: Nom de l'entité à vérifier
        
    Returns:
        bool: True si l'entité est critique
    """
    return entity_name in CRITICAL_ENTITIES

class ClarificationMode(Enum):
    """Modes de clarification disponibles"""
    BATCH = "batch"
    INTERACTIVE = "interactive"
    ADAPTIVE = "adaptive"
    SEMANTIC_DYNAMIC = "semantic_dynamic"

class ClarificationState(Enum):
    """États de clarification"""
    NONE = "none"
    NEEDED = "needed"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    AWAITING_REPROCESS = "awaiting_reprocess"

@dataclass
class ExtractedEntities:
    """Entités extraites intelligemment du contexte avec reconnaissance de souches"""
    breed: Optional[str] = None
    breed_type: Optional[str] = None
    sex: Optional[str] = None
    age_days: Optional[int] = None
    age_weeks: Optional[float] = None
    weight_grams: Optional[float] = None
    mortality_rate: Optional[float] = None
    temperature: Optional[float] = None
    humidity: Optional[float] = None
    housing_type: Optional[str] = None
    feed_type: Optional[str] = None
    flock_size: Optional[int] = None
    symptoms: Optional[List[str]] = None
    duration_problem: Optional[str] = None
    previous_treatments: Optional[List[str]] = None
    
    # 🆕 NOUVEAUX CHAMPS: Métadonnées d'inférence
    sex_inferred: Optional[bool] = None  # True si sexe inféré automatiquement
    breed_normalized: Optional[bool] = None  # True si race normalisée automatiquement
    
    def to_dict(self) -> Dict[str, Any]:
        """Convertit en dictionnaire pour logs"""
        return {k: v for k, v in asdict(self).items() if v is not None}
    
    def get_missing_critical_info(self, question_type: str) -> List[str]:
        """
        Détermine les informations critiques manquantes selon le type de question
        🔧 CORRIGÉ: Logique simplifiée et plus efficace
        """
        missing = []
        
        # 🔧 FIX: Définir quelles entités sont critiques par type de question
        critical_for_question_type = self._get_critical_entities_for_question_type(question_type)
        
        # 🔧 FIX: Vérifier seulement les entités critiques pour ce type de question
        for entity in critical_for_question_type:
            if not self._has_entity_value(entity):
                missing.append(entity)
        
        return missing
    
    def _get_critical_entities_for_question_type(self, question_type: str) -> List[str]:
        """
        🔧 NOUVEAU: Retourne les entités critiques selon le type de question
        """
        base_entities = ["breed", "age"]  # Toujours critiques
        
        if question_type in ["health", "mortality", "disease"]:
            return base_entities + ["symptoms"]
        elif question_type in ["environment", "temperature", "housing"]:
            return base_entities + ["environment"]
        elif question_type in ["feeding", "nutrition"]:
            return base_entities + ["feed"]
        elif question_type in ["growth", "weight", "performance"]:
            return base_entities + ["sex"]
        else:
            return base_entities
    
    def _has_entity_value(self, entity: str) -> bool:
        """
        🔧 NOUVEAU: Vérifie si une entité a une valeur valide
        """
        if entity == "breed":
            return bool(self.breed and self.breed_type != "generic")
        elif entity == "age":
            return bool(self.age_days or self.age_weeks)
        elif entity == "sex":
            return bool(self.sex)
        elif entity == "symptoms":
            return bool(self.symptoms and len(self.symptoms) > 0)
        elif entity == "environment":
            return bool(self.temperature or self.housing_type or self.humidity)
        elif entity == "feed":
            return bool(self.feed_type)
        else:
            return False
    
    def get_critical_entities_status(self) -> Dict[str, bool]:
        """
        Retourne le statut de présence de toutes les entités critiques
        
        Returns:
            Dict[str, bool]: Mapping entité_critique -> présente
        """
        status = {}
        
        for entity in CRITICAL_ENTITIES:
            status[entity] = self._has_entity_value(entity)
        
        return status
    
    def normalize_breed_name(self, raw_breed: str) -> Tuple[str, bool]:
        """
        🆕 NOUVEAU: Normalise le nom de la souche selon les patterns connus
        🔧 CORRIGÉ: Gestion None et recherche plus précise
        
        Args:
            raw_breed: Nom brut de la souche
            
        Returns:
            Tuple[str, bool]: (nom_normalisé, a_été_normalisé)
        """
        
        # 🔧 FIX: Gestion correcte de None/empty
        if not raw_breed or not raw_breed.strip():
            return raw_breed or "", False
        
        raw_lower = raw_breed.lower().strip()
        
        # Dictionnaire de normalisation des souches
        breed_normalization = {
            # Poules pondeuses
            "lohmann": "Lohmann LSL-Lite",
            "lohmann lsl": "Lohmann LSL-Lite", 
            "lohmann lsl-lite": "Lohmann LSL-Lite",
            "lohmann lsl lite": "Lohmann LSL-Lite",
            "lsl": "Lohmann LSL-Lite",
            "lsl-lite": "Lohmann LSL-Lite",
            "lsl lite": "Lohmann LSL-Lite",
            
            "bovans": "Bovans Brown",
            "bovans brown": "Bovans Brown",
            "bovans blanc": "Bovans White",
            "bovans white": "Bovans White",
            
            "hisex": "Hisex Brown",
            "hisex brown": "Hisex Brown",
            "hisex blanc": "Hisex White",
            "hisex white": "Hisex White",
            
            "isa": "ISA Brown",
            "isa brown": "ISA Brown",
            "isa blanc": "ISA White",
            "isa white": "ISA White",
            
            "hyline": "Hyline Brown",
            "hyline brown": "Hyline Brown",
            "hyline white": "Hyline White",
            
            # Poulets de chair
            "ross": "Ross 308",
            "ross308": "Ross 308",
            "ross 308": "Ross 308",
            "ross708": "Ross 708",
            "ross 708": "Ross 708",
            "ross ap95": "Ross AP95",
            "ross pm3": "Ross PM3",
            
            "cobb": "Cobb 500",
            "cobb500": "Cobb 500",
            "cobb 500": "Cobb 500",
            "cobb700": "Cobb 700",
            "cobb 700": "Cobb 700",
            "cobb sasso": "Cobb Sasso",
            
            "hubbard": "Hubbard Flex",
            "hubbard flex": "Hubbard Flex",
            "hubbard classic": "Hubbard Classic",
            
            "arbor acres": "Arbor Acres",
            "arbor": "Arbor Acres",
            
            # Autres
            "red bro": "Red Bro",
            "redbro": "Red Bro"
        }
        
        # 🔧 FIX: Recherche exacte d'abord
        if raw_lower in breed_normalization:
            normalized = breed_normalization[raw_lower]
            logger.info(f"🔄 [Breed Normalization] '{raw_breed}' → '{normalized}' (exact match)")
            return normalized, True
        
        # 🔧 FIX: Recherche par mots-clés plus précise (ordre par longueur décroissante)
        # Pour éviter que "ross" match avant "ross 308"
        patterns_sorted = sorted(breed_normalization.keys(), key=len, reverse=True)
        
        for pattern in patterns_sorted:
            # 🔧 FIX: Recherche plus précise avec limites de mots
            if self._is_breed_pattern_match(raw_lower, pattern):
                normalized_name = breed_normalization[pattern]
                logger.info(f"🔄 [Breed Normalization] '{raw_breed}' → '{normalized_name}' (pattern match: '{pattern}')")
                return normalized_name, True
        
        # Aucune normalisation trouvée
        return raw_breed, False
    
    def _is_breed_pattern_match(self, text: str, pattern: str) -> bool:
        """
        🔧 NOUVEAU: Matching plus intelligent pour éviter les faux positifs
        """
        # Pour les patterns courts (< 4 chars), exiger match exact ou en début/fin de mot
        if len(pattern) < 4:
            import re
            # Match exact ou entouré d'espaces/début/fin
            regex_pattern = rf'\b{re.escape(pattern)}\b'
            return bool(re.search(regex_pattern, text))
        else:
            # Pour les patterns plus longs, simple substring matching
            return pattern in text
    
    def infer_sex_from_breed(self, breed: str) -> Tuple[Optional[str], bool]:
        """
        🆕 NOUVEAU: Infère automatiquement le sexe selon la souche
        🔧 CORRIGÉ: Matching plus précis pour éviter faux positifs
        
        Args:
            breed: Nom de la souche (normalisé)
            
        Returns:
            Tuple[Optional[str], bool]: (sexe_inféré, a_été_inféré)
        """
        
        if not breed or not breed.strip():
            return None, False
        
        breed_lower = breed.lower().strip()
        
        # 🔧 FIX: Lignées femelles (poules pondeuses) - matching plus précis
        female_breeds_exact = {
            "lohmann lsl-lite",
            "bovans brown", 
            "bovans white",
            "hisex brown",
            "hisex white", 
            "isa brown",
            "isa white",
            "hyline brown",
            "hyline white"
        }
        
        # 🔧 FIX: Lignées mixtes (poulets de chair) - pas d'inférence automatique
        mixed_breeds_exact = {
            "ross 308",
            "ross 708", 
            "ross ap95",
            "ross pm3",
            "cobb 500",
            "cobb 700",
            "cobb sasso",
            "hubbard flex",
            "hubbard classic",
            "arbor acres",
            "red bro"
        }
        
        # 🔧 FIX: Vérification exacte d'abord pour éviter faux positifs
        if breed_lower in female_breeds_exact:
            logger.info(f"🚺 [Sex Inference] '{breed}' → 'femelle' (lignée pondeuse - exact match)")
            return "femelle", True
        
        if breed_lower in mixed_breeds_exact:
            logger.info(f"🔄 [Sex Inference] '{breed}' → None (lignée mixte - exact match)")
            return None, False
        
        # 🔧 FIX: Recherche par substring plus intelligente
        for female_breed in female_breeds_exact:
            if self._is_breed_substring_match(breed_lower, female_breed):
                logger.info(f"🚺 [Sex Inference] '{breed}' → 'femelle' (lignée pondeuse - substring match)")
                return "femelle", True
        
        for mixed_breed in mixed_breeds_exact:
            if self._is_breed_substring_match(breed_lower, mixed_breed):
                logger.info(f"🔄 [Sex Inference] '{breed}' → None (lignée mixte - substring match)")
                return None, False
        
        # Breed non reconnu
        logger.info(f"❓ [Sex Inference] '{breed}' → None (souche non reconnue)")
        return None, False
    
    def _is_breed_substring_match(self, breed_text: str, reference_breed: str) -> bool:
        """
        🔧 NOUVEAU: Matching substring intelligent pour inférence sexe
        """
        # Extraire les mots clés principaux de la référence
        ref_keywords = reference_breed.split()
        
        # Il faut que la majorité des mots clés soient présents
        matches = sum(1 for keyword in ref_keywords if keyword in breed_text)
        return matches >= len(ref_keywords) * 0.6  # Au moins 60% des mots clés
    
    def normalize_and_infer(self):
        """
        🆕 NOUVEAU: Applique la normalisation de souche et l'inférence de sexe
        🔧 CORRIGÉ: Évite la race condition en gardant l'original
        Modifie l'objet en place
        """
        
        original_breed = self.breed  # 🔧 FIX: Conserver l'original
        
        # 1. Normaliser la souche si présente
        if self.breed:
            normalized_breed, was_normalized = self.normalize_breed_name(self.breed)
            if was_normalized:
                self.breed = normalized_breed
                self.breed_normalized = True
                self.breed_type = "specific"  # Les souches normalisées sont spécifiques
        
        # 2. 🔧 FIX: Inférer le sexe si pas déjà spécifié et si souche présente
        # Utiliser la souche normalisée si disponible, sinon l'originale
        breed_for_inference = self.breed if self.breed else original_breed
        
        if not self.sex and breed_for_inference:
            inferred_sex, was_inferred = self.infer_sex_from_breed(breed_for_inference)
            if was_inferred and inferred_sex:
                self.sex = inferred_sex
                self.sex_inferred = True
                logger.info(f"✅ [Auto Inference] Sexe inféré automatiquement: {inferred_sex} pour {breed_for_inference}")

@dataclass
class ClarificationResult:
    """Résultat de l'analyse de clarification amélioré"""
    needs_clarification: bool
    questions: Optional[List[str]] = None
    confidence_score: float = 0.0
    processing_time_ms: int = 0
    reason: Optional[str] = None
    model_used: Optional[str] = None
    extracted_entities: Optional[ExtractedEntities] = None
    question_type: Optional[str] = None
    clarification_mode: Optional[ClarificationMode] = None
    clarification_state: Optional[ClarificationState] = None
    missing_critical_info: Optional[List[str]] = None
    should_reprocess: bool = False
    original_question: Optional[str] = None
    validation_score: Optional[float] = None  # 🔧 NOUVEAU: Score de validation des questions
    validation_details: Optional[Dict[str, Any]] = None  # 🔧 NOUVEAU: Détails validation
    fallback_used: bool = False  # 🔧 NOUVEAU: Indicateur si fallback utilisé
    gpt_failed: bool = False  # 🔧 NOUVEAU: Indicateur si GPT a échoué
    
    def to_dict(self) -> Dict:
        """Convertit en dictionnaire pour les logs"""
        result = {
            "needs_clarification": self.needs_clarification,
            "questions": self.questions,
            "questions_count": len(self.questions) if self.questions else 0,
            "confidence_score": self.confidence_score,
            "processing_time_ms": self.processing_time_ms,
            "reason": self.reason,
            "model_used": self.model_used,
            "extracted_entities": self.extracted_entities.to_dict() if self.extracted_entities else None,
            "question_type": self.question_type,
            "clarification_mode": self.clarification_mode.value if self.clarification_mode else None,
            "clarification_state": self.clarification_state.value if self.clarification_state else None,
            "missing_critical_info": self.missing_critical_info,
            "should_reprocess": self.should_reprocess,
            "original_question": self.original_question,
            "validation_score": self.validation_score,
            "validation_details": self.validation_details,
            "fallback_used": self.fallback_used,
            "gpt_failed": self.gpt_failed
        }
        
        # 🔧 FIX: Retourner le dict, pas None
        return result

# ==================== FONCTIONS UTILITAIRES ====================

def normalize_breed_name(raw_breed: str) -> Tuple[str, bool]:
    """Normalise le nom d'une souche selon les patterns connus"""
    dummy_entity = ExtractedEntities()
    return dummy_entity.normalize_breed_name(raw_breed)

def infer_sex_from_breed(breed: str) -> Tuple[Optional[str], bool]:
    """Infère le sexe automatiquement selon la souche"""
    dummy_entity = ExtractedEntities()
    return dummy_entity.infer_sex_from_breed(breed)

def get_supported_breeds() -> Dict[str, List[str]]:
    """Retourne la liste des souches supportées par catégorie"""
    return {
        "laying": [
            "Lohmann LSL-Lite", "Bovans Brown", "Bovans White", 
            "Hisex Brown", "Hisex White", "ISA Brown", "ISA White",
            "Hyline Brown", "Hyline White"
        ],
        "broiler": [
            "Ross 308", "Ross 708", "Ross AP95", "Ross PM3",
            "Cobb 500", "Cobb 700", "Cobb Sasso",
            "Hubbard Flex", "Hubbard Classic", "Arbor Acres", "Red Bro"
        ]
    }

def get_critical_entities_info() -> Dict[str, str]:
    """
    Retourne des informations sur chaque entité critique
    
    Returns:
        Dict[str, str]: Mapping entité -> description
    """
    return {
        "breed": "Souche ou race des animaux (ex: Ross 308, Cobb 500)",
        "age": "Âge des animaux en jours ou semaines",
        "sex": "Sexe des animaux (mâle/femelle/mixte)",
        "symptoms": "Symptômes observés pour questions de santé",
        "environment": "Conditions environnementales (température, humidité, logement)",
        "feed": "Type d'alimentation ou formule nutritionnelle"
    }