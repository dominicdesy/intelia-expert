"""
app/api/v1/clarification_entities.py - CLASSES DE DONN√âES + RECONNAISSANCE SOUCHES

Contient:
- ExtractedEntities avec normalisation souches
- ClarificationResult 
- Enums (ClarificationMode, ClarificationState)
- Utilitaires de reconnaissance
- Gestion centralis√©e des entit√©s critiques
"""

import logging
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum

logger = logging.getLogger(__name__)

# ==================== CONSTANTES ENTIT√âS CRITIQUES ====================

CRITICAL_ENTITIES = ["breed", "age", "sex", "symptoms", "environment", "feed"]

def is_critical_entity(entity_name: str) -> bool:
    """
    V√©rifie si une entit√© est consid√©r√©e comme critique
    
    Args:
        entity_name: Nom de l'entit√© √† v√©rifier
        
    Returns:
        bool: True si l'entit√© est critique
    """
    return entity_name in CRITICAL_ENTITIES

class ClarificationMode(Enum):
    """Modes de clarification disponibles"""
    BATCH = "batch"
    INTERACTIVE = "interactive"
    ADAPTIVE = "adaptive"
    SEMANTIC_DYNAMIC = "semantic_dynamic"

class ClarificationState(Enum):
    """√âtats de clarification"""
    NONE = "none"
    NEEDED = "needed"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    AWAITING_REPROCESS = "awaiting_reprocess"

@dataclass
class ExtractedEntities:
    """Entit√©s extraites intelligemment du contexte avec reconnaissance de souches"""
    breed: Optional[str] = None
    breed_type: Optional[str] = None
    sex: Optional[str] = None
    age_days: Optional[int] = None
    age_weeks: Optional[float] = None
    weight_grams: Optional[float] = None
    mortality_rate: Optional[float] = None
    temperature: Optional[float] = None
    humidity: Optional[float] = None
    housing_type: Optional[str] = None
    feed_type: Optional[str] = None
    flock_size: Optional[int] = None
    symptoms: Optional[List[str]] = None
    duration_problem: Optional[str] = None
    previous_treatments: Optional[List[str]] = None
    
    # üÜï NOUVEAUX CHAMPS: M√©tadonn√©es d'inf√©rence
    sex_inferred: Optional[bool] = None  # True si sexe inf√©r√© automatiquement
    breed_normalized: Optional[bool] = None  # True si race normalis√©e automatiquement
    
    def to_dict(self) -> Dict[str, Any]:
        """Convertit en dictionnaire pour logs"""
        return {k: v for k, v in asdict(self).items() if v is not None}
    
    def get_missing_critical_info(self, question_type: str) -> List[str]:
        """
        D√©termine les informations critiques manquantes selon le type de question
        üîß CORRIG√â: Logique simplifi√©e et plus efficace
        """
        missing = []
        
        # üîß FIX: D√©finir quelles entit√©s sont critiques par type de question
        critical_for_question_type = self._get_critical_entities_for_question_type(question_type)
        
        # üîß FIX: V√©rifier seulement les entit√©s critiques pour ce type de question
        for entity in critical_for_question_type:
            if not self._has_entity_value(entity):
                missing.append(entity)
        
        return missing
    
    def _get_critical_entities_for_question_type(self, question_type: str) -> List[str]:
        """
        üîß NOUVEAU: Retourne les entit√©s critiques selon le type de question
        """
        base_entities = ["breed", "age"]  # Toujours critiques
        
        if question_type in ["health", "mortality", "disease"]:
            return base_entities + ["symptoms"]
        elif question_type in ["environment", "temperature", "housing"]:
            return base_entities + ["environment"]
        elif question_type in ["feeding", "nutrition"]:
            return base_entities + ["feed"]
        elif question_type in ["growth", "weight", "performance"]:
            return base_entities + ["sex"]
        else:
            return base_entities
    
    def _has_entity_value(self, entity: str) -> bool:
        """
        üîß NOUVEAU: V√©rifie si une entit√© a une valeur valide
        """
        if entity == "breed":
            return bool(self.breed and self.breed_type != "generic")
        elif entity == "age":
            return bool(self.age_days or self.age_weeks)
        elif entity == "sex":
            return bool(self.sex)
        elif entity == "symptoms":
            return bool(self.symptoms and len(self.symptoms) > 0)
        elif entity == "environment":
            return bool(self.temperature or self.housing_type or self.humidity)
        elif entity == "feed":
            return bool(self.feed_type)
        else:
            return False
    
    def get_critical_entities_status(self) -> Dict[str, bool]:
        """
        Retourne le statut de pr√©sence de toutes les entit√©s critiques
        
        Returns:
            Dict[str, bool]: Mapping entit√©_critique -> pr√©sente
        """
        status = {}
        
        for entity in CRITICAL_ENTITIES:
            status[entity] = self._has_entity_value(entity)
        
        return status
    
    def normalize_breed_name(self, raw_breed: str) -> Tuple[str, bool]:
        """
        üÜï NOUVEAU: Normalise le nom de la souche selon les patterns connus
        üîß CORRIG√â: Gestion None et recherche plus pr√©cise
        
        Args:
            raw_breed: Nom brut de la souche
            
        Returns:
            Tuple[str, bool]: (nom_normalis√©, a_√©t√©_normalis√©)
        """
        
        # üîß FIX: Gestion correcte de None/empty
        if not raw_breed or not raw_breed.strip():
            return raw_breed or "", False
        
        raw_lower = raw_breed.lower().strip()
        
        # Dictionnaire de normalisation des souches
        breed_normalization = {
            # Poules pondeuses
            "lohmann": "Lohmann LSL-Lite",
            "lohmann lsl": "Lohmann LSL-Lite", 
            "lohmann lsl-lite": "Lohmann LSL-Lite",
            "lohmann lsl lite": "Lohmann LSL-Lite",
            "lsl": "Lohmann LSL-Lite",
            "lsl-lite": "Lohmann LSL-Lite",
            "lsl lite": "Lohmann LSL-Lite",
            
            "bovans": "Bovans Brown",
            "bovans brown": "Bovans Brown",
            "bovans blanc": "Bovans White",
            "bovans white": "Bovans White",
            
            "hisex": "Hisex Brown",
            "hisex brown": "Hisex Brown",
            "hisex blanc": "Hisex White",
            "hisex white": "Hisex White",
            
            "isa": "ISA Brown",
            "isa brown": "ISA Brown",
            "isa blanc": "ISA White",
            "isa white": "ISA White",
            
            "hyline": "Hyline Brown",
            "hyline brown": "Hyline Brown",
            "hyline white": "Hyline White",
            
            # Poulets de chair
            "ross": "Ross 308",
            "ross308": "Ross 308",
            "ross 308": "Ross 308",
            "ross708": "Ross 708",
            "ross 708": "Ross 708",
            "ross ap95": "Ross AP95",
            "ross pm3": "Ross PM3",
            
            "cobb": "Cobb 500",
            "cobb500": "Cobb 500",
            "cobb 500": "Cobb 500",
            "cobb700": "Cobb 700",
            "cobb 700": "Cobb 700",
            "cobb sasso": "Cobb Sasso",
            
            "hubbard": "Hubbard Flex",
            "hubbard flex": "Hubbard Flex",
            "hubbard classic": "Hubbard Classic",
            
            "arbor acres": "Arbor Acres",
            "arbor": "Arbor Acres",
            
            # Autres
            "red bro": "Red Bro",
            "redbro": "Red Bro"
        }
        
        # üîß FIX: Recherche exacte d'abord
        if raw_lower in breed_normalization:
            normalized = breed_normalization[raw_lower]
            logger.info(f"üîÑ [Breed Normalization] '{raw_breed}' ‚Üí '{normalized}' (exact match)")
            return normalized, True
        
        # üîß FIX: Recherche par mots-cl√©s plus pr√©cise (ordre par longueur d√©croissante)
        # Pour √©viter que "ross" match avant "ross 308"
        patterns_sorted = sorted(breed_normalization.keys(), key=len, reverse=True)
        
        for pattern in patterns_sorted:
            # üîß FIX: Recherche plus pr√©cise avec limites de mots
            if self._is_breed_pattern_match(raw_lower, pattern):
                normalized_name = breed_normalization[pattern]
                logger.info(f"üîÑ [Breed Normalization] '{raw_breed}' ‚Üí '{normalized_name}' (pattern match: '{pattern}')")
                return normalized_name, True
        
        # Aucune normalisation trouv√©e
        return raw_breed, False
    
    def _is_breed_pattern_match(self, text: str, pattern: str) -> bool:
        """
        üîß NOUVEAU: Matching plus intelligent pour √©viter les faux positifs
        """
        # Pour les patterns courts (< 4 chars), exiger match exact ou en d√©but/fin de mot
        if len(pattern) < 4:
            import re
            # Match exact ou entour√© d'espaces/d√©but/fin
            regex_pattern = rf'\b{re.escape(pattern)}\b'
            return bool(re.search(regex_pattern, text))
        else:
            # Pour les patterns plus longs, simple substring matching
            return pattern in text
    
    def infer_sex_from_breed(self, breed: str) -> Tuple[Optional[str], bool]:
        """
        üÜï NOUVEAU: Inf√®re automatiquement le sexe selon la souche
        üîß CORRIG√â: Matching plus pr√©cis pour √©viter faux positifs
        
        Args:
            breed: Nom de la souche (normalis√©)
            
        Returns:
            Tuple[Optional[str], bool]: (sexe_inf√©r√©, a_√©t√©_inf√©r√©)
        """
        
        if not breed or not breed.strip():
            return None, False
        
        breed_lower = breed.lower().strip()
        
        # üîß FIX: Lign√©es femelles (poules pondeuses) - matching plus pr√©cis
        female_breeds_exact = {
            "lohmann lsl-lite",
            "bovans brown", 
            "bovans white",
            "hisex brown",
            "hisex white", 
            "isa brown",
            "isa white",
            "hyline brown",
            "hyline white"
        }
        
        # üîß FIX: Lign√©es mixtes (poulets de chair) - pas d'inf√©rence automatique
        mixed_breeds_exact = {
            "ross 308",
            "ross 708", 
            "ross ap95",
            "ross pm3",
            "cobb 500",
            "cobb 700",
            "cobb sasso",
            "hubbard flex",
            "hubbard classic",
            "arbor acres",
            "red bro"
        }
        
        # üîß FIX: V√©rification exacte d'abord pour √©viter faux positifs
        if breed_lower in female_breeds_exact:
            logger.info(f"üö∫ [Sex Inference] '{breed}' ‚Üí 'femelle' (lign√©e pondeuse - exact match)")
            return "femelle", True
        
        if breed_lower in mixed_breeds_exact:
            logger.info(f"üîÑ [Sex Inference] '{breed}' ‚Üí None (lign√©e mixte - exact match)")
            return None, False
        
        # üîß FIX: Recherche par substring plus intelligente
        for female_breed in female_breeds_exact:
            if self._is_breed_substring_match(breed_lower, female_breed):
                logger.info(f"üö∫ [Sex Inference] '{breed}' ‚Üí 'femelle' (lign√©e pondeuse - substring match)")
                return "femelle", True
        
        for mixed_breed in mixed_breeds_exact:
            if self._is_breed_substring_match(breed_lower, mixed_breed):
                logger.info(f"üîÑ [Sex Inference] '{breed}' ‚Üí None (lign√©e mixte - substring match)")
                return None, False
        
        # Breed non reconnu
        logger.info(f"‚ùì [Sex Inference] '{breed}' ‚Üí None (souche non reconnue)")
        return None, False
    
    def _is_breed_substring_match(self, breed_text: str, reference_breed: str) -> bool:
        """
        üîß NOUVEAU: Matching substring intelligent pour inf√©rence sexe
        """
        # Extraire les mots cl√©s principaux de la r√©f√©rence
        ref_keywords = reference_breed.split()
        
        # Il faut que la majorit√© des mots cl√©s soient pr√©sents
        matches = sum(1 for keyword in ref_keywords if keyword in breed_text)
        return matches >= len(ref_keywords) * 0.6  # Au moins 60% des mots cl√©s
    
    def normalize_and_infer(self):
        """
        üÜï NOUVEAU: Applique la normalisation de souche et l'inf√©rence de sexe
        üîß CORRIG√â: √âvite la race condition en gardant l'original
        Modifie l'objet en place
        """
        
        original_breed = self.breed  # üîß FIX: Conserver l'original
        
        # 1. Normaliser la souche si pr√©sente
        if self.breed:
            normalized_breed, was_normalized = self.normalize_breed_name(self.breed)
            if was_normalized:
                self.breed = normalized_breed
                self.breed_normalized = True
                self.breed_type = "specific"  # Les souches normalis√©es sont sp√©cifiques
        
        # 2. üîß FIX: Inf√©rer le sexe si pas d√©j√† sp√©cifi√© et si souche pr√©sente
        # Utiliser la souche normalis√©e si disponible, sinon l'originale
        breed_for_inference = self.breed if self.breed else original_breed
        
        if not self.sex and breed_for_inference:
            inferred_sex, was_inferred = self.infer_sex_from_breed(breed_for_inference)
            if was_inferred and inferred_sex:
                self.sex = inferred_sex
                self.sex_inferred = True
                logger.info(f"‚úÖ [Auto Inference] Sexe inf√©r√© automatiquement: {inferred_sex} pour {breed_for_inference}")

@dataclass
class ClarificationResult:
    """R√©sultat de l'analyse de clarification am√©lior√©"""
    needs_clarification: bool
    questions: Optional[List[str]] = None
    confidence_score: float = 0.0
    processing_time_ms: int = 0
    reason: Optional[str] = None
    model_used: Optional[str] = None
    extracted_entities: Optional[ExtractedEntities] = None
    question_type: Optional[str] = None
    clarification_mode: Optional[ClarificationMode] = None
    clarification_state: Optional[ClarificationState] = None
    missing_critical_info: Optional[List[str]] = None
    should_reprocess: bool = False
    original_question: Optional[str] = None
    validation_score: Optional[float] = None  # üîß NOUVEAU: Score de validation des questions
    validation_details: Optional[Dict[str, Any]] = None  # üîß NOUVEAU: D√©tails validation
    fallback_used: bool = False  # üîß NOUVEAU: Indicateur si fallback utilis√©
    gpt_failed: bool = False  # üîß NOUVEAU: Indicateur si GPT a √©chou√©
    
    def to_dict(self) -> Dict:
        """Convertit en dictionnaire pour les logs"""
        result = {
            "needs_clarification": self.needs_clarification,
            "questions": self.questions,
            "questions_count": len(self.questions) if self.questions else 0,
            "confidence_score": self.confidence_score,
            "processing_time_ms": self.processing_time_ms,
            "reason": self.reason,
            "model_used": self.model_used,
            "extracted_entities": self.extracted_entities.to_dict() if self.extracted_entities else None,
            "question_type": self.question_type,
            "clarification_mode": self.clarification_mode.value if self.clarification_mode else None,
            "clarification_state": self.clarification_state.value if self.clarification_state else None,
            "missing_critical_info": self.missing_critical_info,
            "should_reprocess": self.should_reprocess,
            "original_question": self.original_question,
            "validation_score": self.validation_score,
            "validation_details": self.validation_details,
            "fallback_used": self.fallback_used,
            "gpt_failed": self.gpt_failed
        }
        
        # üîß FIX: Retourner le dict, pas None
        return result

# ==================== FONCTIONS UTILITAIRES ====================

def normalize_breed_name(raw_breed: str) -> Tuple[str, bool]:
    """Normalise le nom d'une souche selon les patterns connus"""
    dummy_entity = ExtractedEntities()
    return dummy_entity.normalize_breed_name(raw_breed)

def infer_sex_from_breed(breed: str) -> Tuple[Optional[str], bool]:
    """Inf√®re le sexe automatiquement selon la souche"""
    dummy_entity = ExtractedEntities()
    return dummy_entity.infer_sex_from_breed(breed)

def get_supported_breeds() -> Dict[str, List[str]]:
    """Retourne la liste des souches support√©es par cat√©gorie"""
    return {
        "laying": [
            "Lohmann LSL-Lite", "Bovans Brown", "Bovans White", 
            "Hisex Brown", "Hisex White", "ISA Brown", "ISA White",
            "Hyline Brown", "Hyline White"
        ],
        "broiler": [
            "Ross 308", "Ross 708", "Ross AP95", "Ross PM3",
            "Cobb 500", "Cobb 700", "Cobb Sasso",
            "Hubbard Flex", "Hubbard Classic", "Arbor Acres", "Red Bro"
        ]
    }

def get_critical_entities_info() -> Dict[str, str]:
    """
    Retourne des informations sur chaque entit√© critique
    
    Returns:
        Dict[str, str]: Mapping entit√© -> description
    """
    return {
        "breed": "Souche ou race des animaux (ex: Ross 308, Cobb 500)",
        "age": "√Çge des animaux en jours ou semaines",
        "sex": "Sexe des animaux (m√¢le/femelle/mixte)",
        "symptoms": "Sympt√¥mes observ√©s pour questions de sant√©",
        "environment": "Conditions environnementales (temp√©rature, humidit√©, logement)",
        "feed": "Type d'alimentation ou formule nutritionnelle"
    }