# app/api/v1/conversations.py
"""
Router pour la gestion des conversations avec int√©gration PostgreSQL.
Version avec requ√™tes JSONB fiables + retour messages.
"""
from fastapi import APIRouter, HTTPException, Query
from typing import Dict, Any
import logging
import os
import json
from datetime import datetime

logger = logging.getLogger("app.api.v1.conversations")
router = APIRouter()

MEMORY_AVAILABLE = False
memory = None
try:
    from .pipeline.postgres_memory import PostgresMemory
    memory = PostgresMemory(dsn=os.getenv("DATABASE_URL"))
    MEMORY_AVAILABLE = True
    logger.info("‚úÖ PostgresMemory initialized for conversations")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è PostgresMemory import failed: {e}")
except Exception as e:
    logger.error(f"‚ùå PostgresMemory initialization failed: {e}")

conversation_tracker = None
if not MEMORY_AVAILABLE:
    try:
        from .utils.conversation_tracker import ConversationTracker
        conversation_tracker = ConversationTracker()
        logger.info("‚úÖ Fallback: ConversationTracker loaded")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è ConversationTracker unavailable: {e}")

@router.get("/health")
async def health_check() -> Dict[str, Any]:
    try:
        if MEMORY_AVAILABLE and memory:
            stats = memory.get_stats()
            return {"status":"healthy","backend":"postgresql","total_conversations":stats.get("total_sessions",0),"timestamp":datetime.utcnow().isoformat()}
        elif conversation_tracker:
            return {"status":"healthy","backend":"conversation_tracker","timestamp":datetime.utcnow().isoformat()}
        else:
            return {"status":"limited","backend":"none","message":"No conversation backend available","timestamp":datetime.utcnow().isoformat()}
    except Exception as e:
        logger.exception("‚ùå Health check failed")
        return {"status":"unhealthy","error":str(e),"timestamp":datetime.utcnow().isoformat()}

@router.get("/stats")
async def get_stats() -> Dict[str, Any]:
    try:
        if MEMORY_AVAILABLE and memory:
            stats = memory.get_stats()
            return {**stats, "service_status":"operational", "backend":"postgresql", "timestamp":datetime.utcnow().isoformat()}
        else:
            return {"total_sessions":0, "service_status":"limited", "backend":"none", "timestamp":datetime.utcnow().isoformat()}
    except Exception as e:
        logger.exception("‚ùå Error getting stats")
        return {"error":str(e), "service_status":"error", "timestamp":datetime.utcnow().isoformat()}

@router.get("/test-public")
async def test_public() -> Dict[str, Any]:
    return {"status":"success","message":"üéâ Conversations router fully functional!","router":"conversations","backend_available":MEMORY_AVAILABLE,"timestamp":datetime.utcnow().isoformat()}

@router.get("/user/{user_id}")
async def get_user_conversations(user_id: str, limit: int = Query(default=20, ge=1, le=100), offset: int = Query(default=0, ge=0)) -> Dict[str, Any]:
    try:
        logger.info(f"üìã get_user_conversations: user_id={user_id}, limit={limit}")
        if MEMORY_AVAILABLE and memory:
            try:
                import psycopg2
                with psycopg2.connect(memory.dsn) as conn:
                    with conn.cursor() as cur:
                        total_count = 0
                        sessions = []
                        # ‚úÖ Tentative JSONB fiable
                        try:
                            cur.execute("""
                                SELECT session_id, context, created_at, updated_at
                                FROM conversation_memory
                                WHERE context->>'user_id' = %s
                                ORDER BY updated_at DESC
                                LIMIT %s OFFSET %s
                            """, (user_id, limit, offset))
                            sessions = cur.fetchall()

                            cur.execute("""
                                SELECT COUNT(*) FROM conversation_memory
                                WHERE context->>'user_id' = %s
                            """, (user_id,))
                            total_count = cur.fetchone()[0]
                        except Exception as jsonb_err:
                            logger.warning(f"‚ö†Ô∏è JSONB query failed, fallback LIKE: {jsonb_err}")
                            cur.execute("""
                                SELECT session_id, context, created_at, updated_at
                                FROM conversation_memory
                                WHERE context::text LIKE %s
                                ORDER BY updated_at DESC
                                LIMIT %s OFFSET %s
                            """, (f'%{user_id}%', limit, offset))
                            sessions = cur.fetchall()
                            cur.execute("""
                                SELECT COUNT(*) FROM conversation_memory
                                WHERE context::text LIKE %s
                            """, (f'%{user_id}%',))
                            total_count = cur.fetchone()[0]

                        conversations = []
                        for session_id, context, created_at, updated_at in sessions:
                            try:
                                ctx = json.loads(context) if isinstance(context, str) else context
                                messages = ctx.get("messages", [])
                                title = f"Conversation {session_id[:8]}..."
                                preview = "Conversation utilisateur"
                                if messages:
                                    user_messages = [m for m in messages if m.get("isUser", False)]
                                    if user_messages:
                                        first = user_messages[0].get("content", "")
                                        title = first[:50] + ("..." if len(first) > 50 else "")
                                        preview = first[:100] + ("..." if len(first) > 100 else "")
                                conversations.append({
                                    "id": session_id,
                                    "title": title,
                                    "preview": preview,
                                    "message_count": len(messages),
                                    "created_at": created_at.isoformat() if created_at else datetime.utcnow().isoformat(),
                                    "updated_at": updated_at.isoformat() if updated_at else datetime.utcnow().isoformat(),
                                    "language": ctx.get("language", "fr"),
                                    "status": "active"
                                })
                            except Exception as parse_error:
                                logger.warning(f"‚ö†Ô∏è Erreur parsing session {session_id}: {parse_error}")
                                continue

                stats = memory.get_stats()
                result = {
                    "status":"success","user_id":user_id,
                    "conversations":conversations,"total_count":total_count,
                    "limit":limit,"offset":offset,"source":"postgresql",
                    "timestamp":datetime.utcnow().isoformat(),"system_stats":stats
                }
                logger.info(f"‚úÖ PostgreSQL: {total_count} conversations found for user {user_id}")
                return result

            except Exception as db_error:
                logger.error(f"‚ùå PostgreSQL error for user {user_id}: {db_error}")

        if conversation_tracker:
            try:
                conversations = conversation_tracker.get_user_conversations(user_id, limit)
                return {
                    "status":"success","user_id":user_id,"conversations":conversations,
                    "total_count":len(conversations),"limit":limit,"offset":offset,
                    "source":"conversation_tracker","timestamp":datetime.utcnow().isoformat()
                }
            except Exception as e:
                logger.error(f"‚ùå ConversationTracker error for user {user_id}: {e}")

        logger.warning(f"‚ö†Ô∏è Fallback: empty result for user {user_id}")
        return {
            "status":"success","user_id":user_id,"conversations":[],
            "total_count":0,"limit":limit,"offset":offset,"source":"fallback",
            "timestamp":datetime.utcnow().isoformat(),"message":"No conversation backend available, returning empty result"
        }

    except Exception as e:
        logger.exception(f"‚ùå Unexpected error for user {user_id}")
        raise HTTPException(status_code=500, detail=f"Error retrieving conversations for user {user_id}: {str(e)}")

@router.get("/{session_id}")
async def get_conversation(session_id: str) -> Dict[str, Any]:
    try:
        logger.info(f"üìñ get_conversation: session_id={session_id}")
        if MEMORY_AVAILABLE and memory:
            context = memory.get(session_id)
            if not context:
                return {
                    "session_id": session_id, "exists": False, "context": {},
                    "messages": [], "message_count": 0, "timestamp": datetime.utcnow().isoformat()
                }
            messages = context.get("messages", [])
            return {
                "session_id": session_id, "exists": True,
                "context": context, "messages": messages,
                "message_count": len(messages), "timestamp": datetime.utcnow().isoformat()
            }
        raise HTTPException(status_code=503, detail="Conversation service unavailable")
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"‚ùå Error retrieving conversation {session_id}")
        raise HTTPException(status_code=500, detail=f"Error retrieving conversation: {str(e)}")

@router.delete("/{session_id}")
async def delete_conversation(session_id: str) -> Dict[str, Any]:
    try:
        logger.info(f"üóëÔ∏è delete_conversation: session_id={session_id}")
        if MEMORY_AVAILABLE and memory:
            context = memory.get(session_id)
            existed = bool(context)
            memory.clear(session_id)
            return {
                "session_id": session_id, "deleted": True, "existed": existed,
                "timestamp": datetime.utcnow().isoformat()
            }
        raise HTTPException(status_code=503, detail="Conversation service unavailable")
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"‚ùå Error deleting conversation {session_id}")
        raise HTTPException(status_code=500, detail=f"Error deleting conversation: {str(e)}")
