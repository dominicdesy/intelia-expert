"""
app/api/v1/expert.py - VERSION NETTOY√âE
SUPPRESSION: Endpoints non-utilis√©s qui √©chouent dans les tests
CONSERVATION: Tous les endpoints fonctionnels et diagnostic auth (car il fonctionne)
"""
import os
import logging
import uuid
import time
from datetime import datetime
from typing import Optional, List, Dict, Any

from fastapi import APIRouter, HTTPException, Request, Depends, Query, Body
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field, ConfigDict

router = APIRouter(tags=["expert"])
logger = logging.getLogger(__name__)

# ‚úÖ DIAGNOSTIC D√âTAILL√â: Import auth avec plusieurs m√©thodes
logger.info("=" * 60)
logger.info("üîç DIAGNOSTIC IMPORT AUTH.PY - M√âTHODES MULTIPLES")

# V√©rifier si le fichier auth.py existe
import os
import sys
auth_file_path = os.path.join(os.path.dirname(__file__), "auth.py")
logger.info(f"üìÅ Chemin auth.py: {auth_file_path}")
logger.info(f"üìÅ Fichier existe: {'‚úÖ' if os.path.exists(auth_file_path) else '‚ùå'}")

# M√©thode 1: Import direct relatif
AUTH_AVAILABLE = False
get_current_user = None

logger.info("üîç M√©thode 1: Import direct relatif")
try:
    from .auth import get_current_user
    AUTH_AVAILABLE = True
    logger.info("‚úÖ M√©thode 1 r√©ussie: Import direct relatif")
except ImportError as e:
    logger.error(f"‚ùå M√©thode 1 √©chou√©e: {e}")
except Exception as e:
    logger.error(f"‚ùå M√©thode 1 erreur critique: {e}")

# M√©thode 2: Import absolu (si m√©thode 1 √©choue)
if not AUTH_AVAILABLE:
    logger.info("üîç M√©thode 2: Import absolu")
    try:
        from app.api.v1.auth import get_current_user
        AUTH_AVAILABLE = True
        logger.info("‚úÖ M√©thode 2 r√©ussie: Import absolu")
    except ImportError as e:
        logger.error(f"‚ùå M√©thode 2 √©chou√©e: {e}")
    except Exception as e:
        logger.error(f"‚ùå M√©thode 2 erreur critique: {e}")

# M√©thode 3: Import par importlib (si m√©thodes 1&2 √©chouent)
if not AUTH_AVAILABLE:
    logger.info("üîç M√©thode 3: Import par importlib")
    try:
        import importlib
        auth_module = importlib.import_module(".auth", package="app.api.v1")
        get_current_user = getattr(auth_module, "get_current_user", None)
        if get_current_user:
            AUTH_AVAILABLE = True
            logger.info("‚úÖ M√©thode 3 r√©ussie: Import par importlib")
        else:
            logger.error("‚ùå M√©thode 3: get_current_user non trouv√© dans le module")
    except ImportError as e:
        logger.error(f"‚ùå M√©thode 3 √©chou√©e: {e}")
    except Exception as e:
        logger.error(f"‚ùå M√©thode 3 erreur critique: {e}")

# V√©rifier le chemin Python et diagnostics suppl√©mentaires
logger.info(f"üêç Python path: {sys.path[:3]}...")
logger.info(f"üêç Current working dir: {os.getcwd()}")
logger.info(f"üêç __file__ location: {__file__}")

# Test d'import √©tape par √©tape
logger.info("üîç Tests d'import √©tape par √©tape:")
try:
    import app
    logger.info("‚úÖ import app")
except Exception as e:
    logger.error(f"‚ùå import app: {e}")

try:
    import app.api
    logger.info("‚úÖ import app.api")
except Exception as e:
    logger.error(f"‚ùå import app.api: {e}")

try:
    import app.api.v1
    logger.info("‚úÖ import app.api.v1")
except Exception as e:
    logger.error(f"‚ùå import app.api.v1: {e}")

# R√©sultat final
logger.info(f"üéØ AUTH_AVAILABLE final: {AUTH_AVAILABLE}")
logger.info(f"üéØ get_current_user: {'‚úÖ Disponible' if get_current_user else '‚ùå Non disponible'}")
logger.info("=" * 60)

# OpenAI import s√©curis√©
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    openai = None

# Configuration s√©curit√© pour authentification
security = HTTPBearer()

# =============================================================================
# MOD√àLES PYDANTIC CORRIG√âS - VERSION SIMPLE ET ROBUSTE
# =============================================================================

class QuestionRequest(BaseModel):
    """Request model simplifi√© et robuste"""
    text: str = Field(..., min_length=1, max_length=5000, description="Question text")
    language: Optional[str] = Field("fr", description="Response language (fr, en, es)")
    speed_mode: Optional[str] = Field("balanced", description="Speed mode (fast, balanced, quality)")

    model_config = ConfigDict(
        str_strip_whitespace=True,  # Nettoie automatiquement les espaces
        validate_default=True,      # Valide les valeurs par d√©faut
        extra="ignore"              # Ignore les champs suppl√©mentaires
    )

    def model_post_init(self, __context) -> None:
        """Post-validation pour nettoyer et valider les champs"""
        # Validation et nettoyage de la langue
        if self.language not in ['fr', 'en', 'es']:
            self.language = 'fr'
        
        # Validation et nettoyage du mode de vitesse
        if self.speed_mode not in ['fast', 'balanced', 'quality']:
            self.speed_mode = 'balanced'

class ExpertResponse(BaseModel):
    """Response model standard"""
    question: str
    response: str
    conversation_id: str
    rag_used: bool
    rag_score: Optional[float] = None
    timestamp: str
    language: str
    response_time_ms: int
    mode: str = "expert_router_corrected"
    user: Optional[str] = None
    logged: bool = False

class FeedbackRequest(BaseModel):
    """Feedback model standard"""
    rating: str = Field(..., description="Rating: positive, negative, neutral")
    comment: Optional[str] = Field(None, description="Optional comment")
    conversation_id: Optional[str] = Field(None, description="Conversation ID")

    model_config = ConfigDict(
        str_strip_whitespace=True,
        extra="ignore"
    )

    def model_post_init(self, __context) -> None:
        """Post-validation pour le rating"""
        if self.rating not in ['positive', 'negative', 'neutral']:
            self.rating = 'neutral'

# =============================================================================
# IMPORT LOGGING
# =============================================================================

try:
    from app.api.v1.logging import logger_instance, ConversationCreate
    LOGGING_AVAILABLE = True
    logger.info("‚úÖ Syst√®me de logging int√©gr√©")
except ImportError as e:
    LOGGING_AVAILABLE = False
    logger_instance = None
    ConversationCreate = None
    logger.warning(f"‚ö†Ô∏è Syst√®me de logging non disponible: {e}")

async def save_conversation_auto(
    conversation_id: str,
    question: str, 
    response: str,
    user_id: str = "anonymous",
    language: str = "fr",
    rag_used: bool = False,
    rag_score: float = None,
    response_time_ms: int = 0
) -> bool:
    """Sauvegarde automatique"""
    
    if not LOGGING_AVAILABLE or not logger_instance:
        return False
    
    try:
        conversation = ConversationCreate(
            user_id=str(user_id),
            question=str(question),
            response=str(response),
            conversation_id=conversation_id,
            confidence_score=rag_score,
            response_time_ms=response_time_ms,
            language=language,
            rag_used=rag_used
        )
        
        record_id = logger_instance.save_conversation(conversation)
        logger.info(f"‚úÖ Conversation sauvegard√©e: {conversation_id}")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erreur sauvegarde: {e}")
        return False

def get_user_id_from_request(fastapi_request: Request) -> str:
    """Extrait l'ID utilisateur"""
    try:
        user = getattr(fastapi_request.state, "user", None)
        if user:
            return str(user.get("id", user.get("user_id", "authenticated_user")))
        
        client_ip = fastapi_request.client.host if fastapi_request.client else "unknown"
        user_agent = fastapi_request.headers.get("user-agent", "unknown")
        
        import hashlib
        anonymous_data = f"{client_ip}_{user_agent}_{datetime.now().strftime('%Y-%m-%d')}"
        anonymous_id = f"anon_{hashlib.md5(anonymous_data.encode()).hexdigest()[:8]}"
        
        return anonymous_id
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Erreur g√©n√©ration user_id: {e}")
        return f"anon_{uuid.uuid4().hex[:8]}"

# =============================================================================
# PROMPTS MULTI-LANGUES
# =============================================================================

EXPERT_PROMPTS = {
    "fr": """Tu es un expert v√©t√©rinaire sp√©cialis√© en sant√© et nutrition animale, particuli√®rement pour les poulets de chair. 
R√©ponds de mani√®re pr√©cise et pratique en fran√ßais. Tu peux utiliser tous les caract√®res fran√ßais (√©, √®, √†, √ß, √π, etc.) et tous les symboles (¬∞C, %, etc.) dans tes r√©ponses.

IMPORTANT: Ne fais pas r√©f√©rence √† une lign√©e g√©n√©tique comme Ross ou Cobb, sauf si l'utilisateur la mentionne dans sa question. Donne une r√©ponse g√©n√©rale qui s'applique √† tous les poulets de chair.""",
    
    "en": """You are a veterinary expert specialized in animal health and nutrition, particularly for broiler chickens.
Answer precisely and practically in English, providing advice based on industry best practices.

IMPORTANT: Do not reference specific genetic lines like Ross or Cobb, unless the user mentions them in their question. Provide general answers that apply to all broiler chickens.""",
    
    "es": """Eres un experto veterinario especializado en salud y nutrici√≥n animal, particularmente para pollos de engorde.
Responde de manera precisa y pr√°ctica en espa√±ol. Puedes usar todos los caract√©res especiales del espa√±ol (√±, ¬ø, ¬°, acentos, etc.) en tus respuestas.

IMPORTANTE: No hagas referencia a l√≠neas gen√©ticas como Ross o Cobb, a menos que el usuario las mencione en su pregunta. Da respuestas generales que se apliquen a todos los pollos de engorde."""
}

def get_expert_prompt(language: str) -> str:
    """Get expert system prompt for language"""
    return EXPERT_PROMPTS.get(language.lower(), EXPERT_PROMPTS["fr"])

# =============================================================================
# FONCTIONS HELPER
# =============================================================================

def get_fallback_response(question: str, language: str = "fr") -> str:
    """R√©ponse de fallback"""
    try:
        safe_question = str(question)[:50] if question else "votre question"
    except:
        safe_question = "votre question"
    
    fallback_responses = {
        "fr": f"Je suis un expert v√©t√©rinaire. Pour votre question sur '{safe_question}...', je recommande de surveiller les param√®tres environnementaux et de maintenir de bonnes pratiques d'hygi√®ne pour vos poulets de chair.",
        "en": f"I am a veterinary expert. For your question about '{safe_question}...', I recommend monitoring environmental parameters and maintaining good hygiene practices for your broiler chickens.",
        "es": f"Soy un experto veterinario. Para su pregunta sobre '{safe_question}...', recomiendo monitorear los par√°metros ambientales y mantener buenas pr√°cticas de higiene para sus pollos de engorde."
    }
    return fallback_responses.get(language.lower(), fallback_responses["fr"])

async def process_question_openai(question: str, language: str = "fr", speed_mode: str = "balanced") -> str:
    """Process question using OpenAI"""
    
    # üõ°Ô∏è V√âRIFICATION DOMAINE AVANT OPENAI
    question_lower = question.lower()
    
    # Liste de mots-cl√©s non-agricoles
    non_agricultural_keywords = [
        'crypto', 'bitcoin', 'ethereum', 'finance', 'banque', 'investissement',
        'politique', '√©lection', 'sport', 'football', 'beaut√©', 'maquillage',
        'technologie', 'informatique', 'smartphone', 'voiture', 'auto',
        'immobilier', 'maison', 'appartement', 'cin√©ma', 'film', 'musique'
    ]
    
    # V√©rifier si la question contient des mots non-agricoles
    if any(keyword in question_lower for keyword in non_agricultural_keywords):
        logger.info(f"üö´ Question hors contexte d√©tect√©e: {question[:50]}...")
        
        # Message exact que vous voulez
        if language == "en":
            return "I am an expert in the poultry field, so I am not specialized in cryptocurrency. If you have questions about the poultry field, I would be happy to help you."
        elif language == "es":
            return "Soy un experto en el campo av√≠cola, por lo que no me especializo en criptomonedas. Si tienes preguntas sobre el campo av√≠cola, estar√≠a encantado de ayudarte."
        else:  # fran√ßais par d√©faut
            return "Je suis un expert dans le domaine avicole, donc je ne suis pas sp√©cialis√© dans la cryptomonnaie. Si vous avez des questions sur le domaine avicole, je serais ravi de vous aider."
    
    # V√©rifier s'il y a des mots-cl√©s agricoles
    agricultural_keywords = [
        'poulet', 'poule', 'volaille', 'aviculture', '√©levage', 'ferme',
        'nutrition', 'alimentation', 'vaccination', 'maladie', 'mortalit√©',
        'temp√©rature', 'ventilation', 'chicken', 'poultry', 'farm', 'breeding'
    ]
    
    # Si pas de mots agricoles, retourner le message standard
    if not any(keyword in question_lower for keyword in agricultural_keywords):
        logger.info(f"üö´ Question trop g√©n√©rale d√©tect√©e: {question[:50]}...")
        
        if language == "en":
            return "I am an expert in the poultry field, so I am not specialized in cryptocurrency. If you have questions about the poultry field, I would be happy to help you."
        elif language == "es":
            return "Soy un experto en el campo av√≠cola, por lo que no me especializo en criptomonedas. Si tienes preguntas sobre el campo av√≠cola, estar√≠a encantado de ayudarte."
        else:  # fran√ßais par d√©faut
            return "Je suis un expert dans le domaine avicole, donc je ne suis pas sp√©cialis√© dans la cryptomonnaie. Si vous avez des questions sur le domaine avicole, je serais ravi de vous aider."
    
    # Si c'est agricole, continuer avec OpenAI normal...
    if not OPENAI_AVAILABLE or not openai:
        return get_fallback_response(question, language)
    
    # Reste du code OpenAI inchang√©...




# =============================================================================
# ENDPOINT PRINCIPAL AVEC DIAGNOSTIC CIBL√â
# =============================================================================

@router.post("/ask", response_model=ExpertResponse)
async def ask_expert_secure(
    request_data: QuestionRequest,  # ‚úÖ CORRECTION: FastAPI mappe automatiquement le JSON
    request: Request,               # ‚úÖ CORRECTION: FastAPI injecte automatiquement Request
    current_user: Dict[str, Any] = Depends(get_current_user) if AUTH_AVAILABLE else None
):
    """Question avec authentification Supabase - VERSION AVEC DIAGNOSTIC CIBL√â"""
    start_time = time.time()
    
    try:
        # ‚úÖ DIAGNOSTIC CIBL√â: Log seulement ce qui est n√©cessaire
        logger.info("=" * 60)
        logger.info("üîê D√âBUT ask_expert_secure")
        logger.info(f"üìù Question: {request_data.text[:100]}...")
        logger.info(f"üåê Langue: {request_data.language}")
        logger.info(f"‚ö° Mode: {request_data.speed_mode}")
        logger.info(f"üîß AUTH_AVAILABLE: {AUTH_AVAILABLE}")
        logger.info(f"üë§ current_user: {bool(current_user)}")
        
        # ‚úÖ DIAGNOSTIC: V√©rifier le token uniquement si probl√®me
        if not AUTH_AVAILABLE:
            logger.error("‚ùå AUTH_AVAILABLE = False - V√©rifiez import auth.py")
            raise HTTPException(
                status_code=503,
                detail="Service d'authentification non disponible"
            )
        
        if not current_user:
            # Diagnostic du token seulement en cas d'√©chec
            auth_header = request.headers.get("Authorization")
            logger.error(f"‚ùå current_user = None - Auth header: {'Pr√©sent' if auth_header else 'Manquant'}")
            if auth_header:
                logger.error(f"Token preview: {auth_header[:50]}...")
            raise HTTPException(
                status_code=503,
                detail="Service d'authentification non disponible"
            )
        
        # L'utilisateur est authentifi√© via auth.py
        user_id = current_user.get("user_id")
        user_email = current_user.get("email")
        
        logger.info(f"‚úÖ Authentifi√©: {user_email} ({user_id[:8] if user_id else 'N/A'}...)")
        
        # Ajouter les infos utilisateur √† la requ√™te
        request.state.user = current_user
        
        # R√©cup√©ration de la question avec validation
        question_text = request_data.text.strip()
        
        if not question_text:
            logger.error("‚ùå Question vide apr√®s nettoyage")
            raise HTTPException(status_code=400, detail="Question text is required")
        
        conversation_id = str(uuid.uuid4())
        
        logger.info(f"üÜî Conversation ID: {conversation_id}")
        logger.info(f"üî§ Caract√®res sp√©ciaux d√©tect√©s: {[c for c in question_text if ord(c) > 127]}")
        
        # Variables par d√©faut
        rag_used = False
        rag_score = None
        answer = ""
        mode = "authenticated_direct_openai"
        
        # Essayer RAG d'abord
        app = request.app
        process_rag = getattr(app.state, 'process_question_with_rag', None)
        
        if process_rag:
            try:
                logger.info("üîç Utilisation du syst√®me RAG pour utilisateur authentifi√©...")
                result = await process_rag(
                    question=question_text,
                    user=current_user,
                    language=request_data.language,
                    speed_mode=request_data.speed_mode
                )
                
                answer = str(result.get("response", ""))
                rag_used = result.get("mode", "").startswith("rag")
                rag_score = result.get("score")
                mode = f"authenticated_{result.get('mode', 'rag_enhanced')}"
                
                logger.info(f"‚úÖ RAG trait√© - Mode: {mode}, Score: {rag_score}")
                
            except Exception as rag_error:
                logger.error(f"‚ùå Erreur RAG: {rag_error}")
                answer = await process_question_openai(
                    question_text, 
                    request_data.language,
                    request_data.speed_mode
                )
                mode = "authenticated_fallback_openai"
        else:
            logger.info("‚ö†Ô∏è RAG non disponible, utilisation OpenAI direct")
            answer = await process_question_openai(
                question_text,
                request_data.language,
                request_data.speed_mode
            )
            mode = "authenticated_direct_openai"
        
        response_time_ms = int((time.time() - start_time) * 1000)
        
        logger.info(f"‚è±Ô∏è Temps de traitement: {response_time_ms}ms")
        
        # Sauvegarde automatique
        logged = await save_conversation_auto(
            conversation_id=conversation_id,
            question=question_text,
            response=answer,
            user_id=user_id or "authenticated_user",
            language=request_data.language,
            rag_used=rag_used,
            rag_score=rag_score,
            response_time_ms=response_time_ms
        )
        
        logger.info(f"üíæ Sauvegarde: {'‚úÖ R√©ussie' if logged else '‚ùå √âchou√©e'}")
        
        # Retourner la r√©ponse
        response_obj = ExpertResponse(
            question=str(question_text),
            response=str(answer),
            conversation_id=conversation_id,
            rag_used=rag_used,
            rag_score=rag_score,
            timestamp=datetime.now().isoformat(),
            language=request_data.language,
            response_time_ms=response_time_ms,
            mode=mode,
            user=user_email,
            logged=logged
        )
        
        logger.info("‚úÖ FIN ask_expert_secure - Succ√®s")
        logger.info("=" * 60)
        
        return response_obj
    
    except HTTPException:
        logger.info("=" * 60)
        raise
    except Exception as e:
        logger.error(f"‚ùå Erreur critique ask expert s√©curis√©: {e}")
        import traceback
        logger.error(f"‚ùå Traceback complet: {traceback.format_exc()}")
        logger.info("=" * 60)
        raise HTTPException(status_code=500, detail=f"Erreur interne: {str(e)}")

# =============================================================================
# TOUS LES AUTRES ENDPOINTS FONCTIONNELS (CONSERV√âS INT√âGRALEMENT)
# =============================================================================

@router.post("/ask-public", response_model=ExpertResponse)
async def ask_expert_public(
    request_data: QuestionRequest,  # ‚úÖ CORRECTION: Mapping automatique
    request: Request                # ‚úÖ CORRECTION: Injection correcte
):
    """Question publique - CORRIG√â INJECTION REQUEST"""
    start_time = time.time()
    
    try:
        # Log d√©taill√© pour debug
        logger.info("=" * 60)
        logger.info("üåê D√âBUT ask_expert_public")
        logger.info(f"üìù Question re√ßue: {request_data.text[:100]}...")
        logger.info(f"üåê Langue: {request_data.language}")
        logger.info(f"‚ö° Mode: {request_data.speed_mode}")
        
        # R√©cup√©ration de la question avec validation
        question_text = request_data.text.strip()
        
        if not question_text:
            logger.error("‚ùå Question vide apr√®s nettoyage")
            raise HTTPException(status_code=400, detail="Question text is required")
        
        conversation_id = str(uuid.uuid4())
        user_id = get_user_id_from_request(request)
        
        logger.info(f"üÜî Conversation ID: {conversation_id}")
        logger.info(f"üë§ User ID: {user_id}")
        logger.info(f"üî§ Caract√®res sp√©ciaux: {[c for c in question_text if ord(c) > 127]}")
        
        user = getattr(request.state, "user", None)
        
        # Variables par d√©faut
        rag_used = False
        rag_score = None
        answer = ""
        mode = "direct_openai"
        
        # Essayer RAG d'abord
        app = request.app
        process_rag = getattr(app.state, 'process_question_with_rag', None)
        
        if process_rag:
            try:
                logger.info("üîç Utilisation du syst√®me RAG...")
                result = await process_rag(
                    question=question_text,
                    user=user,
                    language=request_data.language,
                    speed_mode=request_data.speed_mode
                )
                
                answer = str(result.get("response", ""))
                rag_used = result.get("mode", "").startswith("rag")
                rag_score = result.get("score")
                mode = result.get("mode", "rag_enhanced")
                
                logger.info(f"‚úÖ RAG trait√© - Mode: {mode}, Score: {rag_score}")
                
            except Exception as rag_error:
                logger.error(f"‚ùå Erreur RAG: {rag_error}")
                answer = await process_question_openai(
                    question_text, 
                    request_data.language,
                    request_data.speed_mode
                )
        else:
            logger.info("‚ö†Ô∏è RAG non disponible, utilisation OpenAI")
            answer = await process_question_openai(
                question_text,
                request_data.language,
                request_data.speed_mode
            )
        
        response_time_ms = int((time.time() - start_time) * 1000)
        
        logger.info(f"‚è±Ô∏è Temps de traitement: {response_time_ms}ms")
        
        # Sauvegarde automatique
        logged = await save_conversation_auto(
            conversation_id=conversation_id,
            question=question_text,
            response=answer,
            user_id=user_id,
            language=request_data.language,
            rag_used=rag_used,
            rag_score=rag_score,
            response_time_ms=response_time_ms
        )
        
        logger.info(f"üíæ Sauvegarde: {'‚úÖ R√©ussie' if logged else '‚ùå √âchou√©e'}")
        
        # Retourner la r√©ponse
        response_obj = ExpertResponse(
            question=str(question_text),
            response=str(answer),
            conversation_id=conversation_id,
            rag_used=rag_used,
            rag_score=rag_score,
            timestamp=datetime.now().isoformat(),
            language=request_data.language,
            response_time_ms=response_time_ms,
            mode=mode,
            user=str(user) if user else None,
            logged=logged
        )
        
        logger.info("‚úÖ FIN ask_expert_public - Succ√®s")
        logger.info("=" * 60)
        
        return response_obj
    
    except HTTPException:
        logger.info("=" * 60)
        raise
    except Exception as e:
        logger.error(f"‚ùå Erreur critique ask expert public: {e}")
        import traceback
        logger.error(f"‚ùå Traceback complet: {traceback.format_exc()}")
        logger.info("=" * 60)
        raise HTTPException(status_code=500, detail=f"Erreur interne: {str(e)}")

@router.post("/feedback")
async def submit_feedback(feedback_data: FeedbackRequest):
    """Submit feedback - CORRIG√â"""
    try:
        logger.info(f"üìä Feedback re√ßu: {feedback_data.rating}")
        
        feedback_updated = False
        if feedback_data.conversation_id and LOGGING_AVAILABLE and logger_instance:
            try:
                rating_numeric = {
                    "positive": 1,
                    "negative": -1,
                    "neutral": 0
                }.get(feedback_data.rating, 0)
                
                feedback_updated = logger_instance.update_feedback(
                    feedback_data.conversation_id, 
                    rating_numeric
                )
                
            except Exception as e:
                logger.error(f"‚ùå Erreur mise √† jour feedback: {e}")
        
        return {
            "success": True,
            "message": "Feedback enregistr√© avec succ√®s",
            "rating": feedback_data.rating,
            "comment": feedback_data.comment,
            "conversation_id": feedback_data.conversation_id,
            "feedback_updated_in_db": feedback_updated,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"‚ùå Erreur feedback: {e}")
        raise HTTPException(status_code=500, detail="Erreur enregistrement feedback")

@router.get("/topics")
async def get_suggested_topics(language: str = "fr"):
    """Get suggested topics"""
    try:
        lang = language.lower() if language else "fr"
        if lang not in ["fr", "en", "es"]:
            lang = "fr"
        
        topics_by_language = {
            "fr": [
                "Protocoles Compass pour l'analyse de performance",
                "Probl√®mes de croissance poulets de chair",
                "Temp√©rature optimale pour √©levage (32¬∞C)",
                "Mortalit√© √©lev√©e - diagnostic",
                "Ventilation et qualit√© d'air",
                "Protocoles de vaccination",
                "Indices de conversion alimentaire"
            ],
            "en": [
                "Compass Performance Analysis Protocol",
                "Broiler chicken growth problems",
                "Optimal temperature for farming (32¬∞C)",
                "High mortality - diagnosis", 
                "Ventilation and air quality",
                "Vaccination protocols",
                "Feed conversion ratios"
            ],
            "es": [
                "Protocolos Compass an√°lisis rendimiento",
                "Problemas crecimiento pollos de engorde",
                "Temperatura √≥ptima crianza (32¬∞C)",
                "Mortalidad alta - diagn√≥stico",
                "Ventilaci√≥n y calidad aire",
                "Protocolos vacunaci√≥n",
                "√çndices conversi√≥n alimentaria"
            ]
        }
        
        topics = topics_by_language.get(lang, topics_by_language["fr"])
        
        return {
            "topics": topics,
            "language": lang,
            "count": len(topics),
            "note": "Topics g√©n√©riques pour tous poulets de chair"
        }
    except Exception as e:
        logger.error(f"‚ùå Erreur topics: {e}")
        raise HTTPException(status_code=500, detail="Erreur r√©cup√©ration topics")

# =============================================================================
# ENDPOINTS DEBUG UTILES (CONSERV√âS CAR FONCTIONNELS)
# =============================================================================

@router.get("/debug-system")
async def debug_system_info():
    """Endpoint de diagnostic syst√®me complet"""
    import os
    import sys
    
    auth_file_path = os.path.join(os.path.dirname(__file__), "auth.py")
    
    # Liste des fichiers dans le r√©pertoire
    current_dir = os.path.dirname(__file__)
    try:
        files_in_dir = os.listdir(current_dir)
    except:
        files_in_dir = ["Erreur lecture r√©pertoire"]
    
    # Test d'import d√©taill√© avec analyse __init__.py
    import_tests = {}
    
    # Test 1: app
    try:
        import app
        import_tests["app"] = "‚úÖ OK"
    except Exception as e:
        import_tests["app"] = f"‚ùå {str(e)}"
    
    # Test 2: app.api
    try:
        import app.api
        import_tests["app.api"] = "‚úÖ OK"
    except Exception as e:
        import_tests["app.api"] = f"‚ùå {str(e)}"
    
    # Test 3: app.api.v1 (ici c'est critique)
    try:
        import app.api.v1
        import_tests["app.api.v1"] = "‚úÖ OK"
        
        # V√©rifier les attributs disponibles dans __init__.py
        v1_attrs = dir(app.api.v1)
        import_tests["app.api.v1.attributes"] = [attr for attr in v1_attrs if not attr.startswith('_')]
        
        # V√©rifier sp√©cifiquement AUTH_AVAILABLE dans __init__.py
        if hasattr(app.api.v1, 'AUTH_AVAILABLE'):
            import_tests["app.api.v1.AUTH_AVAILABLE"] = f"‚úÖ {getattr(app.api.v1, 'AUTH_AVAILABLE')}"
        else:
            import_tests["app.api.v1.AUTH_AVAILABLE"] = "‚ùå Non d√©fini"
            
    except Exception as e:
        import_tests["app.api.v1"] = f"‚ùå {str(e)}"
    
    # Test 4: app.api.v1.auth (module direct)
    try:
        import app.api.v1.auth
        import_tests["app.api.v1.auth"] = "‚úÖ OK"
        
        # V√©rifier les fonctions disponibles dans auth.py
        auth_attrs = dir(app.api.v1.auth)
        auth_functions = [attr for attr in auth_attrs if not attr.startswith('_') and callable(getattr(app.api.v1.auth, attr, None))]
        import_tests["app.api.v1.auth.functions"] = auth_functions
        
    except Exception as e:
        import_tests["app.api.v1.auth"] = f"‚ùå {str(e)}"
    
    # Test 5: get_current_user function (direct)
    try:
        from app.api.v1.auth import get_current_user
        import_tests["get_current_user"] = "‚úÖ OK"
        import_tests["get_current_user.type"] = str(type(get_current_user))
    except Exception as e:
        import_tests["get_current_user"] = f"‚ùå {str(e)}"
    
    # Test 6: Import relatif
    try:
        # Simuler l'import relatif depuis le contexte expert.py
        current_dir = os.path.dirname(__file__)
        auth_py_path = os.path.join(current_dir, "auth.py")
        if os.path.exists(auth_py_path):
            import_tests["relative_auth_file"] = "‚úÖ Fichier auth.py existe"
            try:
                from .auth import get_current_user as relative_get_current_user
                import_tests["relative_import"] = "‚úÖ Import relatif r√©ussi"
            except Exception as rel_e:
                import_tests["relative_import"] = f"‚ùå Import relatif √©chou√©: {rel_e}"
        else:
            import_tests["relative_auth_file"] = "‚ùå Fichier auth.py manquant"
    except Exception as e:
        import_tests["relative_import_test"] = f"‚ùå {str(e)}"
    
    return {
        "auth_available": AUTH_AVAILABLE,
        "current_directory": current_dir,
        "auth_file_path": auth_file_path,
        "auth_file_exists": os.path.exists(auth_file_path),
        "files_in_directory": files_in_dir,
        "python_path_sample": sys.path[:3],
        "working_directory": os.getcwd(),
        "import_tests": import_tests,
        "openai_available": OPENAI_AVAILABLE,
        "logging_available": LOGGING_AVAILABLE,
        "timestamp": datetime.now().isoformat()
    }

@router.get("/debug-auth")
async def debug_auth_info(request: Request):
    """Endpoint de diagnostic rapide"""
    auth_header = request.headers.get("Authorization")
    
    return {
        "auth_available": AUTH_AVAILABLE,
        "auth_header_present": bool(auth_header),
        "auth_header_preview": auth_header[:50] + "..." if auth_header else None,
        "openai_available": OPENAI_AVAILABLE,
        "logging_available": LOGGING_AVAILABLE,
        "timestamp": datetime.now().isoformat()
    }

# =============================================================================
# ENDPOINT DE TEST UTF-8 (GARDE CAR IL FONCTIONNE)
# =============================================================================

@router.post("/test-utf8")
async def test_utf8_direct(request: Request):  # ‚úÖ CORRECTION: Injection correcte
    """Test endpoint pour UTF-8 direct"""
    try:
        # R√©cup√©rer le body brut
        body = await request.body()
        body_str = body.decode('utf-8')
        
        logger.info(f"üìù Body brut re√ßu: {body_str}")
        
        # Parser JSON manuellement
        import json
        data = json.loads(body_str)
        
        question_text = data.get('text', '')
        language = data.get('language', 'fr')
        
        logger.info(f"üìù Question extraite: {question_text}")
        logger.info(f"üî§ Caract√®res sp√©ciaux: {[c for c in question_text if ord(c) > 127]}")
        
        # Traitement direct
        answer = await process_question_openai(question_text, language, "fast")
        
        return {
            "success": True,
            "question_received": question_text,
            "special_chars_detected": [c for c in question_text if ord(c) > 127],
            "response": answer,
            "method": "direct_body_parsing",
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"‚ùå Erreur test UTF-8: {e}")
        return {
            "success": False,
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

# =============================================================================
# CONFIGURATION
# =============================================================================

if OPENAI_AVAILABLE and openai:
    openai_api_key = os.getenv('OPENAI_API_KEY')
    if openai_api_key:
        openai.api_key = openai_api_key
        logger.info("‚úÖ OpenAI configur√© avec succ√®s")
    else:
        logger.warning("‚ö†Ô∏è OpenAI API key non trouv√©e")
else:
    logger.warning("‚ö†Ô∏è Module OpenAI non disponible")

logger.info("‚úÖ EXPERT.PY NETTOY√â - ENDPOINTS INUTILES SUPPRIM√âS")
logger.info(f"üîß AUTH_AVAILABLE: {AUTH_AVAILABLE}")
logger.info(f"üíæ LOGGING_AVAILABLE: {LOGGING_AVAILABLE}")
logger.info(f"ü§ñ OPENAI_AVAILABLE: {OPENAI_AVAILABLE}")
logger.info("‚úÖ ENDPOINTS SUPPRIM√âS: /auth-status, /test-auth (retournaient 401/503)")