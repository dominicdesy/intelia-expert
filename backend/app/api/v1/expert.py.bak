"""
app/api/v1/expert.py - VERSION COMPL√àTE R√â√âCRITE AVEC CORRECTIONS
CORRECTIONS: save_conversation et update_feedback
CONSERVATION: Toutes les autres fonctionnalit√©s existantes
"""
import os
import logging
import uuid
import time
from datetime import datetime
from typing import Optional, List, Dict, Any

from fastapi import APIRouter, HTTPException, Request, Depends, Query, Body
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field, ConfigDict

router = APIRouter(tags=["expert"])
logger = logging.getLogger(__name__)

# =============================================================================
# IMPORT VALIDATEUR AGRICOLE - PRIORIT√â ABSOLUE
# =============================================================================

try:
    from app.api.v1.agricultural_domain_validator import (
        validate_agricultural_question,
        get_agricultural_validator_stats,
        is_agricultural_validation_enabled
    )
    AGRICULTURAL_VALIDATOR_AVAILABLE = True
    logger.info("‚úÖ [Expert] Validateur agricole import√© avec succ√®s")
    logger.info(f"‚úÖ [Expert] Validation agricole: {'ACTIVE' if is_agricultural_validation_enabled() else 'INACTIVE'}")
except ImportError as e:
    AGRICULTURAL_VALIDATOR_AVAILABLE = False
    logger.error(f"‚ùå [Expert] ERREUR CRITIQUE - Validateur agricole non disponible: {e}")
    logger.error("‚ùå [Expert] Toutes les questions seront accept√©es sans filtrage!")
except Exception as e:
    AGRICULTURAL_VALIDATOR_AVAILABLE = False
    logger.error(f"‚ùå [Expert] Erreur inattendue import validateur: {e}")

# =============================================================================
# IMPORT AUTH
# =============================================================================

logger.info("=" * 60)
logger.info("üîç DIAGNOSTIC IMPORT AUTH.PY - M√âTHODES MULTIPLES")

AUTH_AVAILABLE = False
get_current_user = None

try:
    from .auth import get_current_user
    AUTH_AVAILABLE = True
    logger.info("‚úÖ M√©thode 1 r√©ussie: Import direct relatif")
except ImportError as e:
    logger.error(f"‚ùå M√©thode 1 √©chou√©e: {e}")
    try:
        from app.api.v1.auth import get_current_user
        AUTH_AVAILABLE = True
        logger.info("‚úÖ M√©thode 2 r√©ussie: Import absolu")
    except ImportError as e2:
        logger.error(f"‚ùå M√©thode 2 √©chou√©e: {e2}")

logger.info(f"üéØ AUTH_AVAILABLE final: {AUTH_AVAILABLE}")
logger.info("=" * 60)

# OpenAI import s√©curis√©
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    openai = None

# Configuration s√©curit√© pour authentification
security = HTTPBearer()

# =============================================================================
# MOD√àLES PYDANTIC
# =============================================================================

class QuestionRequest(BaseModel):
    """Request model simplifi√© et robuste"""
    text: str = Field(..., min_length=1, max_length=5000, description="Question text")
    language: Optional[str] = Field("fr", description="Response language (fr, en, es)")
    speed_mode: Optional[str] = Field("balanced", description="Speed mode (fast, balanced, quality)")

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_default=True,
        extra="ignore"
    )

    def model_post_init(self, __context) -> None:
        if self.language not in ['fr', 'en', 'es']:
            self.language = 'fr'
        if self.speed_mode not in ['fast', 'balanced', 'quality']:
            self.speed_mode = 'balanced'

class ExpertResponse(BaseModel):
    """Response model standard"""
    question: str
    response: str
    conversation_id: str
    rag_used: bool
    rag_score: Optional[float] = None
    timestamp: str
    language: str
    response_time_ms: int
    mode: str = "expert_router_corrected"
    user: Optional[str] = None
    logged: bool = False
    validation_passed: Optional[bool] = None
    validation_confidence: Optional[float] = None

class FeedbackRequest(BaseModel):
    """Feedback model standard"""
    rating: str = Field(..., description="Rating: positive, negative, neutral")
    comment: Optional[str] = Field(None, description="Optional comment")
    conversation_id: Optional[str] = Field(None, description="Conversation ID")

    model_config = ConfigDict(
        str_strip_whitespace=True,
        extra="ignore"
    )

    def model_post_init(self, __context) -> None:
        if self.rating not in ['positive', 'negative', 'neutral']:
            self.rating = 'neutral'

# =============================================================================
# IMPORT LOGGING - CORRIG√â
# =============================================================================

try:
    from app.api.v1.logging import logger_instance, ConversationCreate
    LOGGING_AVAILABLE = True
    logger.info("‚úÖ Syst√®me de logging int√©gr√©")
except ImportError as e:
    LOGGING_AVAILABLE = False
    logger_instance = None
    ConversationCreate = None
    logger.warning(f"‚ö†Ô∏è Syst√®me de logging non disponible: {e}")

# =============================================================================
# FONCTION DE SAUVEGARDE CORRIG√âE
# =============================================================================

async def save_conversation_auto(
    conversation_id: str,
    question: str, 
    response: str,
    user_id: str = "anonymous",
    language: str = "fr",
    rag_used: bool = False,
    rag_score: float = None,
    response_time_ms: int = 0
) -> bool:
    """Sauvegarde automatique - COMPL√àTEMENT CORRIG√âE"""
    
    if not LOGGING_AVAILABLE or not logger_instance:
        logger.warning("‚ö†Ô∏è Logging non disponible pour sauvegarde")
        return False
    
    try:
        # Cr√©er l'objet conversation
        conversation = ConversationCreate(
            user_id=str(user_id),
            question=str(question),
            response=str(response),
            conversation_id=conversation_id,
            confidence_score=rag_score,
            response_time_ms=response_time_ms,
            language=language,
            rag_used=rag_used
        )
        
        # ‚úÖ M√âTHODE 1: Essayer log_conversation
        try:
            if hasattr(logger_instance, 'log_conversation'):
                record_id = logger_instance.log_conversation(conversation)
                logger.info(f"‚úÖ Conversation sauvegard√©e via log_conversation: {conversation_id}")
                return True
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è log_conversation √©chou√©: {e}")
        
        # ‚úÖ M√âTHODE 2: Essayer save_conversation
        try:
            if hasattr(logger_instance, 'save_conversation'):
                record_id = logger_instance.save_conversation(conversation)
                logger.info(f"‚úÖ Conversation sauvegard√©e via save_conversation: {conversation_id}")
                return True
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è save_conversation √©chou√©: {e}")
        
        # ‚úÖ M√âTHODE 3: Sauvegarde directe SQL (fallback)
        logger.info("üîÑ Tentative sauvegarde directe SQL...")
        
        import sqlite3
        from datetime import datetime
        
        with sqlite3.connect(logger_instance.db_path) as conn:
            record_id = str(uuid.uuid4())
            timestamp = datetime.now().isoformat()
            
            conn.execute("""
                INSERT INTO conversations (
                    id, conversation_id, user_id, question, response, 
                    confidence_score, response_time_ms, language, rag_used, timestamp
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                record_id, conversation_id, str(user_id), str(question), str(response),
                rag_score, response_time_ms, language, rag_used, timestamp
            ))
            
            logger.info(f"‚úÖ Conversation sauvegard√©e via SQL direct: {conversation_id}")
            return True
        
    except Exception as e:
        logger.error(f"‚ùå Toutes les m√©thodes de sauvegarde ont √©chou√©: {e}")
        return False

def get_user_id_from_request(fastapi_request: Request) -> str:
    """Extrait l'ID utilisateur"""
    try:
        user = getattr(fastapi_request.state, "user", None)
        if user:
            return str(user.get("id", user.get("user_id", "authenticated_user")))
        
        client_ip = fastapi_request.client.host if fastapi_request.client else "unknown"
        user_agent = fastapi_request.headers.get("user-agent", "unknown")
        
        import hashlib
        anonymous_data = f"{client_ip}_{user_agent}_{datetime.now().strftime('%Y-%m-%d')}"
        anonymous_id = f"anon_{hashlib.md5(anonymous_data.encode()).hexdigest()[:8]}"
        
        return anonymous_id
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Erreur g√©n√©ration user_id: {e}")
        return f"anon_{uuid.uuid4().hex[:8]}"

# =============================================================================
# FONCTION DE VALIDATION AGRICOLE CENTRALIS√âE
# =============================================================================

async def validate_question_agricultural_domain(
    question: str, 
    language: str, 
    user_id: str, 
    request_ip: str
) -> tuple[bool, str, float]:
    """
    Valide qu'une question concerne le domaine agricole
    
    Returns:
        tuple[bool, str, float]: (is_valid, rejection_message_or_empty, confidence)
    """
    
    # Si le validateur n'est pas disponible, REJETER par s√©curit√©
    if not AGRICULTURAL_VALIDATOR_AVAILABLE:
        logger.error("‚ùå [Validation] Validateur agricole non disponible - REJET par s√©curit√©")
        
        rejection_messages = {
            "fr": "Service temporairement indisponible. Veuillez r√©essayer plus tard.",
            "en": "Service temporarily unavailable. Please try again later.",
            "es": "Servicio temporalmente no disponible. Por favor, int√©ntelo m√°s tarde."
        }
        
        return False, rejection_messages.get(language, rejection_messages["fr"]), 0.0
    
    # Si la validation est d√©sactiv√©e, accepter
    if not is_agricultural_validation_enabled():
        logger.info("üîß [Validation] Validation agricole d√©sactiv√©e - question accept√©e")
        return True, "", 100.0
    
    try:
        # Utiliser le validateur
        validation_result = validate_agricultural_question(
            question=question,
            language=language,
            user_id=user_id,
            request_ip=request_ip
        )
        
        logger.info(f"üîç [Validation] R√©sultat: {validation_result.is_valid} (confiance: {validation_result.confidence:.1f}%)")
        
        if validation_result.is_valid:
            return True, "", validation_result.confidence
        else:
            return False, validation_result.reason or "Question hors domaine agricole", validation_result.confidence
    
    except Exception as e:
        logger.error(f"‚ùå [Validation] Erreur validateur: {e}")
        
        # En cas d'erreur du validateur, rejeter par s√©curit√©
        rejection_messages = {
            "fr": "Erreur de validation. Veuillez reformuler votre question sur le domaine avicole.",
            "en": "Validation error. Please rephrase your question about the poultry domain.",
            "es": "Error de validaci√≥n. Por favor, reformule su pregunta sobre el dominio av√≠cola."
        }
        
        return False, rejection_messages.get(language, rejection_messages["fr"]), 0.0

# =============================================================================
# PROMPTS MULTI-LANGUES
# =============================================================================

EXPERT_PROMPTS = {
    "fr": """Tu es un expert v√©t√©rinaire sp√©cialis√© en sant√© et nutrition animale, particuli√®rement pour les poulets de chair. 
R√©ponds de mani√®re pr√©cise et pratique en fran√ßais. Tu peux utiliser tous les caract√®res fran√ßais (√©, √®, √†, √ß, √π, etc.) et tous les symboles (¬∞C, %, etc.) dans tes r√©ponses.

IMPORTANT: Ne fais pas r√©f√©rence √† une lign√©e g√©n√©tique comme Ross ou Cobb, sauf si l'utilisateur la mentionne dans sa question. Donne une r√©ponse g√©n√©rale qui s'applique √† tous les poulets de chair.""",
    
    "en": """You are a veterinary expert specialized in animal health and nutrition, particularly for broiler chickens.
Answer precisely and practically in English, providing advice based on industry best practices.

IMPORTANT: Do not reference specific genetic lines like Ross or Cobb, unless the user mentions them in their question. Provide general answers that apply to all broiler chickens.""",
    
    "es": """Eres un experto veterinario especializado en salud y nutrici√≥n animal, particularmente para pollos de engorde.
Responde de manera precisa y pr√°ctica en espa√±ol. Puedes usar todos los caract√©res especiales del espa√±ol (√±, ¬ø, ¬°, acentos, etc.) en tus respuestas.

IMPORTANTE: No hagas referencia a l√≠neas gen√©ticas como Ross o Cobb, a menos que el usuario las mencione en su pregunta. Da respuestas generales que se apliquen a todos los pollos de engorde."""
}

def get_expert_prompt(language: str) -> str:
    """Get expert system prompt for language"""
    return EXPERT_PROMPTS.get(language.lower(), EXPERT_PROMPTS["fr"])

# =============================================================================
# FONCTIONS HELPER
# =============================================================================

def get_fallback_response(question: str, language: str = "fr") -> str:
    """R√©ponse de fallback - utilis√©e seulement si OpenAI √©choue"""
    try:
        safe_question = str(question)[:50] if question else "votre question"
    except:
        safe_question = "votre question"
    
    fallback_responses = {
        "fr": f"Je suis un expert v√©t√©rinaire. Pour votre question sur '{safe_question}...', je recommande de surveiller les param√®tres environnementaux et de maintenir de bonnes pratiques d'hygi√®ne pour vos poulets de chair.",
        "en": f"I am a veterinary expert. For your question about '{safe_question}...', I recommend monitoring environmental parameters and maintaining good hygiene practices for your broiler chickens.",
        "es": f"Soy un experto veterinario. Para su pregunta sobre '{safe_question}...', recomiendo monitorear los par√°metros ambientales y mantener buenas pr√°cticas de higiene para sus pollos de engorde."
    }
    return fallback_responses.get(language.lower(), fallback_responses["fr"])

async def process_question_openai(question: str, language: str = "fr", speed_mode: str = "balanced") -> str:
    """Process question using OpenAI"""
    
    if not OPENAI_AVAILABLE or not openai:
        return get_fallback_response(question, language)
    
    try:
        api_key = os.getenv('OPENAI_API_KEY')
        if not api_key:
            return get_fallback_response(question, language)
        
        openai.api_key = api_key
        system_prompt = get_expert_prompt(language)
        
        safe_question = str(question)
        
        model_config = {
            "fast": {"model": "gpt-3.5-turbo", "max_tokens": 300},
            "balanced": {"model": "gpt-3.5-turbo", "max_tokens": 500},
            "quality": {"model": "gpt-4o-mini", "max_tokens": 800}
        }
        
        config = model_config.get(speed_mode, model_config["balanced"])
        
        response = openai.chat.completions.create(
            model=config["model"],
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": safe_question}
            ],
            temperature=0.7,
            max_tokens=config["max_tokens"],
            timeout=15
        )
        
        answer = response.choices[0].message.content
        return str(answer) if answer else get_fallback_response(question, language)
        
    except Exception as e:
        logger.error(f"‚ùå OpenAI error: {e}")
        return get_fallback_response(question, language)

# =============================================================================
# ENDPOINT PRINCIPAL AVEC VALIDATION AGRICOLE INT√âGR√âE
# =============================================================================

@router.post("/ask", response_model=ExpertResponse)
async def ask_expert_secure(
    request_data: QuestionRequest,
    request: Request,
    current_user: Dict[str, Any] = Depends(get_current_user) if AUTH_AVAILABLE else None
):
    """Question avec authentification + validation agricole obligatoire"""
    start_time = time.time()
    
    try:
        logger.info("=" * 60)
        logger.info("üîê D√âBUT ask_expert_secure avec validation agricole")
        logger.info(f"üìù Question: {request_data.text[:100]}...")
        logger.info(f"üåê Langue: {request_data.language}")
        logger.info(f"‚ö° Mode: {request_data.speed_mode}")
        logger.info(f"üîß AUTH_AVAILABLE: {AUTH_AVAILABLE}")
        logger.info(f"üåæ VALIDATOR_AVAILABLE: {AGRICULTURAL_VALIDATOR_AVAILABLE}")
        
        # V√©rification auth
        if not AUTH_AVAILABLE:
            logger.error("‚ùå AUTH_AVAILABLE = False")
            raise HTTPException(status_code=503, detail="Service d'authentification non disponible")
        
        if not current_user:
            logger.error("‚ùå current_user = None")
            raise HTTPException(status_code=503, detail="Service d'authentification non disponible")
        
        # L'utilisateur est authentifi√©
        user_id = current_user.get("user_id")
        user_email = current_user.get("email")
        request_ip = request.client.host if request.client else "unknown"
        
        logger.info(f"‚úÖ Authentifi√©: {user_email} ({user_id[:8] if user_id else 'N/A'}...)")
        
        # Ajouter les infos utilisateur √† la requ√™te
        request.state.user = current_user
        
        # R√©cup√©ration de la question avec validation
        question_text = request_data.text.strip()
        
        if not question_text:
            logger.error("‚ùå Question vide apr√®s nettoyage")
            raise HTTPException(status_code=400, detail="Question text is required")
        
        conversation_id = str(uuid.uuid4())
        logger.info(f"üÜî Conversation ID: {conversation_id}")
        
        # üåæ === VALIDATION AGRICOLE OBLIGATOIRE ===
        logger.info("üåæ [VALIDATION] D√©marrage validation domaine agricole...")
        
        is_valid, rejection_message, validation_confidence = await validate_question_agricultural_domain(
            question=question_text,
            language=request_data.language,
            user_id=user_id or "authenticated_user",
            request_ip=request_ip
        )
        
        if not is_valid:
            logger.warning(f"üö´ [VALIDATION] Question rejet√©e: {rejection_message}")
            
            response_time_ms = int((time.time() - start_time) * 1000)
            
            # Sauvegarde du rejet pour analytics
            await save_conversation_auto(
                conversation_id=conversation_id,
                question=question_text,
                response=rejection_message,
                user_id=user_id or "authenticated_user",
                language=request_data.language,
                rag_used=False,
                rag_score=None,
                response_time_ms=response_time_ms
            )
            
            response_obj = ExpertResponse(
                question=str(question_text),
                response=str(rejection_message),
                conversation_id=conversation_id,
                rag_used=False,
                rag_score=None,
                timestamp=datetime.now().isoformat(),
                language=request_data.language,
                response_time_ms=response_time_ms,
                mode="agricultural_validation_rejected",
                user=user_email,
                logged=True,
                validation_passed=False,
                validation_confidence=validation_confidence
            )
            
            logger.info("üö´ [VALIDATION] Question rejet√©e et logg√©e")
            logger.info("=" * 60)
            return response_obj
        
        logger.info(f"‚úÖ [VALIDATION] Question valid√©e (confiance: {validation_confidence:.1f}%)")
        
        # === TRAITEMENT NORMAL (RAG/OpenAI) ===
        # Variables par d√©faut
        rag_used = False
        rag_score = None
        answer = ""
        mode = "authenticated_direct_openai"
        
        # Essayer RAG d'abord
        app = request.app
        process_rag = getattr(app.state, 'process_question_with_rag', None)
        
        if process_rag:
            try:
                logger.info("üîç Utilisation du syst√®me RAG pour utilisateur authentifi√©...")
                result = await process_rag(
                    question=question_text,
                    user=current_user,
                    language=request_data.language,
                    speed_mode=request_data.speed_mode
                )
                
                answer = str(result.get("response", ""))
                rag_used = result.get("mode", "").startswith("rag")
                rag_score = result.get("score")
                mode = f"authenticated_{result.get('mode', 'rag_enhanced')}"
                
                logger.info(f"‚úÖ RAG trait√© - Mode: {mode}, Score: {rag_score}")
                
            except Exception as rag_error:
                logger.error(f"‚ùå Erreur RAG: {rag_error}")
                answer = await process_question_openai(
                    question_text, 
                    request_data.language,
                    request_data.speed_mode
                )
                mode = "authenticated_fallback_openai"
        else:
            logger.info("‚ö†Ô∏è RAG non disponible, utilisation OpenAI direct")
            answer = await process_question_openai(
                question_text,
                request_data.language,
                request_data.speed_mode
            )
            mode = "authenticated_direct_openai"
        
        response_time_ms = int((time.time() - start_time) * 1000)
        logger.info(f"‚è±Ô∏è Temps de traitement: {response_time_ms}ms")
        
        # Sauvegarde automatique
        logged = await save_conversation_auto(
            conversation_id=conversation_id,
            question=question_text,
            response=answer,
            user_id=user_id or "authenticated_user",
            language=request_data.language,
            rag_used=rag_used,
            rag_score=rag_score,
            response_time_ms=response_time_ms
        )
        
        logger.info(f"üíæ Sauvegarde: {'‚úÖ R√©ussie' if logged else '‚ùå √âchou√©e'}")
        
        # Retourner la r√©ponse
        response_obj = ExpertResponse(
            question=str(question_text),
            response=str(answer),
            conversation_id=conversation_id,
            rag_used=rag_used,
            rag_score=rag_score,
            timestamp=datetime.now().isoformat(),
            language=request_data.language,
            response_time_ms=response_time_ms,
            mode=mode,
            user=user_email,
            logged=logged,
            validation_passed=True,
            validation_confidence=validation_confidence
        )
        
        logger.info("‚úÖ FIN ask_expert_secure - Succ√®s avec validation")
        logger.info("=" * 60)
        
        return response_obj
    
    except HTTPException:
        logger.info("=" * 60)
        raise
    except Exception as e:
        logger.error(f"‚ùå Erreur critique ask expert s√©curis√©: {e}")
        import traceback
        logger.error(f"‚ùå Traceback complet: {traceback.format_exc()}")
        logger.info("=" * 60)
        raise HTTPException(status_code=500, detail=f"Erreur interne: {str(e)}")

# =============================================================================
# ENDPOINT PUBLIC AVEC VALIDATION AGRICOLE INT√âGR√âE
# =============================================================================

@router.post("/ask-public", response_model=ExpertResponse)
async def ask_expert_public(
    request_data: QuestionRequest,
    request: Request
):
    """Question publique avec validation agricole obligatoire"""
    start_time = time.time()
    
    try:
        logger.info("=" * 60)
        logger.info("üåê D√âBUT ask_expert_public avec validation agricole")
        logger.info(f"üìù Question re√ßue: {request_data.text[:100]}...")
        logger.info(f"üåê Langue: {request_data.language}")
        logger.info(f"‚ö° Mode: {request_data.speed_mode}")
        logger.info(f"üåæ VALIDATOR_AVAILABLE: {AGRICULTURAL_VALIDATOR_AVAILABLE}")
        
        # R√©cup√©ration de la question avec validation
        question_text = request_data.text.strip()
        
        if not question_text:
            logger.error("‚ùå Question vide apr√®s nettoyage")
            raise HTTPException(status_code=400, detail="Question text is required")
        
        conversation_id = str(uuid.uuid4())
        user_id = get_user_id_from_request(request)
        request_ip = request.client.host if request.client else "unknown"
        
        logger.info(f"üÜî Conversation ID: {conversation_id}")
        logger.info(f"üë§ User ID: {user_id}")
        
        # üåæ === VALIDATION AGRICOLE OBLIGATOIRE ===
        logger.info("üåæ [VALIDATION] D√©marrage validation domaine agricole...")
        
        is_valid, rejection_message, validation_confidence = await validate_question_agricultural_domain(
            question=question_text,
            language=request_data.language,
            user_id=user_id,
            request_ip=request_ip
        )
        
        if not is_valid:
            logger.warning(f"üö´ [VALIDATION] Question publique rejet√©e: {rejection_message}")
            
            response_time_ms = int((time.time() - start_time) * 1000)
            
            # Sauvegarde du rejet pour analytics
            await save_conversation_auto(
                conversation_id=conversation_id,
                question=question_text,
                response=rejection_message,
                user_id=user_id,
                language=request_data.language,
                rag_used=False,
                rag_score=None,
                response_time_ms=response_time_ms
            )
            
            response_obj = ExpertResponse(
                question=str(question_text),
                response=str(rejection_message),
                conversation_id=conversation_id,
                rag_used=False,
                rag_score=None,
                timestamp=datetime.now().isoformat(),
                language=request_data.language,
                response_time_ms=response_time_ms,
                mode="public_agricultural_validation_rejected",
                user=None,
                logged=True,
                validation_passed=False,
                validation_confidence=validation_confidence
            )
            
            logger.info("üö´ [VALIDATION] Question publique rejet√©e et logg√©e")
            logger.info("=" * 60)
            return response_obj
        
        logger.info(f"‚úÖ [VALIDATION] Question publique valid√©e (confiance: {validation_confidence:.1f}%)")
        
        # === TRAITEMENT NORMAL (RAG/OpenAI) ===
        user = getattr(request.state, "user", None)
        
        # Variables par d√©faut
        rag_used = False
        rag_score = None
        answer = ""
        mode = "direct_openai"
        
        # Essayer RAG d'abord
        app = request.app
        process_rag = getattr(app.state, 'process_question_with_rag', None)
        
        if process_rag:
            try:
                logger.info("üîç Utilisation du syst√®me RAG public...")
                result = await process_rag(
                    question=question_text,
                    user=user,
                    language=request_data.language,
                    speed_mode=request_data.speed_mode
                )
                
                answer = str(result.get("response", ""))
                rag_used = result.get("mode", "").startswith("rag")
                rag_score = result.get("score")
                mode = result.get("mode", "rag_enhanced")
                
                logger.info(f"‚úÖ RAG trait√© - Mode: {mode}, Score: {rag_score}")
                
            except Exception as rag_error:
                logger.error(f"‚ùå Erreur RAG: {rag_error}")
                answer = await process_question_openai(
                    question_text, 
                    request_data.language,
                    request_data.speed_mode
                )
        else:
            logger.info("‚ö†Ô∏è RAG non disponible, utilisation OpenAI")
            answer = await process_question_openai(
                question_text,
                request_data.language,
                request_data.speed_mode
            )
        
        response_time_ms = int((time.time() - start_time) * 1000)
        logger.info(f"‚è±Ô∏è Temps de traitement: {response_time_ms}ms")
        
        # Sauvegarde automatique
        logged = await save_conversation_auto(
            conversation_id=conversation_id,
            question=question_text,
            response=answer,
            user_id=user_id,
            language=request_data.language,
            rag_used=rag_used,
            rag_score=rag_score,
            response_time_ms=response_time_ms
        )
        
        logger.info(f"üíæ Sauvegarde: {'‚úÖ R√©ussie' if logged else '‚ùå √âchou√©e'}")
        
        # Retourner la r√©ponse
        response_obj = ExpertResponse(
            question=str(question_text),
            response=str(answer),
            conversation_id=conversation_id,
            rag_used=rag_used,
            rag_score=rag_score,
            timestamp=datetime.now().isoformat(),
            language=request_data.language,
            response_time_ms=response_time_ms,
            mode=mode,
            user=str(user) if user else None,
            logged=logged,
            validation_passed=True,
            validation_confidence=validation_confidence
        )
        
        logger.info("‚úÖ FIN ask_expert_public - Succ√®s avec validation")
        logger.info("=" * 60)
        
        return response_obj
    
    except HTTPException:
        logger.info("=" * 60)
        raise
    except Exception as e:
        logger.error(f"‚ùå Erreur critique ask expert public: {e}")
        import traceback
        logger.error(f"‚ùå Traceback complet: {traceback.format_exc()}")
        logger.info("=" * 60)
        raise HTTPException(status_code=500, detail=f"Erreur interne: {str(e)}")

# =============================================================================
# ENDPOINT FEEDBACK - COMPL√àTEMENT CORRIG√â
# =============================================================================

@router.post("/feedback")
async def submit_feedback(feedback_data: FeedbackRequest):
    """Submit feedback - COMPL√àTEMENT CORRIG√â"""
    try:
        logger.info(f"üìä Feedback re√ßu: {feedback_data.rating}")
        logger.info(f"üìä Conversation ID: {feedback_data.conversation_id}")
        logger.info(f"üìä Commentaire: {feedback_data.comment}")
        
        feedback_updated = False
        
        if feedback_data.conversation_id and LOGGING_AVAILABLE and logger_instance:
            try:
                # Convertir le rating en format num√©rique
                rating_numeric = {
                    "positive": 1,
                    "negative": -1,
                    "neutral": 0
                }.get(feedback_data.rating, 0)
                
                logger.info(f"üìä Rating num√©rique: {rating_numeric}")
                
                # ‚úÖ M√âTHODE 1: Essayer update_feedback si disponible
                try:
                    if hasattr(logger_instance, 'update_feedback'):
                        feedback_updated = logger_instance.update_feedback(
                            feedback_data.conversation_id, 
                            rating_numeric
                        )
                        logger.info(f"‚úÖ Feedback mis √† jour via update_feedback: {feedback_updated}")
                    else:
                        logger.warning("‚ö†Ô∏è M√©thode update_feedback non disponible")
                        feedback_updated = False
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è update_feedback √©chou√©: {e}")
                    feedback_updated = False
                
                # ‚úÖ M√âTHODE 2: SQL direct si update_feedback √©choue
                if not feedback_updated:
                    logger.info("üîÑ Tentative mise √† jour feedback via SQL direct...")
                    
                    import sqlite3
                    with sqlite3.connect(logger_instance.db_path) as conn:
                        cursor = conn.execute("""
                            UPDATE conversations 
                            SET feedback = ?, updated_at = CURRENT_TIMESTAMP 
                            WHERE conversation_id = ?
                        """, (rating_numeric, feedback_data.conversation_id))
                        
                        feedback_updated = cursor.rowcount > 0
                        
                        if feedback_updated:
                            logger.info(f"‚úÖ Feedback mis √† jour via SQL direct: {feedback_data.conversation_id}")
                        else:
                            logger.warning(f"‚ö†Ô∏è Conversation non trouv√©e: {feedback_data.conversation_id}")
                
            except Exception as e:
                logger.error(f"‚ùå Erreur mise √† jour feedback: {e}")
                feedback_updated = False
        else:
            if not feedback_data.conversation_id:
                logger.warning("‚ö†Ô∏è Conversation ID manquant")
            if not LOGGING_AVAILABLE:
                logger.warning("‚ö†Ô∏è Logging non disponible")
            if not logger_instance:
                logger.warning("‚ö†Ô∏è Logger instance non disponible")
        
        return {
            "success": True,
            "message": "Feedback enregistr√© avec succ√®s",
            "rating": feedback_data.rating,
            "comment": feedback_data.comment,
            "conversation_id": feedback_data.conversation_id,
            "feedback_updated_in_db": feedback_updated,
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"‚ùå Erreur feedback critique: {e}")
        import traceback
        logger.error(f"‚ùå Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Erreur enregistrement feedback: {str(e)}")

# =============================================================================
# AUTRES ENDPOINTS (conserv√©s identiques)
# =============================================================================

@router.get("/topics")
async def get_suggested_topics(language: str = "fr"):
    """Get suggested topics"""
    try:
        lang = language.lower() if language else "fr"
        if lang not in ["fr", "en", "es"]:
            lang = "fr"
        
        topics_by_language = {
            "fr": [
                "Protocoles Compass pour l'analyse de performance",
                "Probl√®mes de croissance poulets de chair",
                "Temp√©rature optimale pour √©levage (32¬∞C)",
                "Mortalit√© √©lev√©e - diagnostic",
                "Ventilation et qualit√© d'air",
                "Protocoles de vaccination",
                "Indices de conversion alimentaire"
            ],
            "en": [
                "Compass Performance Analysis Protocol",
                "Broiler chicken growth problems",
                "Optimal temperature for farming (32¬∞C)",
                "High mortality - diagnosis", 
                "Ventilation and air quality",
                "Vaccination protocols",
                "Feed conversion ratios"
            ],
            "es": [
                "Protocolos Compass an√°lisis rendimiento",
                "Problemas crecimiento pollos de engorde",
                "Temperatura √≥ptima crianza (32¬∞C)",
                "Mortalidad alta - diagn√≥stico",
                "Ventilaci√≥n y calidad aire",
                "Protocolos vacunaci√≥n",
                "√çndices conversi√≥n alimentaria"
            ]
        }
        
        topics = topics_by_language.get(lang, topics_by_language["fr"])
        
        return {
            "topics": topics,
            "language": lang,
            "count": len(topics),
            "validation_enabled": is_agricultural_validation_enabled() if AGRICULTURAL_VALIDATOR_AVAILABLE else False,
            "note": "Topics g√©n√©riques pour tous poulets de chair"
        }
    except Exception as e:
        logger.error(f"‚ùå Erreur topics: {e}")
        raise HTTPException(status_code=500, detail="Erreur r√©cup√©ration topics")

# =============================================================================
# NOUVEAUX ENDPOINTS DE DIAGNOSTIC
# =============================================================================

@router.get("/validation-stats")
async def get_validation_stats():
    """Statistiques du validateur agricole"""
    try:
        if not AGRICULTURAL_VALIDATOR_AVAILABLE:
            return {
                "error": "Validateur agricole non disponible",
                "available": False,
                "stats": None
            }
        
        stats = get_agricultural_validator_stats()
        
        return {
            "available": True,
            "validation_enabled": is_agricultural_validation_enabled(),
            "stats": stats,
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"‚ùå Erreur stats validation: {e}")
        raise HTTPException(status_code=500, detail="Erreur r√©cup√©ration stats")

@router.post("/test-validation")
async def test_validation(
    request_data: QuestionRequest,
    request: Request
):
    """Test endpoint pour tester la validation sans traitement"""
    try:
        question_text = request_data.text.strip()
        user_id = get_user_id_from_request(request)
        request_ip = request.client.host if request.client else "unknown"
        
        if not AGRICULTURAL_VALIDATOR_AVAILABLE:
            return {
                "error": "Validateur agricole non disponible",
                "available": False
            }
        
        # Test de validation
        is_valid, rejection_message, validation_confidence = await validate_question_agricultural_domain(
            question=question_text,
            language=request_data.language,
            user_id=user_id,
            request_ip=request_ip
        )
        
        return {
            "question": question_text,
            "language": request_data.language,
            "validation_passed": is_valid,
            "confidence": validation_confidence,
            "rejection_message": rejection_message if not is_valid else None,
            "validator_available": True,
            "validation_enabled": is_agricultural_validation_enabled(),
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"‚ùå Erreur test validation: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur test validation: {str(e)}")

# =============================================================================
# ENDPOINTS DEBUG
# =============================================================================

@router.get("/debug-database")
async def debug_database_info():
    """Debug des informations de base de donn√©es - CORRIG√â"""
    try:
        if not LOGGING_AVAILABLE or not logger_instance:
            return {
                "error": "Logging non disponible",
                "logging_available": LOGGING_AVAILABLE,
                "logger_instance": bool(logger_instance)
            }
        
        import sqlite3
        
        # V√©rifier la structure de la base
        with sqlite3.connect(logger_instance.db_path) as conn:
            # Lister les tables
            tables = conn.execute("""
                SELECT name FROM sqlite_master WHERE type='table'
            """).fetchall()
            
            # Structure de la table conversations
            schema = []
            count = 0
            recent = []
            
            if tables:
                try:
                    schema = conn.execute("PRAGMA table_info(conversations)").fetchall()
                    count = conn.execute("SELECT COUNT(*) FROM conversations").fetchone()[0]
                    recent = conn.execute("""
                        SELECT conversation_id, user_id, feedback, timestamp 
                        FROM conversations 
                        ORDER BY timestamp DESC 
                        LIMIT 5
                    """).fetchall()
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Erreur requ√™tes base: {e}")
        
        # M√©thodes disponibles
        logger_methods = [method for method in dir(logger_instance) if not method.startswith('_')]
        
        return {
            "logging_available": LOGGING_AVAILABLE,
            "database_path": logger_instance.db_path,
            "tables": [table[0] for table in tables],
            "conversations_schema": [{"name": col[1], "type": col[2]} for col in schema],
            "conversations_count": count,
            "recent_conversations": [
                {
                    "conversation_id": row[0],
                    "user_id": row[1],
                    "feedback": row[2],
                    "timestamp": row[3]
                } for row in recent
            ],
            "logger_methods": logger_methods,
            "has_save_conversation": hasattr(logger_instance, 'save_conversation'),
            "has_log_conversation": hasattr(logger_instance, 'log_conversation'),
            "has_update_feedback": hasattr(logger_instance, 'update_feedback'),
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"‚ùå Erreur debug database: {e}")
        return {
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

@router.get("/debug-system")
async def debug_system_info():
    """Endpoint de diagnostic syst√®me complet avec validateur"""
    import os
    import sys
    
    # Tests d'import d√©taill√©s
    import_tests = {}
    
    try:
        import app
        import_tests["app"] = "‚úÖ OK"
    except Exception as e:
        import_tests["app"] = f"‚ùå {str(e)}"
    
    try:
        import app.api.v1.auth
        import_tests["app.api.v1.auth"] = "‚úÖ OK"
        auth_attrs = dir(app.api.v1.auth)
        auth_functions = [attr for attr in auth_attrs if not attr.startswith('_') and callable(getattr(app.api.v1.auth, attr, None))]
        import_tests["app.api.v1.auth.functions"] = auth_functions
    except Exception as e:
        import_tests["app.api.v1.auth"] = f"‚ùå {str(e)}"
    
    # Test sp√©cifique du validateur agricole
    try:
        import app.api.v1.agricultural_domain_validator
        import_tests["agricultural_validator_module"] = "‚úÖ OK"
        
        validator_attrs = dir(app.api.v1.agricultural_domain_validator)
        validator_functions = [attr for attr in validator_attrs if not attr.startswith('_')]
        import_tests["agricultural_validator_functions"] = validator_functions
        
    except Exception as e:
        import_tests["agricultural_validator_module"] = f"‚ùå {str(e)}"
    
    return {
        "auth_available": AUTH_AVAILABLE,
        "agricultural_validator_available": AGRICULTURAL_VALIDATOR_AVAILABLE,
        "validation_enabled": is_agricultural_validation_enabled() if AGRICULTURAL_VALIDATOR_AVAILABLE else None,
        "openai_available": OPENAI_AVAILABLE,
        "logging_available": LOGGING_AVAILABLE,
        "current_directory": os.path.dirname(__file__),
        "python_path_sample": sys.path[:3],
        "import_tests": import_tests,
        "validator_stats": get_agricultural_validator_stats() if AGRICULTURAL_VALIDATOR_AVAILABLE else None,
        "timestamp": datetime.now().isoformat()
    }

@router.get("/debug-auth")
async def debug_auth_info(request: Request):
    """Endpoint de diagnostic rapide avec validation"""
    auth_header = request.headers.get("Authorization")
    
    return {
        "auth_available": AUTH_AVAILABLE,
        "agricultural_validator_available": AGRICULTURAL_VALIDATOR_AVAILABLE,
        "validation_enabled": is_agricultural_validation_enabled() if AGRICULTURAL_VALIDATOR_AVAILABLE else None,
        "auth_header_present": bool(auth_header),
        "auth_header_preview": auth_header[:50] + "..." if auth_header else None,
        "openai_available": OPENAI_AVAILABLE,
        "logging_available": LOGGING_AVAILABLE,
        "timestamp": datetime.now().isoformat()
    }

@router.post("/test-utf8")
async def test_utf8_direct(request: Request):
    """Test endpoint pour UTF-8 direct avec validation"""
    try:
        # R√©cup√©rer le body brut
        body = await request.body()
        body_str = body.decode('utf-8')
        
        logger.info(f"üìù Body brut re√ßu: {body_str}")
        
        # Parser JSON manuellement
        import json
        data = json.loads(body_str)
        
        question_text = data.get('text', '')
        language = data.get('language', 'fr')
        
        logger.info(f"üìù Question extraite: {question_text}")
        logger.info(f"üî§ Caract√®res sp√©ciaux: {[c for c in question_text if ord(c) > 127]}")
        
        # Test de validation
        user_id = get_user_id_from_request(request)
        request_ip = request.client.host if request.client else "unknown"
        
        is_valid, rejection_message, validation_confidence = await validate_question_agricultural_domain(
            question=question_text,
            language=language,
            user_id=user_id,
            request_ip=request_ip
        )
        
        if not is_valid:
            return {
                "success": False,
                "question_received": question_text,
                "special_chars_detected": [c for c in question_text if ord(c) > 127],
                "validation_passed": False,
                "rejection_message": rejection_message,
                "confidence": validation_confidence,
                "method": "direct_body_parsing_with_validation",
                "timestamp": datetime.now().isoformat()
            }
        
        # Traitement direct seulement si valid√©
        answer = await process_question_openai(question_text, language, "fast")
        
        return {
            "success": True,
            "question_received": question_text,
            "special_chars_detected": [c for c in question_text if ord(c) > 127],
            "validation_passed": True,
            "confidence": validation_confidence,
            "response": answer,
            "method": "direct_body_parsing_with_validation",
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"‚ùå Erreur test UTF-8: {e}")
        return {
            "success": False,
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

# =============================================================================
# CONFIGURATION
# =============================================================================

if OPENAI_AVAILABLE and openai:
    openai_api_key = os.getenv('OPENAI_API_KEY')
    if openai_api_key:
        openai.api_key = openai_api_key
        logger.info("‚úÖ OpenAI configur√© avec succ√®s")
    else:
        logger.warning("‚ö†Ô∏è OpenAI API key non trouv√©e")
else:
    logger.warning("‚ö†Ô∏è Module OpenAI non disponible")

logger.info("‚úÖ EXPERT.PY R√â√âCRIT AVEC CORRECTIONS COMPL√àTES")
logger.info(f"üîß AUTH_AVAILABLE: {AUTH_AVAILABLE}")
logger.info(f"üåæ AGRICULTURAL_VALIDATOR_AVAILABLE: {AGRICULTURAL_VALIDATOR_AVAILABLE}")
logger.info(f"üåæ VALIDATION_ENABLED: {is_agricultural_validation_enabled() if AGRICULTURAL_VALIDATOR_AVAILABLE else 'N/A'}")
logger.info(f"üíæ LOGGING_AVAILABLE: {LOGGING_AVAILABLE}")
logger.info(f"ü§ñ OPENAI_AVAILABLE: {OPENAI_AVAILABLE}")
logger.info("üîß CORRECTIONS APPLIQU√âES: save_conversation_auto + submit_feedback")