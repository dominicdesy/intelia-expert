"""
app/api/v1/conversation_extraction.py - Extraction d'entit√©s et logique IA

üîß MODULE 2/3: Extraction intelligente d'entit√©s avec OpenAI et fallback - VERSION S√âCURIS√âE
‚úÖ Extraction OpenAI avec prompts optimis√©s
‚úÖ Fallback robuste sans d√©pendances
‚úÖ Gestion d'erreurs compl√®te
‚úÖ Synchronisation weight/weight_grams
‚úÖ NOUVELLES S√âCURISATIONS AJOUT√âES pour √©viter les crashes
"""

import os
import json
import logging
import re
import asyncio
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime

# Import OpenAI s√©curis√© pour extraction intelligente
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    openai = None

from .conversation_entities import IntelligentEntities, IntelligentConversationContext, safe_int_conversion, safe_float_conversion

logger = logging.getLogger(__name__)

class ConversationEntityExtractor:
    """Extracteur d'entit√©s conversationnelles avec IA et fallback robuste - VERSION S√âCURIS√âE"""
    
    def __init__(self):
        self.ai_enhancement_enabled = os.getenv('AI_ENHANCEMENT_ENABLED', 'true').lower() == 'true'
        self.ai_enhancement_model = os.getenv('AI_ENHANCEMENT_MODEL', 'gpt-4o-mini')
        self.ai_enhancement_timeout = int(os.getenv('AI_ENHANCEMENT_TIMEOUT', '15'))
        
        logger.info(f"ü§ñ [Extractor] Initialis√© - IA: {'‚úÖ' if self.ai_enhancement_enabled else '‚ùå'}")

    async def extract_entities_ai_enhanced(
        self, 
        message: str, 
        language: str = "fr",
        conversation_context: Optional[IntelligentConversationContext] = None
    ) -> IntelligentEntities:
        """üîß FIX 6: Extraction d'entit√©s avec fallback robuste et gestion d'erreurs am√©lior√©e - VERSION S√âCURIS√âE"""
        
        # Tentative IA si disponible
        if self.ai_enhancement_enabled and OPENAI_AVAILABLE and openai:
            try:
                entities = await self._extract_entities_openai_safe(message, language, conversation_context)
                if entities and entities.confidence_overall > 0.3:
                    return entities.validate_and_correct_safe()
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è [AI Extraction] √âchec IA: {e}")
        
        # üîß FIX 7: Fallback robuste sans d√©pendances manquantes
        logger.info("üîÑ [Fallback] Utilisation extraction basique robuste")
        try:
            entities = await self._extract_entities_basic_robust_safe(message, language)
            entities.extraction_method = "fallback_robust"
            return entities.validate_and_correct_safe()
        except Exception as fallback_error:
            logger.error(f"‚ùå [Fallback] √âchec fallback: {fallback_error}")
            # Fallback ultime: entit√©s vides mais valides
            return IntelligentEntities(
                extraction_method="empty_fallback",
                extraction_success=False,
                confidence_overall=0.0
            )

    async def _extract_entities_openai_safe(
        self, 
        message: str, 
        language: str = "fr",
        conversation_context: Optional[IntelligentConversationContext] = None
    ) -> IntelligentEntities:
        """üîß NOUVELLE M√âTHODE S√âCURIS√âE: Extraction d'entit√©s par OpenAI avec gestion robuste"""
        
        try:
            return await self._extract_entities_openai(message, language, conversation_context)
        except Exception as e:
            logger.error(f"‚ùå [OpenAI Safe] Erreur extraction OpenAI: {e}")
            # Retourner entit√©s vides mais valides
            return IntelligentEntities(
                extraction_method="openai_failed",
                extraction_success=False,
                confidence_overall=0.0
            )

    async def _extract_entities_openai(
        self, 
        message: str, 
        language: str = "fr",
        conversation_context: Optional[IntelligentConversationContext] = None
    ) -> IntelligentEntities:
        """Extraction d'entit√©s par OpenAI avec gestion robuste"""
        
        # Contexte pour l'IA avec gestion s√©curis√©e
        context_info = ""
        if conversation_context and conversation_context.consolidated_entities:
            try:
                existing_entities = conversation_context.consolidated_entities.to_dict_safe()
                if existing_entities and not existing_entities.get('error'):
                    context_info = f"\n\nEntit√©s d√©j√† connues:\n{json.dumps(existing_entities, ensure_ascii=False, indent=2)}"
            except Exception as context_error:
                logger.warning(f"‚ö†Ô∏è [OpenAI] Erreur g√©n√©ration contexte: {context_error}")
                context_info = ""
        
        extraction_prompt = f"""Tu es un expert en extraction d'informations v√©t√©rinaires pour l'aviculture. Analyse ce message et extrait TOUTES les informations pertinentes.

Message: "{message}"{context_info}

INSTRUCTIONS CRITIQUES:
1. Extrait toutes les informations, m√™me partielles ou implicites
2. Utilise le contexte existant pour √©viter les doublons
3. Assigne des scores de confiance (0.0 √† 1.0) bas√©s sur la pr√©cision
4. Inf√©rer des informations logiques (ex: si "mes poulets Ross 308", alors breed_type="specific")
5. Convertir automatiquement les unit√©s (semaines -> jours, kg -> grammes)
6. IMPORTANT: D√©tecte le SEXE avec variations multilingues
7. POIDS: Toujours en grammes (weight ET weight_grams synchronis√©s)

SEXES SUPPORT√âS:
- FR: m√¢les, m√¢le, femelles, femelle, mixte, troupeau mixte, coqs, poules
- EN: males, male, females, female, mixed, mixed flock, roosters, hens  
- ES: machos, macho, hembras, hembra, mixto, lote mixto, gallos, gallinas

R√©ponds UNIQUEMENT avec ce JSON exact:
```json
{{
  "breed": "race_d√©tect√©e_ou_null",
  "breed_confidence": 0.0_√†_1.0,
  "breed_type": "specific/generic/null",
  
  "sex": "sexe_d√©tect√©_ou_null",
  "sex_confidence": 0.0_√†_1.0,
  
  "age": nombre_jours_ou_null,
  "age_days": nombre_jours_ou_null,
  "age_weeks": nombre_semaines_ou_null,
  "age_confidence": 0.0_√†_1.0,
  
  "weight": poids_grammes_ou_null,
  "weight_grams": poids_grammes_ou_null,
  "weight_confidence": 0.0_√†_1.0,
  "expected_weight_range": [min_grammes, max_grammes] ou null,
  "growth_rate": "normal/slow/fast/null",
  
  "mortality_rate": pourcentage_ou_null,
  "mortality_confidence": 0.0_√†_1.0,
  "symptoms": ["sympt√¥me1", "sympt√¥me2"] ou [],
  "health_status": "good/concerning/critical/null",
  
  "temperature": celsius_ou_null,
  "humidity": pourcentage_ou_null,
  "housing_type": "type_ou_null",
  
  "feed_type": "type_ou_null",
  "flock_size": nombre_ou_null,
  
  "problem_severity": "low/medium/high/critical/null",
  "intervention_urgency": "none/monitor/act/urgent/null",
  
  "extraction_method": "openai",
  "confidence_overall": 0.0_√†_1.0
}}
```

EXEMPLES:
- "Ross 308 m√¢les" ‚Üí breed="Ross 308", sex="m√¢les", breed_confidence=0.95, sex_confidence=0.95
- "Ross 308 male" ‚Üí breed="Ross 308", sex="m√¢les", breed_confidence=0.95, sex_confidence=0.95
- "3 semaines" ‚Üí age_weeks=3, age_days=21, age_confidence=0.9
- "800g" ‚Üí weight=800, weight_grams=800, weight_confidence=0.9
"""

        api_key = os.getenv('OPENAI_API_KEY')
        if not api_key:
            raise Exception("Cl√© API OpenAI manquante")
        
        # Gestion d'erreurs sp√©cifique OpenAI
        try:
            # Cr√©er le client OpenAI
            client = openai.AsyncOpenAI(api_key=api_key)
            
            response = await client.chat.completions.create(
                model=self.ai_enhancement_model,
                messages=[
                    {"role": "system", "content": "Tu es un extracteur d'entit√©s expert en aviculture. R√©ponds UNIQUEMENT avec du JSON valide."},
                    {"role": "user", "content": extraction_prompt}
                ],
                temperature=0.1,
                max_tokens=800,
                timeout=self.ai_enhancement_timeout
            )
            
            answer = response.choices[0].message.content.strip()
            
        except asyncio.TimeoutError:
            raise Exception("Timeout lors de l'appel OpenAI")
        except Exception as e:
            raise Exception(f"Erreur OpenAI: {e}")
        
        # Extraire le JSON de mani√®re s√©curis√©e
        try:
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', answer, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
            else:
                json_match = re.search(r'\{.*\}', answer, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                else:
                    raise Exception("Pas de JSON trouv√© dans la r√©ponse IA")
        except Exception as json_extract_error:
            logger.error(f"‚ùå [OpenAI] Erreur extraction JSON: {json_extract_error}")
            raise Exception(f"Erreur extraction JSON: {json_extract_error}")
        
        # Parser et cr√©er les entit√©s avec gestion s√©curis√©e
        try:
            data = json.loads(json_str)
            
            # üîß FIX 8: Conversion s√©curis√©e des types pour √©viter str/int comparaisons
            age_days_safe = safe_int_conversion(data.get("age_days") or data.get("age"))
            age_weeks_safe = safe_float_conversion(data.get("age_weeks"))
            weight_safe = safe_float_conversion(data.get("weight_grams") or data.get("weight"))
            
            # üîß NOUVELLES S√âCURISATIONS: Construction avec hasattr et try/catch
            try:
                entities = IntelligentEntities(
                    breed=data.get("breed"),
                    breed_confidence=safe_float_conversion(data.get("breed_confidence")) or 0.0,
                    breed_type=data.get("breed_type"),
                    
                    sex=data.get("sex"),
                    sex_confidence=safe_float_conversion(data.get("sex_confidence")) or 0.0,
                    
                    # üîß FIX: Synchronisation √¢ge s√©curis√©e
                    age=age_days_safe,
                    age_days=age_days_safe,
                    age_weeks=age_weeks_safe,
                    age_confidence=safe_float_conversion(data.get("age_confidence")) or 0.0,
                    age_last_updated=datetime.now(),
                    
                    # üîß FIX: Synchronisation poids s√©curis√©e
                    weight=weight_safe,
                    weight_grams=weight_safe,
                    weight_confidence=safe_float_conversion(data.get("weight_confidence")) or 0.0,
                    expected_weight_range=tuple(data["expected_weight_range"]) if data.get("expected_weight_range") and isinstance(data["expected_weight_range"], list) and len(data["expected_weight_range"]) == 2 else None,
                    growth_rate=data.get("growth_rate"),
                    
                    mortality_rate=safe_float_conversion(data.get("mortality_rate")),
                    mortality_confidence=safe_float_conversion(data.get("mortality_confidence")) or 0.0,
                    symptoms=data.get("symptoms", []) if isinstance(data.get("symptoms"), list) else [],
                    health_status=data.get("health_status"),
                    
                    temperature=safe_float_conversion(data.get("temperature")),
                    humidity=safe_float_conversion(data.get("humidity")),
                    housing_type=data.get("housing_type"),
                    
                    feed_type=data.get("feed_type"),
                    flock_size=safe_int_conversion(data.get("flock_size")),
                    
                    problem_severity=data.get("problem_severity"),
                    intervention_urgency=data.get("intervention_urgency"),
                    
                    extraction_method="openai",
                    last_ai_update=datetime.now(),
                    confidence_overall=safe_float_conversion(data.get("confidence_overall")) or 0.0,
                    extraction_success=True
                )
                
                return entities
                
            except Exception as entity_creation_error:
                logger.error(f"‚ùå [OpenAI] Erreur cr√©ation entit√©s: {entity_creation_error}")
                # Fallback: cr√©er entit√©s vides mais valides
                return IntelligentEntities(
                    extraction_method="openai_creation_failed",
                    extraction_success=False,
                    confidence_overall=0.0
                )
            
        except json.JSONDecodeError as e:
            raise Exception(f"Erreur parsing JSON IA: {e}")

    async def _extract_entities_basic_robust_safe(self, message: str, language: str) -> IntelligentEntities:
        """üîß NOUVELLE M√âTHODE S√âCURIS√âE: Extraction d'entit√©s basique robuste sans d√©pendances manquantes"""
        
        try:
            return await self._extract_entities_basic_robust(message, language)
        except Exception as e:
            logger.error(f"‚ùå [Basic Safe] Erreur extraction basique: {e}")
            # Fallback entit√©s vides mais valides
            return IntelligentEntities(
                extraction_method="basic_failed",
                extraction_success=False,
                confidence_overall=0.0
            )

    async def _extract_entities_basic_robust(self, message: str, language: str) -> IntelligentEntities:
        """üîß FIX 9: Extraction d'entit√©s basique robuste sans d√©pendances manquantes - VERSION S√âCURIS√âE"""
        
        try:
            entities = IntelligentEntities(extraction_method="basic_robust")
            message_lower = message.lower()
            
            # Race sp√©cifique avec gestion d'erreurs
            specific_breeds = [
                r'ross\s*308', r'ross\s*708', r'cobb\s*500', r'cobb\s*700',
                r'hubbard\s*flex', r'arbor\s*acres'
            ]
            
            for pattern in specific_breeds:
                try:
                    match = re.search(pattern, message_lower, re.IGNORECASE)
                    if match:
                        breed_found = match.group(0).strip().replace(' ', ' ').title()
                        
                        # üîß S√âCURISATION: Utiliser hasattr avant assignation
                        if hasattr(entities, 'breed'):
                            entities.breed = breed_found
                        if hasattr(entities, 'breed_type'):
                            entities.breed_type = "specific"
                        if hasattr(entities, 'breed_confidence'):
                            entities.breed_confidence = 0.9
                        
                        logger.debug(f"üîç [BasicRobust] Race sp√©cifique d√©tect√©e: {breed_found}")
                        break
                except Exception as breed_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur d√©tection race: {breed_error}")
                    continue
            
            # EXTRACTION SEXE ROBUSTE avec s√©curisation
            sex_patterns = {
                "fr": [
                    (r'\bm√¢les?\b', 'm√¢les'),
                    (r'\bmales?\b', 'm√¢les'),
                    (r'\bcoqs?\b', 'm√¢les'),
                    (r'\bfemelles?\b', 'femelles'),
                    (r'\bfemales?\b', 'femelles'),
                    (r'\bpoules?\b', 'femelles'),
                    (r'\bmixte\b', 'mixte'),
                    (r'\btroupeau\s+mixte\b', 'mixte')
                ],
                "en": [
                    (r'\bmales?\b', 'males'),
                    (r'\brooster\b', 'males'),
                    (r'\bfemales?\b', 'females'),
                    (r'\bhens?\b', 'females'),
                    (r'\bmixed?\b', 'mixed'),
                    (r'\bmixed\s+flock\b', 'mixed')
                ],
                "es": [
                    (r'\bmachos?\b', 'machos'),
                    (r'\bgallos?\b', 'machos'),
                    (r'\bhembras?\b', 'hembras'),
                    (r'\bgallinas?\b', 'hembras'),
                    (r'\bmixto\b', 'mixto'),
                    (r'\blote\s+mixto\b', 'mixto')
                ]
            }
            
            patterns = sex_patterns.get(language, sex_patterns["fr"])
            
            for pattern, sex_name in patterns:
                try:
                    if re.search(pattern, message_lower, re.IGNORECASE):
                        # üîß S√âCURISATION: V√©rifier hasattr avant assignation
                        if hasattr(entities, 'sex'):
                            entities.sex = sex_name
                        if hasattr(entities, 'sex_confidence'):
                            entities.sex_confidence = 0.8
                        
                        logger.debug(f"üîç [BasicRobust] Sexe d√©tect√©: {sex_name}")
                        break
                except Exception as sex_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur d√©tection sexe: {sex_error}")
                    continue
            
            # üîß FIX 10: √Çge avec conversion s√©curis√©e des types
            age_patterns = [
                (r'(\d+)\s*jours?', 1, "days"),
                (r'(\d+)\s*semaines?', 7, "weeks"),
                (r'(\d+)\s*days?', 1, "days"),
                (r'(\d+)\s*weeks?', 7, "weeks")
            ]
            
            for pattern, multiplier, unit in age_patterns:
                try:
                    match = re.search(pattern, message_lower, re.IGNORECASE)
                    if match:
                        value = safe_int_conversion(match.group(1))
                        if value is None:
                            continue
                        
                        if unit == "weeks":
                            age_weeks = float(value)
                            age_days = value * 7
                        else:
                            age_days = value
                            age_weeks = round(value / 7, 1)
                        
                        # üîß S√âCURISATION: Assignation avec hasattr
                        if hasattr(entities, 'age_weeks'):
                            entities.age_weeks = age_weeks
                        if hasattr(entities, 'age_days'):
                            entities.age_days = age_days
                        if hasattr(entities, 'age'):
                            entities.age = age_days
                        
                        # Validation √¢ge r√©aliste avec gestion s√©curis√©e
                        if age_days and 0 < age_days <= 365:
                            if hasattr(entities, 'age_confidence'):
                                entities.age_confidence = 0.8
                        else:
                            if hasattr(entities, 'age_confidence'):
                                entities.age_confidence = 0.3
                        
                        if hasattr(entities, 'age_last_updated'):
                            entities.age_last_updated = datetime.now()
                        
                        logger.debug(f"üîç [BasicRobust] √Çge d√©tect√©: {age_days}j ({age_weeks}sem)")
                        break
                        
                except (ValueError, TypeError) as e:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur conversion √¢ge: {e}")
                    continue
                except Exception as age_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur g√©n√©rale √¢ge: {age_error}")
                    continue
            
            # üîß FIX 11: Poids avec synchronisation weight/weight_grams et validation robuste
            weight_patterns = [
                (r'(\d+(?:\.\d+)?)\s*g\b', 1, "grams"),
                (r'(\d+(?:\.\d+)?)\s*kg', 1000, "kg"),
                (r'p√®sent?\s+(\d+(?:\.\d+)?)', 1, "grams"),
                (r'weigh\s+(\d+(?:\.\d+)?)', 1, "grams")
            ]
            
            for pattern, multiplier, unit in weight_patterns:
                try:
                    match = re.search(pattern, message_lower, re.IGNORECASE)
                    if match:
                        weight_value = safe_float_conversion(match.group(1))
                        if weight_value is None:
                            continue
                        
                        weight = weight_value * multiplier
                        
                        # Validation et correction automatique
                        if weight < 10:  # Probablement en kg
                            weight *= 1000
                            weight_confidence = 0.7  # Confiance r√©duite car correction
                        elif weight > 10000:  # Trop √©lev√©
                            weight_confidence = 0.3
                        else:
                            weight_confidence = 0.8
                        
                        # üîß S√âCURISATION: Synchronisation weight/weight_grams avec hasattr
                        if hasattr(entities, 'weight'):
                            entities.weight = weight
                        if hasattr(entities, 'weight_grams'):
                            entities.weight_grams = weight
                        if hasattr(entities, 'weight_confidence'):
                            entities.weight_confidence = weight_confidence
                        
                        logger.debug(f"üîç [BasicRobust] Poids d√©tect√©: {weight}g")
                        break
                        
                except (ValueError, TypeError) as e:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur conversion poids: {e}")
                    continue
                except Exception as weight_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur g√©n√©rale poids: {weight_error}")
                    continue
            
            # Mortalit√© avec conversion s√©curis√©e
            mortality_patterns = [
                r'mortalit√©.*?(\d+(?:\.\d+)?)%',
                r'mortality.*?(\d+(?:\.\d+)?)%',
                r'(\d+(?:\.\d+)?)%.*?mort'
            ]
            
            for pattern in mortality_patterns:
                try:
                    match = re.search(pattern, message_lower, re.IGNORECASE)
                    if match:
                        mortality_value = safe_float_conversion(match.group(1))
                        if mortality_value is not None and 0 <= mortality_value <= 100:
                            # üîß S√âCURISATION: Assignation avec hasattr
                            if hasattr(entities, 'mortality_rate'):
                                entities.mortality_rate = mortality_value
                            if hasattr(entities, 'mortality_confidence'):
                                entities.mortality_confidence = 0.8
                            
                            logger.debug(f"üîç [BasicRobust] Mortalit√© d√©tect√©e: {mortality_value}%")
                            break
                except (ValueError, TypeError) as e:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur conversion mortalit√©: {e}")
                    continue
                except Exception as mortality_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur g√©n√©rale mortalit√©: {mortality_error}")
                    continue
            
            # Temp√©rature avec conversion s√©curis√©e
            temp_patterns = [
                r'temp√©rature.*?(\d+(?:\.\d+)?)¬∞?c',
                r'temperature.*?(\d+(?:\.\d+)?)¬∞?c',
                r'(\d+(?:\.\d+)?)¬∞c'
            ]
            
            for pattern in temp_patterns:
                try:
                    match = re.search(pattern, message_lower, re.IGNORECASE)
                    if match:
                        temp_value = safe_float_conversion(match.group(1))
                        if temp_value is not None and 10 <= temp_value <= 50:  # Plage r√©aliste
                            # üîß S√âCURISATION: Assignation avec hasattr
                            if hasattr(entities, 'temperature'):
                                entities.temperature = temp_value
                            
                            logger.debug(f"üîç [BasicRobust] Temp√©rature d√©tect√©e: {temp_value}¬∞C")
                            break
                except (ValueError, TypeError) as e:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur conversion temp√©rature: {e}")
                    continue
                except Exception as temp_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur g√©n√©rale temp√©rature: {temp_error}")
                    continue
            
            # üîß FIX 12: Calcul confiance globale s√©curis√©
            try:
                confidence_scores = []
                
                # üîß S√âCURISATION: V√©rifier hasattr pour chaque champ
                if hasattr(entities, 'breed_confidence') and entities.breed_confidence > 0:
                    confidence_scores.append(entities.breed_confidence)
                if hasattr(entities, 'sex_confidence') and entities.sex_confidence > 0:
                    confidence_scores.append(entities.sex_confidence)
                if hasattr(entities, 'age_confidence') and entities.age_confidence > 0:
                    confidence_scores.append(entities.age_confidence)
                if hasattr(entities, 'weight_confidence') and entities.weight_confidence > 0:
                    confidence_scores.append(entities.weight_confidence)
                if hasattr(entities, 'mortality_confidence') and entities.mortality_confidence > 0:
                    confidence_scores.append(entities.mortality_confidence)
                
                if confidence_scores:
                    overall_confidence = sum(confidence_scores) / len(confidence_scores)
                else:
                    overall_confidence = 0.0
                
                # üîß S√âCURISATION: Assignation finale avec hasattr
                if hasattr(entities, 'confidence_overall'):
                    entities.confidence_overall = overall_confidence
                if hasattr(entities, 'extraction_success'):
                    entities.extraction_success = overall_confidence > 0.1
                
            except Exception as confidence_error:
                logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur calcul confiance: {confidence_error}")
                # Fallback: confiance minimale
                if hasattr(entities, 'confidence_overall'):
                    entities.confidence_overall = 0.0
                if hasattr(entities, 'extraction_success'):
                    entities.extraction_success = False
            
            return entities
            
        except Exception as e:
            logger.error(f"‚ùå [BasicRobust] Erreur globale extraction: {e}")
            # Fallback ultime: entit√©s vides mais valides
            return IntelligentEntities(
                extraction_method="basic_robust_failed",
                extraction_success=False,
                confidence_overall=0.0
            )


class ConversationClarificationHandler:
    """Gestionnaire de clarifications conversationnelles avec syst√®me d'enrichissement intelligent - VERSION S√âCURIS√âE"""
    
    def __init__(self):
        logger.info("üîÑ [ClarificationHandler] Syst√®me de clarification initialis√©")
    
    def build_enriched_question_from_clarification(
        self,
        original_question: str,
        clarification_response: str,
        conversation_context: Optional[IntelligentConversationContext] = None
    ) -> str:
        """
        Enrichit la question originale avec la clarification de mani√®re robuste - VERSION S√âCURIS√âE
        
        Exemple:
        - Original: "Quel est le poids d'un poulet de 12 jours ?"
        - Clarification: "Ross 308 m√¢les"
        - Enrichi: "Quel est le poids d'un poulet Ross 308 m√¢le de 12 jours ?"
        """
        
        try:
            # Analyser la clarification pour extraire les entit√©s
            clarification_lower = clarification_response.lower().strip()
            
            # D√©tection race avec gestion d'erreurs
            breed_info = self._extract_breed_from_clarification_safe(clarification_lower)
            sex_info = self._extract_sex_from_clarification_safe(clarification_lower)
            
            # Construire l'enrichissement
            enrichments = []
            
            if breed_info:
                enrichments.append(breed_info)
            
            if sex_info:
                enrichments.append(sex_info)
            
            # Int√©grer dans la question originale
            if enrichments:
                enriched_question = self._integrate_enrichments_into_question_safe(
                    original_question, 
                    enrichments
                )
                
                logger.info(f"‚úÖ [Clarification] Question enrichie r√©ussie")
                logger.info(f"  üìù Original: {original_question}")
                logger.info(f"  üîÅ Enrichi: {enriched_question}")
                
                return enriched_question
            else:
                # Fallback: concat√©nation simple
                fallback_question = f"{original_question} Contexte: {clarification_response}"
                logger.warning(f"‚ö†Ô∏è [Clarification] Fallback utilis√©: {fallback_question}")
                return fallback_question
                
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur enrichissement: {e}")
            # Fallback ultime: question originale
            return original_question
    
    def _extract_breed_from_clarification_safe(self, clarification: str) -> Optional[str]:
        """üîß NOUVELLE M√âTHODE S√âCURIS√âE: Extrait la race de la r√©ponse de clarification"""
        
        try:
            return self._extract_breed_from_clarification(clarification)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è [Clarification] Erreur extraction race: {e}")
            return None
    
    def _extract_breed_from_clarification(self, clarification: str) -> Optional[str]:
        """Extrait la race de la r√©ponse de clarification"""
        
        breed_patterns = [
            r'ross\s*308',
            r'ross\s*708', 
            r'cobb\s*500',
            r'cobb\s*700',
            r'hubbard\s*flex',
            r'arbor\s*acres'
        ]
        
        for pattern in breed_patterns:
            try:
                match = re.search(pattern, clarification, re.IGNORECASE)
                if match:
                    breed = match.group(0).strip().replace(' ', ' ').title()
                    logger.debug(f"üîç [Clarification] Race d√©tect√©e: {breed}")
                    return breed
            except Exception as pattern_error:
                logger.warning(f"‚ö†Ô∏è [Clarification] Erreur pattern race: {pattern_error}")
                continue
        
        # Patterns g√©n√©riques
        generic_patterns = [
            r'poulets?\s+de\s+chair',
            r'broilers?',
            r'poulets?'
        ]
        
        for pattern in generic_patterns:
            try:
                if re.search(pattern, clarification, re.IGNORECASE):
                    logger.debug(f"üîç [Clarification] Race g√©n√©rique d√©tect√©e")
                    return "poulets de chair"
            except Exception as generic_error:
                logger.warning(f"‚ö†Ô∏è [Clarification] Erreur pattern g√©n√©rique: {generic_error}")
                continue
        
        return None
    
    def _extract_sex_from_clarification_safe(self, clarification: str) -> Optional[str]:
        """üîß NOUVELLE M√âTHODE S√âCURIS√âE: Extrait le sexe de la r√©ponse de clarification"""
        
        try:
            return self._extract_sex_from_clarification(clarification)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è [Clarification] Erreur extraction sexe: {e}")
            return None
    
    def _extract_sex_from_clarification(self, clarification: str) -> Optional[str]:
        """Extrait le sexe de la r√©ponse de clarification"""
        
        sex_patterns = [
            (r'\bm√¢les?\b', 'm√¢les'),
            (r'\bmales?\b', 'm√¢les'),
            (r'\bcoqs?\b', 'm√¢les'),
            (r'\bfemelles?\b', 'femelles'),
            (r'\bfemales?\b', 'femelles'),
            (r'\bpoules?\b', 'femelles'),
            (r'\bmixte\b', 'mixte'),
            (r'\btroupeau\s+mixte\b', 'mixte')
        ]
        
        for pattern, sex_name in sex_patterns:
            try:
                if re.search(pattern, clarification, re.IGNORECASE):
                    logger.debug(f"üîç [Clarification] Sexe d√©tect√©: {sex_name}")
                    return sex_name
            except Exception as sex_error:
                logger.warning(f"‚ö†Ô∏è [Clarification] Erreur pattern sexe: {sex_error}")
                continue
        
        return None
    
    def _integrate_enrichments_into_question_safe(
        self, 
        original_question: str, 
        enrichments: list
    ) -> str:
        """üîß NOUVELLE M√âTHODE S√âCURIS√âE: Int√®gre intelligemment les enrichissements dans la question"""
        
        try:
            return self._integrate_enrichments_into_question(original_question, enrichments)
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur int√©gration enrichissements: {e}")
            # Fallback: concat√©nation simple
            enrichment_text = ' '.join(enrichments) if enrichments else ""
            return f"{original_question} (Contexte: {enrichment_text})"
    
    def _integrate_enrichments_into_question(
        self, 
        original_question: str, 
        enrichments: list
    ) -> str:
        """Int√®gre intelligemment les enrichissements dans la question"""
        
        # Patterns de questions communes o√π ins√©rer les enrichissements
        question_patterns = [
            # "Quel est le poids d'un poulet de X jours ?"
            (r'(quel\s+est\s+le\s+poids\s+d.un\s+)poulet(\s+de\s+\d+\s+jours?)',
             r'\1{} \2'),
            
            # "Mes poulets de X jours p√®sent Y"
            (r'(mes\s+)poulets?(\s+de\s+\d+\s+jours?)',
             r'\1{} \2'),
            
            # "Comment nourrir des poulets de X semaines ?"
            (r'(comment\s+\w+\s+des\s+)poulets?(\s+de\s+\d+\s+semaines?)',
             r'\1{} \2'),
            
            # Pattern g√©n√©rique "poulet" ‚Üí "poulet [race] [sexe]"
            (r'\bpoulets?\b',
             '{}')
        ]
        
        enrichment_text = ' '.join(enrichments)
        
        for pattern, replacement in question_patterns:
            try:
                if re.search(pattern, original_question, re.IGNORECASE):
                    enriched = re.sub(
                        pattern, 
                        replacement.format(enrichment_text),
                        original_question, 
                        flags=re.IGNORECASE
                    )
                    
                    # Nettoyer les espaces multiples
                    enriched = re.sub(r'\s+', ' ', enriched).strip()
                    
                    return enriched
            except Exception as pattern_error:
                logger.warning(f"‚ö†Ô∏è [Clarification] Erreur pattern int√©gration: {pattern_error}")
                continue
        
        # Fallback: ajout en contexte
        return f"{original_question} (Contexte: {enrichment_text})"
    
    def detect_clarification_state(
        self, 
        conversation_context: IntelligentConversationContext
    ) -> Tuple[bool, Optional[str]]:
        """
        D√©tecte si on est en attente de clarification - VERSION S√âCURIS√âE
        
        Returns:
            (is_awaiting_clarification, original_question_text)
        """
        
        try:
            # V√©rifier l'√©tat dans le contexte
            if hasattr(conversation_context, 'pending_clarification') and conversation_context.pending_clarification:
                try:
                    original_question_msg = conversation_context.find_original_question()
                    
                    if original_question_msg:
                        return True, original_question_msg.message
                except Exception as find_error:
                    logger.warning(f"‚ö†Ô∏è [Clarification] Erreur recherche question originale: {find_error}")
            
            # V√âRIFIER AUSSI L'√âTAT CLARIFICATION CRITIQUE avec s√©curisation
            if (hasattr(conversation_context, 'critical_clarification_active') and 
                conversation_context.critical_clarification_active and 
                hasattr(conversation_context, 'original_question_pending') and
                conversation_context.original_question_pending):
                
                return True, conversation_context.original_question_pending
            
            # Fallback: analyser les derniers messages
            try:
                if hasattr(conversation_context, 'messages') and len(conversation_context.messages) >= 2:
                    last_assistant_msg = None
                    
                    # Chercher le dernier message assistant
                    for msg in reversed(conversation_context.messages):
                        try:
                            if hasattr(msg, 'role') and msg.role == "assistant":
                                last_assistant_msg = msg
                                break
                        except Exception as msg_error:
                            logger.warning(f"‚ö†Ô∏è [Clarification] Erreur v√©rification message: {msg_error}")
                            continue
                    
                    if last_assistant_msg and hasattr(last_assistant_msg, 'message'):
                        # Mots-cl√©s indiquant une demande de clarification
                        clarification_keywords = [
                            "j'ai besoin de", "pouvez-vous pr√©ciser", "quelle est la race",
                            "quel est le sexe", "de quelle race", "m√¢les ou femelles"
                        ]
                        
                        msg_lower = last_assistant_msg.message.lower()
                        
                        if any(keyword in msg_lower for keyword in clarification_keywords):
                            # Chercher la question utilisateur pr√©c√©dente
                            try:
                                original_question = conversation_context.get_last_user_question()
                                
                                if original_question and hasattr(original_question, 'message'):
                                    return True, original_question.message
                            except Exception as user_question_error:
                                logger.warning(f"‚ö†Ô∏è [Clarification] Erreur recherche derni√®re question: {user_question_error}")
            except Exception as fallback_error:
                logger.warning(f"‚ö†Ô∏è [Clarification] Erreur analyse fallback: {fallback_error}")
            
            return False, None
            
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur d√©tection √©tat: {e}")
            return False, None

    def check_if_clarification_needed(
        self,
        question: str,
        rag_response: Any,
        context: Optional[IntelligentConversationContext],
        language: str = "fr"
    ) -> Tuple[bool, List[str]]:
        """D√©termine si une clarification est n√©cessaire - VERSION S√âCURIS√âE"""
        
        try:
            if not context:
                return False, []
            
            # Acc√®s s√©curis√© aux entit√©s consolid√©es
            if not hasattr(context, 'consolidated_entities'):
                return False, []
            
            entities = context.consolidated_entities
            
            try:
                missing_info = entities.get_critical_missing_info()
            except Exception as missing_error:
                logger.warning(f"‚ö†Ô∏è [Clarification] Erreur get_critical_missing_info: {missing_error}")
                missing_info = []
            
            clarification_questions = []
            
            # Messages de clarification par langue
            clarification_messages = {
                "fr": {
                    "breed": "De quelle race de poulets s'agit-il ? (ex: Ross 308, Cobb 500)",
                    "sex": "S'agit-il de m√¢les, femelles, ou d'un troupeau mixte ?",
                    "age": "Quel est l'√¢ge de vos poulets ?"
                },
                "en": {
                    "breed": "What breed of chickens are we talking about? (e.g., Ross 308, Cobb 500)",
                    "sex": "Are these males, females, or a mixed flock?",
                    "age": "How old are your chickens?"
                },
                "es": {
                    "breed": "¬øDe qu√© raza de pollos estamos hablando? (ej: Ross 308, Cobb 500)",
                    "sex": "¬øSon machos, hembras, o un lote mixto?",
                    "age": "¬øQu√© edad tienen sus pollos?"
                }
            }
            
            messages = clarification_messages.get(language, clarification_messages["fr"])
            
            # Race manquante ou g√©n√©rique
            if "breed" in missing_info:
                clarification_questions.append(messages["breed"])
            
            # Sexe manquant
            if "sex" in missing_info:
                clarification_questions.append(messages["sex"])
            
            # √Çge manquant
            if "age" in missing_info:
                clarification_questions.append(messages["age"])
            
            # Au maximum 2 questions de clarification
            needs_clarification = len(clarification_questions) > 0 and len(clarification_questions) <= 2
            
            return needs_clarification, clarification_questions[:2]
            
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur check_if_clarification_needed: {e}")
            return False, []

    def generate_clarification_request(
        self, 
        clarification_questions: List[str], 
        language: str = "fr"
    ) -> str:
        """G√©n√®re une demande de clarification naturelle - VERSION S√âCURIS√âE"""
        
        try:
            if not clarification_questions:
                fallback_messages = {
                    "fr": "Pouvez-vous me donner plus de d√©tails ?",
                    "en": "Can you give me more details?",
                    "es": "¬øPuede darme m√°s detalles?"
                }
                return fallback_messages.get(language, fallback_messages["fr"])
            
            intro_messages = {
                "fr": "Pour vous donner une r√©ponse plus pr√©cise, j'ai besoin de quelques informations suppl√©mentaires :",
                "en": "To give you a more accurate answer, I need some additional information:",
                "es": "Para darle una respuesta m√°s precisa, necesito informaci√≥n adicional:"
            }
            
            intro = intro_messages.get(language, intro_messages["fr"])
            
            try:
                questions_text = "\n".join([f"‚Ä¢ {q}" for q in clarification_questions])
            except Exception as questions_error:
                logger.warning(f"‚ö†Ô∏è [Clarification] Erreur formatage questions: {questions_error}")
                questions_text = str(clarification_questions)
            
            return f"{intro}\n\n{questions_text}"
            
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur generate_clarification_request: {e}")
            return "Pouvez-vous me donner plus de d√©tails ?"


# ===============================
# üîß R√âSUM√â DES NOUVELLES S√âCURISATIONS AJOUT√âES
# ===============================

"""
üö® NOUVELLES S√âCURISATIONS APPLIQU√âES dans conversation_extraction.py:

CLASSE ConversationEntityExtractor:
‚úÖ extract_entities_ai_enhanced() avec fallback ultime
‚úÖ _extract_entities_openai_safe() avec gestion d'erreurs compl√®te
‚úÖ _extract_entities_basic_robust_safe() avec fallback
‚úÖ Tous les acc√®s aux attributs d'entit√©s avec hasattr()
‚úÖ Gestion d'erreurs dans chaque pattern d'extraction
‚úÖ Synchronisation weight/weight_grams s√©curis√©e
‚úÖ Conversion de types s√©curis√©e dans toutes les op√©rations

CLASSE ConversationClarificationHandler:
‚úÖ build_enriched_question_from_clarification() s√©curis√©
‚úÖ _extract_breed_from_clarification_safe() avec gestion d'erreurs
‚úÖ _extract_sex_from_clarification_safe() avec gestion d'erreurs
‚úÖ _integrate_enrichments_into_question_safe() avec fallback
‚úÖ detect_clarification_state() avec v√©rifications hasattr()
‚úÖ check_if_clarification_needed() s√©curis√©
‚úÖ generate_clarification_request() avec fallbacks

AVANTAGES:
- ‚ùå Plus jamais de crash sur attributs manquants (entities.weight, entities.mortality)
- ‚úÖ Extraction continue m√™me si certains patterns √©chouent
- ‚úÖ Fallbacks √† tous les niveaux (OpenAI ‚Üí Basic ‚Üí Empty)
- ‚úÖ Logging d√©taill√© des erreurs sans interruption
- ‚úÖ Assignation s√©curis√©e avec hasattr() partout
- ‚úÖ Validation et conversion de types robustes
"""