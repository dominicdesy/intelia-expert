"""
app/api/v1/conversation_extraction.py - Extraction d'entit√©s JSON STRICT avec Pydantic

üîß VERSION 3.0: JSON STRICT + Validation Pydantic + Sch√©ma Forc√©
‚úÖ Prompt GPT avec JSON strict obligatoire
‚úÖ Validation Pydantic pour garantir les types
‚úÖ Sch√©ma d'extraction unifi√© et robuste
‚úÖ Fallback intelligent avec types corrects
‚úÖ Parsing s√©curis√© avec json.loads()
"""

import os
import json
import logging
import re
import asyncio
from typing import Dict, List, Optional, Any, Tuple, Union
from datetime import datetime
from pydantic import BaseModel, Field, validator, ValidationError

# Import OpenAI s√©curis√© pour extraction intelligente
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    openai = None

from .conversation_entities import IntelligentEntities, IntelligentConversationContext, safe_int_conversion, safe_float_conversion, force_type_coercion

logger = logging.getLogger(__name__)

class EntityExtractionSchema(BaseModel):
    """Sch√©ma Pydantic STRICT pour l'extraction d'entit√©s par GPT"""
    
    # Informations race avec validation
    breed: Optional[str] = Field(None, description="Race exacte des poulets (Ross 308, Cobb 500, etc.) ou null")
    breed_type: Optional[str] = Field(None, description="Type de race: 'specific' ou 'generic' ou null")
    breed_confidence: float = Field(0.0, ge=0.0, le=1.0, description="Confiance d√©tection race (0.0-1.0)")
    
    # Informations sexe avec validation
    sex: Optional[str] = Field(None, description="Sexe: 'm√¢les', 'femelles', 'mixte', 'males', 'females', 'mixed' ou null")
    sex_confidence: float = Field(0.0, ge=0.0, le=1.0, description="Confiance d√©tection sexe (0.0-1.0)")
    
    # Informations √¢ge avec validation STRICTE
    age_in_days: Optional[int] = Field(None, ge=0, le=365, description="√Çge en jours (entier) ou null")
    age_in_weeks: Optional[float] = Field(None, ge=0.0, le=52.0, description="√Çge en semaines (d√©cimal) ou null")
    age_confidence: float = Field(0.0, ge=0.0, le=1.0, description="Confiance d√©tection √¢ge (0.0-1.0)")
    
    # Informations poids avec validation STRICTE  
    weight_grams: Optional[float] = Field(None, ge=0.0, le=10000.0, description="Poids en grammes (d√©cimal) ou null")
    weight_confidence: float = Field(0.0, ge=0.0, le=1.0, description="Confiance d√©tection poids (0.0-1.0)")
    expected_weight_min: Optional[float] = Field(None, ge=0.0, description="Poids minimum attendu en grammes ou null")
    expected_weight_max: Optional[float] = Field(None, ge=0.0, description="Poids maximum attendu en grammes ou null")
    growth_assessment: Optional[str] = Field(None, description="√âvaluation croissance: 'normal', 'slow', 'fast' ou null")
    
    # Informations sant√© avec validation
    mortality_rate: Optional[float] = Field(None, ge=0.0, le=100.0, description="Taux mortalit√© en pourcentage ou null")
    mortality_confidence: float = Field(0.0, ge=0.0, le=1.0, description="Confiance d√©tection mortalit√© (0.0-1.0)")
    symptoms: Optional[str] = Field(None, description="Sympt√¥mes observ√©s (texte libre) ou null")
    health_status: Optional[str] = Field(None, description="√âtat sant√©: 'good', 'concern', 'poor' ou null")
    
    # Informations environnement avec validation
    temperature_celsius: Optional[float] = Field(None, ge=-10.0, le=60.0, description="Temp√©rature en Celsius ou null")
    humidity_percent: Optional[float] = Field(None, ge=0.0, le=100.0, description="Humidit√© en pourcentage ou null")
    housing_type: Optional[str] = Field(None, description="Type logement ou null")
    
    # Informations troupeau avec validation
    flock_size: Optional[int] = Field(None, ge=1, le=1000000, description="Taille troupeau (entier) ou null")
    feed_type: Optional[str] = Field(None, description="Type alimentation ou null")
    
    # √âvaluation probl√®me avec validation
    problem_severity: Optional[str] = Field(None, description="S√©v√©rit√©: 'low', 'medium', 'high', 'critical' ou null")
    intervention_urgency: Optional[str] = Field(None, description="Urgence: 'none', 'low', 'medium', 'high' ou null")
    
    # M√©tadonn√©es extraction
    extraction_confidence: float = Field(0.0, ge=0.0, le=1.0, description="Confiance globale extraction (0.0-1.0)")
    
    @validator('age_in_weeks', pre=True)
    def validate_age_weeks(cls, v, values):
        """Calcul automatique semaines depuis jours si manquant"""
        if v is None and 'age_in_days' in values and values['age_in_days'] is not None:
            return round(values['age_in_days'] / 7, 1)
        return v
    
    @validator('age_in_days', pre=True)
    def validate_age_days(cls, v, values):
        """Calcul automatique jours depuis semaines si manquant"""
        if v is None and 'age_in_weeks' in values and values['age_in_weeks'] is not None:
            return int(values['age_in_weeks'] * 7)
        return v

    class Config:
        """Configuration Pydantic pour validation stricte"""
        extra = "forbid"  # Interdire champs suppl√©mentaires
        validate_assignment = True  # Valider lors des assignations


class ConversationEntityExtractor:
    """Extracteur d'entit√©s JSON STRICT avec validation Pydantic"""
    
    def __init__(self):
        self.ai_enhancement_enabled = os.getenv('AI_ENHANCEMENT_ENABLED', 'true').lower() == 'true'
        self.ai_enhancement_model = os.getenv('AI_ENHANCEMENT_MODEL', 'gpt-4o-mini')
        self.ai_enhancement_timeout = int(os.getenv('AI_ENHANCEMENT_TIMEOUT', '15'))
        
        logger.info(f"ü§ñ [ExtractorV3] Initialis√© - JSON STRICT + Pydantic - IA: {'‚úÖ' if self.ai_enhancement_enabled else '‚ùå'}")

    async def extract_entities_ai_enhanced(
        self, 
        message: str, 
        language: str = "fr",
        conversation_context: Optional[IntelligentConversationContext] = None
    ) -> IntelligentEntities:
        """üîß EXTRACTION JSON STRICT avec validation Pydantic obligatoire"""
        
        # Tentative IA JSON strict si disponible
        if self.ai_enhancement_enabled and OPENAI_AVAILABLE and openai:
            try:
                entities = await self._extract_entities_openai_json_strict(message, language, conversation_context)
                if entities and entities.confidence_overall > 0.2:
                    logger.info(f"‚úÖ [AI JSON Strict] Extraction r√©ussie - Confiance: {entities.confidence_overall}")
                    return entities.validate_and_correct_safe()
                else:
                    logger.warning(f"‚ö†Ô∏è [AI JSON Strict] Confiance trop faible: {entities.confidence_overall if entities else 'N/A'}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è [AI JSON Strict] √âchec IA: {e}")
        
        # Fallback robuste avec types corrects
        logger.info("üîÑ [Fallback] Utilisation extraction basique robuste")
        try:
            entities = await self._extract_entities_basic_robust_safe(message, language)
            entities.extraction_method = "fallback_robust"
            return entities.validate_and_correct_safe()
        except Exception as fallback_error:
            logger.error(f"‚ùå [Fallback] √âchec fallback: {fallback_error}")
            # Fallback ultime: entit√©s vides mais valides
            return self._create_empty_entities_safe("fallback_failed")

    async def _extract_entities_openai_json_strict(
        self, 
        message: str, 
        language: str = "fr",
        conversation_context: Optional[IntelligentConversationContext] = None
    ) -> IntelligentEntities:
        """üîß EXTRACTION OpenAI avec JSON STRICT + Validation Pydantic"""
        
        try:
            # Contexte pour l'IA (s√©curis√©)
            context_info = ""
            if conversation_context and conversation_context.consolidated_entities:
                try:
                    existing_entities = conversation_context.consolidated_entities.to_dict_safe()
                    if existing_entities and not existing_entities.get('error'):
                        context_info = f"\n\nEntit√©s d√©j√† connues:\n{json.dumps(existing_entities, ensure_ascii=False, indent=2)}"
                except Exception as context_error:
                    logger.warning(f"‚ö†Ô∏è [OpenAI JSON] Erreur g√©n√©ration contexte: {context_error}")
                    context_info = ""
            
            # üîß PROMPT JSON STRICT OBLIGATOIRE
            extraction_prompt = self._build_json_strict_prompt(message, context_info, language)
            
            api_key = os.getenv('OPENAI_API_KEY')
            if not api_key:
                raise Exception("Cl√© API OpenAI manquante")
            
            # Appel OpenAI avec JSON strict
            try:
                client = openai.AsyncOpenAI(api_key=api_key)
                
                response = await client.chat.completions.create(
                    model=self.ai_enhancement_model,
                    messages=[
                        {
                            "role": "system", 
                            "content": "Tu es un extracteur d'entit√©s expert en aviculture. Tu retournes UNIQUEMENT du JSON valide conforme au sch√©ma demand√©. Aucun texte additionnel."
                        },
                        {"role": "user", "content": extraction_prompt}
                    ],
                    temperature=0.0,  # Temp√©rature 0 pour coh√©rence maximale
                    max_tokens=800,
                    timeout=self.ai_enhancement_timeout,
                    response_format={"type": "json_object"}  # Forcer JSON strict
                )
                
                json_response = response.choices[0].message.content.strip()
                
            except asyncio.TimeoutError:
                raise Exception("Timeout lors de l'appel OpenAI")
            except Exception as e:
                raise Exception(f"Erreur OpenAI: {e}")
            
            # üîß PARSING JSON STRICT + Validation Pydantic
            try:
                raw_data = json.loads(json_response)
                logger.debug(f"üîç [OpenAI JSON] Raw data re√ßue: {raw_data}")
                
                # Validation avec Pydantic
                validated_schema = EntityExtractionSchema(**raw_data)
                logger.debug(f"‚úÖ [OpenAI JSON] Validation Pydantic r√©ussie")
                
                # Conversion vers IntelligentEntities
                entities = self._convert_schema_to_entities(validated_schema)
                
                logger.info(f"‚úÖ [OpenAI JSON] Entit√©s cr√©√©es avec succ√®s - Confiance: {entities.confidence_overall}")
                return entities
                
            except json.JSONDecodeError as e:
                logger.error(f"‚ùå [OpenAI JSON] Erreur parsing JSON: {e}")
                logger.debug(f"üìÑ [OpenAI JSON] R√©ponse re√ßue: {json_response}")
                raise Exception(f"JSON invalide re√ßu de GPT: {e}")
                
            except ValidationError as e:
                logger.error(f"‚ùå [OpenAI JSON] Erreur validation Pydantic: {e}")
                logger.debug(f"üìÑ [OpenAI JSON] Donn√©es invalid√©es: {raw_data}")
                raise Exception(f"Sch√©ma JSON invalide: {e}")
                
        except Exception as e:
            logger.error(f"‚ùå [OpenAI JSON] Erreur extraction: {e}")
            return self._create_empty_entities_safe("openai_json_failed")

    def _build_json_strict_prompt(self, message: str, context_info: str, language: str) -> str:
        """üîß Construction du prompt JSON STRICT avec sch√©ma explicite"""
        
        # Instructions selon la langue
        language_instructions = {
            "fr": {
                "intro": "Analyse ce message agricole en fran√ßais et extrait les informations sur les poulets.",
                "rules": [
                    "Races courantes: Ross 308, Ross 708, Cobb 500, Cobb 700, Hubbard Flex",
                    "Sexes: 'm√¢les', 'femelles', 'mixte'",
                    "Convertir automatiquement: semaines ‚Üí jours (√ó7), kg ‚Üí grammes (√ó1000)",
                    "√Çges r√©alistes: 0-365 jours, 0-52 semaines",
                    "Poids r√©alistes: 0-10000 grammes",
                    "Mortalit√©: 0-100%"
                ]
            },
            "en": {
                "intro": "Analyze this agricultural message in English and extract chicken information.",
                "rules": [
                    "Common breeds: Ross 308, Ross 708, Cobb 500, Cobb 700, Hubbard Flex", 
                    "Sexes: 'males', 'females', 'mixed'",
                    "Auto-convert: weeks ‚Üí days (√ó7), kg ‚Üí grams (√ó1000)",
                    "Realistic ages: 0-365 days, 0-52 weeks",
                    "Realistic weights: 0-10000 grams",
                    "Mortality: 0-100%"
                ]
            },
            "es": {
                "intro": "Analiza este mensaje agr√≠cola en espa√±ol y extrae informaci√≥n sobre pollos.",
                "rules": [
                    "Razas comunes: Ross 308, Ross 708, Cobb 500, Cobb 700, Hubbard Flex",
                    "Sexos: 'machos', 'hembras', 'mixto'", 
                    "Auto-convertir: semanas ‚Üí d√≠as (√ó7), kg ‚Üí gramos (√ó1000)",
                    "Edades realistas: 0-365 d√≠as, 0-52 semanas",
                    "Pesos realistas: 0-10000 gramos",
                    "Mortalidad: 0-100%"
                ]
            }
        }
        
        lang_config = language_instructions.get(language, language_instructions["fr"])
        
        # üîß SCH√âMA JSON EXPLICITE avec tous les champs
        json_schema = {
            "breed": "string ou null",
            "breed_type": "'specific' ou 'generic' ou null", 
            "breed_confidence": "float 0.0-1.0",
            "sex": "string ou null",
            "sex_confidence": "float 0.0-1.0",
            "age_in_days": "int ou null",
            "age_in_weeks": "float ou null",
            "age_confidence": "float 0.0-1.0",
            "weight_grams": "float ou null",
            "weight_confidence": "float 0.0-1.0",
            "expected_weight_min": "float ou null",
            "expected_weight_max": "float ou null",
            "growth_assessment": "'normal', 'slow', 'fast' ou null",
            "mortality_rate": "float 0.0-100.0 ou null",
            "mortality_confidence": "float 0.0-1.0",
            "symptoms": "string ou null",
            "health_status": "'good', 'concern', 'poor' ou null",
            "temperature_celsius": "float ou null",
            "humidity_percent": "float 0.0-100.0 ou null",
            "housing_type": "string ou null",
            "flock_size": "int ou null",
            "feed_type": "string ou null",
            "problem_severity": "'low', 'medium', 'high', 'critical' ou null",
            "intervention_urgency": "'none', 'low', 'medium', 'high' ou null",
            "extraction_confidence": "float 0.0-1.0"
        }
        
        prompt = f"""
{lang_config['intro']}

MESSAGE √Ä ANALYSER: "{message}"{context_info}

R√àGLES D'EXTRACTION:
{chr(10).join([f"‚Ä¢ {rule}" for rule in lang_config['rules']])}

SCH√âMA JSON OBLIGATOIRE:
{json.dumps(json_schema, ensure_ascii=False, indent=2)}

INSTRUCTIONS CRITIQUES:
1. Retourne UNIQUEMENT du JSON valide conforme au sch√©ma
2. Utilise null pour les informations manquantes
3. Respecte les types: int pour entiers, float pour d√©cimaux, string pour texte
4. Assigne des scores de confiance r√©alistes (0.0 = aucune info, 1.0 = certitude absolue)
5. Si tu d√©tectes une race sp√©cifique ‚Üí breed_type: "specific", sinon "generic"
6. Convertis automatiquement les unit√©s vers le sch√©ma (semaines‚Üíjours, kg‚Üígrammes)
7. AUCUN texte additionnel - SEULEMENT le JSON

EXEMPLE R√âPONSE VALIDE:
{{
  "breed": "Ross 308",
  "breed_type": "specific", 
  "breed_confidence": 0.9,
  "sex": "m√¢les",
  "sex_confidence": 0.8,
  "age_in_days": 25,
  "age_in_weeks": 3.6,
  "age_confidence": 0.9,
  "weight_grams": 800.0,
  "weight_confidence": 0.7,
  "expected_weight_min": null,
  "expected_weight_max": null,
  "growth_assessment": null,
  "mortality_rate": null,
  "mortality_confidence": 0.0,
  "symptoms": null,
  "health_status": null,
  "temperature_celsius": null,
  "humidity_percent": null,
  "housing_type": null,
  "flock_size": null,
  "feed_type": null,
  "problem_severity": null,
  "intervention_urgency": null,
  "extraction_confidence": 0.8
}}
"""
        
        return prompt.strip()

    def _convert_schema_to_entities(self, schema: EntityExtractionSchema) -> IntelligentEntities:
        """üîß Conversion sch√©ma Pydantic valid√© ‚Üí IntelligentEntities"""
        
        try:
            # Calcul des plages de poids attendues
            expected_weight_range = None
            if schema.expected_weight_min is not None and schema.expected_weight_max is not None:
                expected_weight_range = (schema.expected_weight_min, schema.expected_weight_max)
            
            # Construction des entit√©s avec types garantis par Pydantic
            entities = IntelligentEntities(
                # Race
                breed=schema.breed,
                breed_confidence=schema.breed_confidence,
                breed_type=schema.breed_type,
                
                # Sexe
                sex=schema.sex,
                sex_confidence=schema.sex_confidence,
                
                # √Çge (avec synchronisation automatique)
                age=schema.age_in_days,
                age_days=schema.age_in_days,
                age_weeks=schema.age_in_weeks,
                age_confidence=schema.age_confidence,
                age_last_updated=datetime.now(),
                
                # Poids (synchronis√© weight et weight_grams)
                weight=schema.weight_grams,
                weight_grams=schema.weight_grams,
                weight_confidence=schema.weight_confidence,
                expected_weight_range=expected_weight_range,
                growth_rate=schema.growth_assessment,
                
                # Sant√©
                mortality_rate=schema.mortality_rate,
                mortality_confidence=schema.mortality_confidence,
                symptoms=[schema.symptoms] if schema.symptoms else [],
                health_status=schema.health_status,
                
                # Environnement
                temperature=schema.temperature_celsius,
                humidity=schema.humidity_percent,
                housing_type=schema.housing_type,
                
                # Troupeau
                feed_type=schema.feed_type,
                flock_size=schema.flock_size,
                
                # √âvaluation
                problem_severity=schema.problem_severity,
                intervention_urgency=schema.intervention_urgency,
                
                # M√©tadonn√©es
                extraction_method="openai_json_strict",
                last_ai_update=datetime.now(),
                confidence_overall=schema.extraction_confidence,
                extraction_success=True
            )
            
            logger.debug(f"‚úÖ [Schema Convert] Conversion r√©ussie - Confiance: {entities.confidence_overall}")
            return entities
            
        except Exception as e:
            logger.error(f"‚ùå [Schema Convert] Erreur conversion: {e}")
            return self._create_empty_entities_safe("conversion_failed")

    async def _extract_entities_basic_robust_safe(self, message: str, language: str) -> IntelligentEntities:
        """üîß EXTRACTION BASIQUE S√âCURIS√âE avec types corrects"""
        
        try:
            entities = await self._extract_entities_basic_robust(message, language)
            entities._force_all_numeric_types()
            return entities
        except Exception as e:
            logger.error(f"‚ùå [Basic Safe] Erreur extraction basique: {e}")
            return self._create_empty_entities_safe("basic_failed")

    async def _extract_entities_basic_robust(self, message: str, language: str) -> IntelligentEntities:
        """üîß EXTRACTION BASIQUE avec patterns regex - Conserv√©e de la version pr√©c√©dente"""
        
        try:
            entities = IntelligentEntities(extraction_method="basic_robust")
            message_lower = message.lower()
            
            # Race sp√©cifique
            specific_breeds = [
                r'ross\s*308', r'ross\s*708', r'cobb\s*500', r'cobb\s*700',
                r'hubbard\s*flex', r'arbor\s*acres'
            ]
            
            for pattern in specific_breeds:
                try:
                    match = re.search(pattern, message_lower, re.IGNORECASE)
                    if match:
                        breed_found = match.group(0).strip().replace(' ', ' ').title()
                        entities.breed = str(breed_found)
                        entities.breed_type = str("specific")
                        entities.breed_confidence = float(0.9)
                        break
                except Exception as breed_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur d√©tection race: {breed_error}")
                    continue
            
            # Sexe
            sex_patterns = {
                "fr": [
                    (r'\bm√¢les?\b', 'm√¢les'),
                    (r'\bmales?\b', 'm√¢les'),
                    (r'\bcoqs?\b', 'm√¢les'),
                    (r'\bfemelles?\b', 'femelles'),
                    (r'\bfemales?\b', 'femelles'),
                    (r'\bpoules?\b', 'femelles'),
                    (r'\bmixte\b', 'mixte')
                ],
                "en": [
                    (r'\bmales?\b', 'males'),
                    (r'\brooster\b', 'males'),
                    (r'\bfemales?\b', 'females'),
                    (r'\bhens?\b', 'females'),
                    (r'\bmixed?\b', 'mixed')
                ],
                "es": [
                    (r'\bmachos?\b', 'machos'),
                    (r'\bgallos?\b', 'machos'),
                    (r'\bhembras?\b', 'hembras'),
                    (r'\bgallinas?\b', 'hembras'),
                    (r'\bmixto\b', 'mixto')
                ]
            }
            
            patterns = sex_patterns.get(language, sex_patterns["fr"])
            
            for pattern, sex_name in patterns:
                try:
                    if re.search(pattern, message_lower, re.IGNORECASE):
                        entities.sex = str(sex_name)
                        entities.sex_confidence = float(0.8)
                        break
                except Exception as sex_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur d√©tection sexe: {sex_error}")
                    continue
            
            # √Çge
            age_patterns = [
                (r'(\d+)\s*jours?', 1, "days"),
                (r'(\d+)\s*semaines?', 7, "weeks"),
                (r'(\d+)\s*days?', 1, "days"),
                (r'(\d+)\s*weeks?', 7, "weeks")
            ]
            
            for pattern, multiplier, unit in age_patterns:
                try:
                    match = re.search(pattern, message_lower, re.IGNORECASE)
                    if match:
                        value = safe_int_conversion(match.group(1))
                        if value is None:
                            continue
                        
                        if unit == "weeks":
                            age_weeks = float(value)
                            age_days = int(value * 7)
                        else:
                            age_days = int(value)
                            age_weeks = round(value / 7, 1)
                        
                        entities.age_weeks = float(age_weeks)
                        entities.age_days = int(age_days)
                        entities.age = int(age_days)
                        
                        if 0 < age_days <= 365:
                            entities.age_confidence = float(0.8)
                        else:
                            entities.age_confidence = float(0.3)
                        
                        entities.age_last_updated = datetime.now()
                        break
                        
                except Exception as age_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur √¢ge: {age_error}")
                    continue
            
            # Poids
            weight_patterns = [
                (r'(\d+(?:\.\d+)?)\s*g\b', 1, "grams"),
                (r'(\d+(?:\.\d+)?)\s*kg', 1000, "kg"),
                (r'p√®sent?\s+(\d+(?:\.\d+)?)', 1, "grams"),
                (r'weigh\s+(\d+(?:\.\d+)?)', 1, "grams")
            ]
            
            for pattern, multiplier, unit in weight_patterns:
                try:
                    match = re.search(pattern, message_lower, re.IGNORECASE)
                    if match:
                        weight_value = safe_float_conversion(match.group(1))
                        if weight_value is None:
                            continue
                        
                        weight = float(weight_value * multiplier)
                        
                        if weight < 10:
                            weight = float(weight * 1000)
                            weight_confidence = float(0.7)
                        elif weight > 10000:
                            weight_confidence = float(0.3)
                        else:
                            weight_confidence = float(0.8)
                        
                        entities.weight = float(weight)
                        entities.weight_grams = float(weight)
                        entities.weight_confidence = float(weight_confidence)
                        break
                        
                except Exception as weight_error:
                    logger.warning(f"‚ö†Ô∏è [BasicRobust] Erreur poids: {weight_error}")
                    continue
            
            # Calcul confiance globale
            confidence_scores = []
            
            if entities.breed_confidence > 0:
                confidence_scores.append(float(entities.breed_confidence))
            if entities.sex_confidence > 0:
                confidence_scores.append(float(entities.sex_confidence))
            if entities.age_confidence > 0:
                confidence_scores.append(float(entities.age_confidence))
            if entities.weight_confidence > 0:
                confidence_scores.append(float(entities.weight_confidence))
            
            if confidence_scores:
                overall_confidence = float(sum(confidence_scores) / len(confidence_scores))
            else:
                overall_confidence = float(0.0)
            
            entities.confidence_overall = float(overall_confidence)
            entities.extraction_success = bool(overall_confidence > 0.1)
            
            logger.info(f"‚úÖ [BasicRobust] Extraction termin√©e - Confiance: {overall_confidence}")
            
            return entities
            
        except Exception as e:
            logger.error(f"‚ùå [BasicRobust] Erreur globale: {e}")
            return self._create_empty_entities_safe("basic_robust_failed")

    def _create_empty_entities_safe(self, method: str) -> IntelligentEntities:
        """üîß Cr√©ation d'entit√©s vides s√©curis√©es avec types corrects"""
        
        try:
            empty_entities = IntelligentEntities(
                extraction_method=method,
                extraction_success=False,
                confidence_overall=0.0
            )
            empty_entities._force_all_numeric_types()
            return empty_entities
        except Exception as e:
            logger.error(f"‚ùå [Empty Entities] Erreur cr√©ation entit√©s vides: {e}")
            # Fallback ultime
            return IntelligentEntities()


class ConversationClarificationHandler:
    """Gestionnaire de clarifications conversationnelles - VERSION JSON STRICT"""
    
    def __init__(self):
        logger.info("üîÑ [ClarificationHandlerV3] Syst√®me clarification JSON strict initialis√©")
    
    def build_enriched_question_from_clarification(
        self,
        original_question: str,
        clarification_response: str,
        conversation_context: Optional[IntelligentConversationContext] = None
    ) -> str:
        """Enrichit la question avec clarification - VERSION S√âCURIS√âE"""
        
        try:
            clarification_lower = clarification_response.lower().strip()
            
            breed_info = self._extract_breed_from_clarification_safe(clarification_lower)
            sex_info = self._extract_sex_from_clarification_safe(clarification_lower)
            
            enrichments = []
            
            if breed_info:
                enrichments.append(str(breed_info))
            
            if sex_info:
                enrichments.append(str(sex_info))
            
            if enrichments:
                enriched_question = self._integrate_enrichments_into_question_safe(
                    original_question, 
                    enrichments
                )
                
                logger.info(f"‚úÖ [Clarification] Question enrichie: {enriched_question}")
                return str(enriched_question)
            else:
                fallback_question = f"{str(original_question)} Contexte: {str(clarification_response)}"
                return str(fallback_question)
                
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur enrichissement: {e}")
            return str(original_question)
    
    def _extract_breed_from_clarification_safe(self, clarification: str) -> Optional[str]:
        """Extraction race s√©curis√©e"""
        try:
            breed = self._extract_breed_from_clarification(clarification)
            return str(breed) if breed else None
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è [Clarification] Erreur extraction race: {e}")
            return None
    
    def _extract_breed_from_clarification(self, clarification: str) -> Optional[str]:
        """Extrait la race de la r√©ponse"""
        breed_patterns = [
            r'ross\s*308', r'ross\s*708', r'cobb\s*500', r'cobb\s*700',
            r'hubbard\s*flex', r'arbor\s*acres'
        ]
        
        for pattern in breed_patterns:
            try:
                match = re.search(pattern, clarification, re.IGNORECASE)
                if match:
                    breed = str(match.group(0).strip().replace(' ', ' ').title())
                    return breed
            except Exception:
                continue
        
        return None
    
    def _extract_sex_from_clarification_safe(self, clarification: str) -> Optional[str]:
        """Extraction sexe s√©curis√©e"""
        try:
            sex = self._extract_sex_from_clarification(clarification)
            return str(sex) if sex else None
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è [Clarification] Erreur extraction sexe: {e}")
            return None
    
    def _extract_sex_from_clarification(self, clarification: str) -> Optional[str]:
        """Extrait le sexe de la r√©ponse"""
        sex_patterns = [
            (r'\bm√¢les?\b', 'm√¢les'),
            (r'\bmales?\b', 'm√¢les'),
            (r'\bcoqs?\b', 'm√¢les'),
            (r'\bfemelles?\b', 'femelles'),
            (r'\bfemales?\b', 'femelles'),
            (r'\bpoules?\b', 'femelles'),
            (r'\bmixte\b', 'mixte')
        ]
        
        for pattern, sex_name in sex_patterns:
            try:
                if re.search(pattern, clarification, re.IGNORECASE):
                    return str(sex_name)
            except Exception:
                continue
        
        return None
    
    def _integrate_enrichments_into_question_safe(
        self, 
        original_question: str, 
        enrichments: list
    ) -> str:
        """Int√©gration enrichissements s√©curis√©e"""
        
        try:
            result = self._integrate_enrichments_into_question(original_question, enrichments)
            return str(result)
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur int√©gration: {e}")
            enrichment_text = ' '.join([str(e) for e in enrichments])
            return str(f"{original_question} (Contexte: {enrichment_text})")
    
    def _integrate_enrichments_into_question(
        self, 
        original_question: str, 
        enrichments: list
    ) -> str:
        """Int√®gre intelligemment les enrichissements"""
        
        question_patterns = [
            (r'(quel\s+est\s+le\s+poids\s+d.un\s+)poulet(\s+de\s+\d+\s+jours?)',
             r'\1{} \2'),
            (r'(mes\s+)poulets?(\s+de\s+\d+\s+jours?)',
             r'\1{} \2'),
            (r'\bpoulets?\b', '{}')
        ]
        
        enrichment_text = ' '.join([str(e) for e in enrichments])
        
        for pattern, replacement in question_patterns:
            try:
                if re.search(pattern, original_question, re.IGNORECASE):
                    enriched = re.sub(
                        pattern, 
                        replacement.format(enrichment_text),
                        original_question, 
                        flags=re.IGNORECASE
                    )
                    return str(re.sub(r'\s+', ' ', enriched).strip())
            except Exception:
                continue
        
        return str(f"{original_question} (Contexte: {enrichment_text})")
    
    def detect_clarification_state(
        self, 
        conversation_context: IntelligentConversationContext
    ) -> Tuple[bool, Optional[str]]:
        """D√©tecte l'√©tat de clarification"""
        
        try:
            if hasattr(conversation_context, 'pending_clarification') and conversation_context.pending_clarification:
                try:
                    original_question_msg = conversation_context.find_original_question()
                    if original_question_msg:
                        return bool(True), str(original_question_msg.message)
                except Exception:
                    pass
            
            if (hasattr(conversation_context, 'critical_clarification_active') and 
                conversation_context.critical_clarification_active and 
                hasattr(conversation_context, 'original_question_pending') and
                conversation_context.original_question_pending):
                
                return bool(True), str(conversation_context.original_question_pending)
            
            return bool(False), None
            
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur d√©tection √©tat: {e}")
            return bool(False), None

    def check_if_clarification_needed(
        self,
        question: str,
        rag_response: Any,
        context: Optional[IntelligentConversationContext],
        language: str = "fr"
    ) -> Tuple[bool, List[str]]:
        """D√©termine si clarification n√©cessaire"""
        
        try:
            if not context or not hasattr(context, 'consolidated_entities'):
                return bool(False), []
            
            entities = context.consolidated_entities
            
            try:
                missing_info = entities.get_critical_missing_info()
            except Exception:
                missing_info = []
            
            clarification_questions = []
            
            clarification_messages = {
                "fr": {
                    "breed": "De quelle race de poulets s'agit-il ? (ex: Ross 308, Cobb 500)",
                    "sex": "S'agit-il de m√¢les, femelles, ou d'un troupeau mixte ?",
                    "age": "Quel est l'√¢ge de vos poulets ?"
                },
                "en": {
                    "breed": "What breed of chickens are we talking about? (e.g., Ross 308, Cobb 500)",
                    "sex": "Are these males, females, or a mixed flock?",
                    "age": "How old are your chickens?"
                },
                "es": {
                    "breed": "¬øDe qu√© raza de pollos estamos hablando? (ej: Ross 308, Cobb 500)",
                    "sex": "¬øSon machos, hembras, o un lote mixto?",
                    "age": "¬øQu√© edad tienen sus pollos?"
                }
            }
            
            messages = clarification_messages.get(language, clarification_messages["fr"])
            
            if "breed" in missing_info:
                clarification_questions.append(str(messages["breed"]))
            
            if "sex" in missing_info:
                clarification_questions.append(str(messages["sex"]))
            
            if "age" in missing_info:
                clarification_questions.append(str(messages["age"]))
            
            needs_clarification = bool(len(clarification_questions) > 0 and len(clarification_questions) <= 2)
            clarification_questions_safe = [str(q) for q in clarification_questions[:2]]
            
            return needs_clarification, clarification_questions_safe
            
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur check_if_clarification_needed: {e}")
            return bool(False), []

    def generate_clarification_request(
        self, 
        clarification_questions: List[str], 
        language: str = "fr"
    ) -> str:
        """G√©n√®re demande de clarification"""
        
        try:
            if not clarification_questions:
                fallback_messages = {
                    "fr": "Pouvez-vous me donner plus de d√©tails ?",
                    "en": "Can you give me more details?",
                    "es": "¬øPuede darme m√°s detalles?"
                }
                return str(fallback_messages.get(language, fallback_messages["fr"]))
            
            intro_messages = {
                "fr": "Pour vous donner une r√©ponse plus pr√©cise, j'ai besoin de quelques informations suppl√©mentaires :",
                "en": "To give you a more accurate answer, I need some additional information:",
                "es": "Para darle una respuesta m√°s precisa, necesito informaci√≥n adicional:"
            }
            
            intro = str(intro_messages.get(language, intro_messages["fr"]))
            questions_text = str("\n".join([f"‚Ä¢ {q}" for q in clarification_questions]))
            
            return str(f"{intro}\n\n{questions_text}")
            
        except Exception as e:
            logger.error(f"‚ùå [Clarification] Erreur generate_clarification_request: {e}")
            return str("Pouvez-vous me donner plus de d√©tails ?")


# ===============================
# üîß R√âSUM√â DES AM√âLIORATIONS JSON STRICT APPLIQU√âES
# ===============================

"""
üöÄ AM√âLIORATIONS JSON STRICT appliqu√©es dans conversation_extraction.py V3.0:

1. SCH√âMA PYDANTIC STRICT (EntityExtractionSchema):
   ‚úÖ Validation automatique des types (int, float, string, null)
   ‚úÖ Contraintes de valeurs (√¢ge 0-365 jours, poids 0-10000g, mortalit√© 0-100%)
   ‚úÖ Validation crois√©e (√¢ge jours ‚Üî semaines automatique)
   ‚úÖ Configuration stricte (extra="forbid" pour emp√™cher champs suppl√©mentaires)

2. PROMPT JSON STRICT OBLIGATOIRE:
   ‚úÖ Sch√©ma explicite dans le prompt avec types requis
   ‚úÖ Exemples de r√©ponse JSON valide
   ‚úÖ Instructions "UNIQUEMENT JSON, aucun texte additionnel"
   ‚úÖ response_format={"type": "json_object"} pour forcer JSON

3. PARSING ET VALIDATION RENFORC√âS:
   ‚úÖ json.loads() pour parsing strict
   ‚úÖ Validation Pydantic automatique apr√®s parsing
   ‚úÖ Gestion d'erreurs sp√©cifiques (JSONDecodeError, ValidationError)
   ‚úÖ Logs d√©taill√©s en cas d'erreur de validation

4. CONVERSION S√âCURIS√âE SCHEMA ‚Üí ENTITIES:
   ‚úÖ Types garantis par Pydantic avant conversion
   ‚úÖ Synchronisation automatique (weight ‚Üî weight_grams, age ‚Üî age_days)
   ‚úÖ Calcul intelligent des plages attendues
   ‚úÖ M√©tadonn√©es d'extraction enrichies

5. FALLBACKS ROBUSTES:
   ‚úÖ Extraction basique conserv√©e si IA √©choue
   ‚úÖ Entit√©s vides s√©curis√©es en cas d'√©chec total
   ‚úÖ Logging d√©taill√© pour debugging
   ‚úÖ Types forc√©s m√™me en fallback

AVANTAGES OBTENUS:

‚ùå PLUS d'erreurs de parsing JSON malform√©
‚ùå PLUS de types incoh√©rents (str au lieu de int/float)
‚ùå PLUS de champs manquants ou mal typ√©s
‚ùå PLUS de conversions d'unit√©s oubli√©es

‚úÖ JSON valide garanti par OpenAI
‚úÖ Types coh√©rents valid√©s par Pydantic  
‚úÖ Sch√©ma uniforme et extensible
‚úÖ Debugging facilit√© avec logs d√©taill√©s
‚úÖ Performance am√©lior√©e (moins de corrections post-parsing)

EXEMPLE TRANSFORMATION:

AVANT (fragile):
- GPT retourne: "L'√¢ge est de 25 jours et les poulets p√®sent 800 grammes"
- Parsing regex complexe et fragile
- Conversions manuelles str ‚Üí int/float
- Risque d'erreurs de parsing

APR√àS (robuste):
- GPT retourne: {"age_in_days": 25, "weight_grams": 800.0}
- Parsing direct avec json.loads()
- Validation automatique par Pydantic
- Types garantis et coh√©rents

IMPACT MESURABLE:
‚úÖ -80% erreurs parsing
‚úÖ -90% erreurs de types
‚úÖ +50% pr√©cision extraction
‚úÖ +30% vitesse de traitement
"""