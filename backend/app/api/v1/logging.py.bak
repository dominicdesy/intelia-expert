"""
Module de logging pour Intelia Expert - CORRECTION ROUTER 404
Gestion des conversations et feedback utilisateurs
CORRECTION: Router avec endpoints manquants ajout√©s
"""
import sqlite3
import uuid
from datetime import datetime
from typing import Optional, List, Dict, Any
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, validator, ConfigDict
import json
import os

# Configuration
DB_PATH = "conversations.db"

# =============================================================================
# MOD√àLES PYDANTIC AVEC VALIDATION ASSOUPLIE
# =============================================================================

class ConversationCreate(BaseModel):
    """Request model avec validation ultra-assouplie"""
    user_id: str
    question: str
    response: str
    conversation_id: str
    confidence_score: Optional[float] = None
    response_time_ms: Optional[int] = None
    language: str = "fr"
    rag_used: Optional[bool] = True

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
        extra="ignore"  # Ignore extra fields
    )

    @validator('user_id', pre=True, always=True)
    def validate_user_id(cls, v):
        if not v:
            return f"anonymous_{uuid.uuid4().hex[:8]}"
        return str(v).strip()

    @validator('question', 'response', pre=True, always=True)
    def validate_text_fields(cls, v):
        if not v:
            return ""
        try:
            return str(v).strip()
        except:
            return ""

    @validator('conversation_id', pre=True, always=True)
    def validate_conversation_id(cls, v):
        if not v:
            return str(uuid.uuid4())
        return str(v).strip()

    @validator('language', pre=True, always=True)
    def validate_language(cls, v):
        if not v:
            return "fr"
        lang = str(v).lower().strip()[:2]
        return lang if lang in ["fr", "en", "es"] else "fr"

    @validator('confidence_score', pre=True, always=True)
    def validate_confidence_score(cls, v):
        if v is None or v == "":
            return None
        try:
            score = float(v)
            return max(0.0, min(1.0, score))
        except (ValueError, TypeError):
            return None

    @validator('response_time_ms', pre=True, always=True)
    def validate_response_time(cls, v):
        if v is None or v == "":
            return None
        try:
            time_ms = int(float(v))
            return max(0, time_ms)
        except (ValueError, TypeError):
            return None

class FeedbackUpdate(BaseModel):
    feedback: int

class ConversationResponse(BaseModel):
    conversation_id: str
    timestamp: datetime
    message: str

class DeleteResponse(BaseModel):
    message: str
    conversation_id: Optional[str] = None
    user_id: Optional[str] = None
    deleted_count: int
    timestamp: datetime

class AnalyticsResponse(BaseModel):
    total_conversations: int
    satisfaction_rate: Optional[float]
    avg_response_time: Optional[float]
    feedback_distribution: Dict[str, int]
    period_days: int

# ==================== CLASSE LOGGER PRINCIPAL ====================

class ConversationLogger:
    def __init__(self, db_path: str = DB_PATH):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialise la base de donn√©es SQLite"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS conversations (
                        id TEXT PRIMARY KEY,
                        conversation_id TEXT UNIQUE NOT NULL,
                        user_id TEXT NOT NULL,
                        question TEXT NOT NULL,
                        response TEXT NOT NULL,
                        feedback INTEGER,
                        confidence_score REAL,
                        response_time_ms INTEGER,
                        language TEXT DEFAULT 'fr',
                        rag_used BOOLEAN DEFAULT TRUE,
                        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Index pour les requ√™tes fr√©quentes
                conn.execute("CREATE INDEX IF NOT EXISTS idx_conversation_id ON conversations(conversation_id)")
                conn.execute("CREATE INDEX IF NOT EXISTS idx_user_id ON conversations(user_id)")
                conn.execute("CREATE INDEX IF NOT EXISTS idx_timestamp ON conversations(timestamp)")
                
                print("‚úÖ Base de donn√©es conversations initialis√©e")
                
        except Exception as e:
            print(f"‚ùå Erreur initialisation base: {e}")
    
    def save_conversation(self, conversation: ConversationCreate) -> str:
        """Sauvegarde une conversation avec gestion d'erreurs"""
        try:
            record_id = str(uuid.uuid4())
            
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    INSERT OR REPLACE INTO conversations (
                        id, conversation_id, user_id, question, response, 
                        confidence_score, response_time_ms, language, rag_used
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    record_id,
                    conversation.conversation_id,
                    conversation.user_id,
                    conversation.question,
                    conversation.response,
                    conversation.confidence_score,
                    conversation.response_time_ms,
                    conversation.language,
                    conversation.rag_used
                ))
            
            return record_id
            
        except Exception as e:
            print(f"‚ùå Erreur sauvegarde: {e}")
            return str(uuid.uuid4())
    
    def update_feedback(self, conversation_id: str, feedback: int) -> bool:
        """Met √† jour le feedback d'une conversation"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute("""
                    UPDATE conversations 
                    SET feedback = ?, updated_at = CURRENT_TIMESTAMP 
                    WHERE conversation_id = ?
                """, (feedback, conversation_id))
                
                return cursor.rowcount > 0
                
        except Exception as e:
            print(f"‚ùå Erreur mise √† jour feedback: {e}")
            return False
    
    def get_user_conversations(self, user_id: str, limit: int = 10) -> List[Dict]:
        """R√©cup√®re les conversations d'un utilisateur"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute("""
                    SELECT conversation_id, question, timestamp, language, rag_used, feedback
                    FROM conversations 
                    WHERE user_id = ? 
                    ORDER BY timestamp DESC 
                    LIMIT ?
                """, (user_id, limit))
                
                return [dict(row) for row in cursor.fetchall()]
                
        except Exception as e:
            print(f"‚ùå Erreur r√©cup√©ration conversations: {e}")
            return []
    
    def get_analytics(self, days: int = 7) -> Dict[str, Any]:
        """G√©n√®re des analytics pour une p√©riode donn√©e"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                # Total conversations
                total = conn.execute("""
                    SELECT COUNT(*) FROM conversations 
                    WHERE datetime(timestamp) >= datetime('now', '-{} days')
                """.format(days)).fetchone()[0]
                
                # Satisfaction rate
                satisfaction = conn.execute("""
                    SELECT 
                        COUNT(CASE WHEN feedback = 1 THEN 1 END) as positive,
                        COUNT(CASE WHEN feedback = -1 THEN 1 END) as negative,
                        COUNT(CASE WHEN feedback IS NOT NULL THEN 1 END) as total_feedback
                    FROM conversations 
                    WHERE datetime(timestamp) >= datetime('now', '-{} days')
                """.format(days)).fetchone()
                
                satisfaction_rate = None
                if satisfaction[2] > 0:
                    satisfaction_rate = round(satisfaction[0] / satisfaction[2], 3)
                
                # Temps de r√©ponse moyen
                avg_response_time = conn.execute("""
                    SELECT AVG(response_time_ms) FROM conversations 
                    WHERE response_time_ms IS NOT NULL 
                    AND datetime(timestamp) >= datetime('now', '-{} days')
                """.format(days)).fetchone()[0]
                
                return {
                    "total_conversations": total,
                    "satisfaction_rate": satisfaction_rate,
                    "avg_response_time": round(avg_response_time, 2) if avg_response_time else None,
                    "feedback_distribution": {
                        "positive": satisfaction[0],
                        "negative": satisfaction[1],
                        "no_feedback": total - satisfaction[2]
                    },
                    "period_days": days
                }
                
        except Exception as e:
            print(f"‚ùå Erreur analytics: {e}")
            return {
                "total_conversations": 0,
                "satisfaction_rate": None,
                "avg_response_time": None,
                "feedback_distribution": {"positive": 0, "negative": 0, "no_feedback": 0},
                "period_days": days
            }

# Instance globale
logger_instance = ConversationLogger()

# =============================================================================
# ROUTER AVEC TOUS LES ENDPOINTS MANQUANTS
# =============================================================================

# CORRECTION CRITIQUE: D√©finir le router avec le bon pr√©fixe
router = APIRouter(prefix="/logging", tags=["logging"])

# ============================================================================
# CORRECTION: AJOUT DE TOUS LES ENDPOINTS MANQUANTS (r√©sout erreurs 404)
# ============================================================================

@router.get("/health")
async def logging_health_check():
    """Health check du syst√®me de logging - ENDPOINT MANQUANT AJOUT√â"""
    try:
        # V√©rifier la base de donn√©es
        with sqlite3.connect(logger_instance.db_path) as conn:
            # Test simple
            count = conn.execute("SELECT COUNT(*) FROM conversations").fetchone()[0]
            
        return {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "database": {
                "status": "connected",
                "path": logger_instance.db_path,
                "conversations_count": count
            },
            "message": "Syst√®me de logging op√©rationnel"
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "timestamp": datetime.now().isoformat(),
            "database": {
                "status": "error",
                "error": str(e)
            },
            "message": "Erreur syst√®me de logging"
        }

@router.get("/analytics")
async def get_logging_analytics(days: int = 7):
    """Analytics du syst√®me de logging - ENDPOINT MANQUANT AJOUT√â"""
    try:
        analytics = logger_instance.get_analytics(days)
        
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "analytics": analytics,
            "message": f"Analytics pour les {days} derniers jours"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur r√©cup√©ration analytics"
        }

@router.get("/admin/stats")
async def get_admin_stats():
    """Statistiques administrateur - ENDPOINT MANQUANT AJOUT√â"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            # Statistiques g√©n√©rales
            stats = {
                "total_conversations": conn.execute("SELECT COUNT(*) FROM conversations").fetchone()[0],
                "total_users": conn.execute("SELECT COUNT(DISTINCT user_id) FROM conversations").fetchone()[0],
                "conversations_today": conn.execute("""
                    SELECT COUNT(*) FROM conversations 
                    WHERE date(timestamp) = date('now')
                """).fetchone()[0],
                "conversations_this_week": conn.execute("""
                    SELECT COUNT(*) FROM conversations 
                    WHERE datetime(timestamp) >= datetime('now', '-7 days')
                """).fetchone()[0]
            }
            
            # Langues les plus utilis√©es
            languages = conn.execute("""
                SELECT language, COUNT(*) as count 
                FROM conversations 
                GROUP BY language 
                ORDER BY count DESC
            """).fetchall()
            
            # Feedback distribution
            feedback_stats = conn.execute("""
                SELECT 
                    SUM(CASE WHEN feedback = 1 THEN 1 ELSE 0 END) as positive,
                    SUM(CASE WHEN feedback = -1 THEN 1 ELSE 0 END) as negative,
                    SUM(CASE WHEN feedback IS NULL THEN 1 ELSE 0 END) as no_feedback
                FROM conversations
            """).fetchone()
            
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "general_stats": stats,
            "language_distribution": [{"language": lang, "count": count} for lang, count in languages],
            "feedback_stats": {
                "positive": feedback_stats[0],
                "negative": feedback_stats[1],
                "no_feedback": feedback_stats[2]
            },
            "message": "Statistiques administrateur r√©cup√©r√©es"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur r√©cup√©ration statistiques"
        }

@router.get("/database/info")
async def get_database_info():
    """Informations sur la base de donn√©es - ENDPOINT MANQUANT AJOUT√â"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            # Informations sur la base
            tables_info = conn.execute("""
                SELECT name FROM sqlite_master WHERE type='table'
            """).fetchall()
            
            # Informations sur la table conversations
            conversations_info = conn.execute("""
                PRAGMA table_info(conversations)
            """).fetchall()
            
            # Taille approximative de la base
            file_size = os.path.getsize(logger_instance.db_path) if os.path.exists(logger_instance.db_path) else 0
            
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "database_info": {
                "path": logger_instance.db_path,
                "file_size_bytes": file_size,
                "file_size_mb": round(file_size / (1024 * 1024), 2),
                "tables": [table[0] for table in tables_info],
                "conversations_schema": [
                    {
                        "column": col[1],
                        "type": col[2],
                        "not_null": bool(col[3]),
                        "default": col[4],
                        "primary_key": bool(col[5])
                    } for col in conversations_info
                ]
            },
            "message": "Informations base de donn√©es r√©cup√©r√©es"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur r√©cup√©ration informations base"
        }

@router.get("/conversations/{user_id}")
async def get_user_conversations_endpoint(user_id: str, limit: int = 10):
    """Conversations d'un utilisateur - ENDPOINT MANQUANT AJOUT√â"""
    try:
        conversations = logger_instance.get_user_conversations(user_id, limit)
        
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "user_id": user_id,
            "conversations": conversations,
            "count": len(conversations),
            "message": f"{len(conversations)} conversations trouv√©es"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur r√©cup√©ration conversations utilisateur"
        }

@router.delete("/test-data")
async def cleanup_test_data():
    """Nettoyage des donn√©es de test - ENDPOINT MANQUANT AJOUT√â"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            # Supprimer les conversations de test (avec user_id contenant "test" ou "anon")
            cursor = conn.execute("""
                DELETE FROM conversations 
                WHERE user_id LIKE '%test%' OR user_id LIKE '%anon%'
            """)
            deleted_count = cursor.rowcount
            
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "deleted_count": deleted_count,
            "message": f"{deleted_count} conversations de test supprim√©es"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur nettoyage donn√©es de test"
        }

# ============================================================================
# ENDPOINTS MANQUANTS √Ä AJOUTER DANS logging.py
# Ajouter ces endpoints AVANT les "# ENDPOINTS EXISTANTS" (ligne 235)
# ============================================================================

@router.post("/conversation", response_model=ConversationResponse)
async def save_conversation_endpoint(conversation: ConversationCreate):
    """ENDPOINT MANQUANT: Sauvegarder une conversation (utilis√© par le frontend)"""
    try:
        print(f"üíæ [logging] R√©ception conversation: {conversation.conversation_id}")
        print(f"üë§ [logging] User: {conversation.user_id}")
        print(f"üìù [logging] Question: {conversation.question[:50]}...")
        
        record_id = logger_instance.save_conversation(conversation)
        
        print(f"‚úÖ [logging] Conversation sauvegard√©e avec ID: {record_id}")
        
        return ConversationResponse(
            conversation_id=conversation.conversation_id,
            timestamp=datetime.now(),
            message="Conversation enregistr√©e avec succ√®s"
        )
    except Exception as e:
        print(f"‚ùå [logging] Erreur sauvegarde: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur sauvegarde: {str(e)}")

@router.patch("/conversation/{conversation_id}/feedback")
async def update_feedback_endpoint(conversation_id: str, feedback_data: dict):
    """ENDPOINT MANQUANT: Mettre √† jour le feedback (utilis√© par le frontend)"""
    try:
        print(f"üìä [logging] R√©ception feedback pour: {conversation_id}")
        print(f"üìä [logging] Feedback data: {feedback_data}")
        
        feedback_value = feedback_data.get("feedback", 0)
        
        success = logger_instance.update_feedback(conversation_id, feedback_value)
        
        if success:
            print(f"‚úÖ [logging] Feedback mis √† jour: {conversation_id} = {feedback_value}")
            return {
                "status": "success",
                "message": "Feedback mis √† jour avec succ√®s", 
                "conversation_id": conversation_id,
                "feedback": feedback_value,
                "timestamp": datetime.now().isoformat()
            }
        else:
            print(f"‚ùå [logging] Conversation non trouv√©e: {conversation_id}")
            raise HTTPException(status_code=404, detail="Conversation non trouv√©e")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå [logging] Erreur feedback: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur feedback: {str(e)}")

@router.get("/user/{user_id}/conversations")
async def get_user_conversations_list(user_id: str, limit: int = 50):
    """ENDPOINT MANQUANT: R√©cup√©rer les conversations d'un utilisateur (utilis√© par le frontend)"""
    try:
        print(f"üîç [logging] R√©cup√©ration conversations pour: {user_id}")
        print(f"üîç [logging] Limite: {limit}")
        
        conversations = logger_instance.get_user_conversations(user_id, limit)
        
        # Enrichir les donn√©es pour le frontend
        enriched_conversations = []
        for conv in conversations:
            enriched_conversations.append({
                "conversation_id": conv["conversation_id"],
                "question": conv["question"],
                "response": "R√©ponse disponible",  # On ne stocke pas la r√©ponse compl√®te
                "timestamp": conv["timestamp"],
                "language": conv.get("language", "fr"),
                "rag_used": conv.get("rag_used", True),
                "feedback": conv.get("feedback"),
                "created_at": conv["timestamp"],
                "updated_at": conv["timestamp"]
            })
        
        print(f"‚úÖ [logging] {len(enriched_conversations)} conversations r√©cup√©r√©es")
        
        return {
            "status": "success",
            "user_id": user_id,
            "conversations": enriched_conversations,
            "count": len(enriched_conversations),
            "timestamp": datetime.now().isoformat(),
            "message": f"{len(enriched_conversations)} conversations trouv√©es"
        }
        
    except Exception as e:
        print(f"‚ùå [logging] Erreur r√©cup√©ration: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur r√©cup√©ration: {str(e)}")

@router.delete("/conversation/{conversation_id}")
async def delete_single_conversation(conversation_id: str):
    """ENDPOINT MANQUANT: Supprimer une conversation sp√©cifique (utilis√© par le frontend)"""
    try:
        print(f"üóëÔ∏è [logging] Suppression conversation: {conversation_id}")
        
        with sqlite3.connect(logger_instance.db_path) as conn:
            cursor = conn.execute("DELETE FROM conversations WHERE conversation_id = ?", (conversation_id,))
            
            if cursor.rowcount > 0:
                print(f"‚úÖ [logging] Conversation supprim√©e: {conversation_id}")
                return {
                    "status": "success",
                    "message": "Conversation supprim√©e avec succ√®s",
                    "conversation_id": conversation_id,
                    "deleted_count": cursor.rowcount,
                    "timestamp": datetime.now().isoformat()
                }
            else:
                print(f"‚ùå [logging] Conversation non trouv√©e: {conversation_id}")
                raise HTTPException(status_code=404, detail="Conversation non trouv√©e")
                
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå [logging] Erreur suppression: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur suppression: {str(e)}")

@router.delete("/user/{user_id}/conversations")
async def delete_all_user_conversations(user_id: str):
    """ENDPOINT MANQUANT: Supprimer toutes les conversations d'un utilisateur (utilis√© par le frontend)"""
    try:
        print(f"üóëÔ∏è [logging] Suppression toutes conversations pour: {user_id}")
        
        with sqlite3.connect(logger_instance.db_path) as conn:
            cursor = conn.execute("DELETE FROM conversations WHERE user_id = ?", (user_id,))
            deleted_count = cursor.rowcount
            
        print(f"‚úÖ [logging] {deleted_count} conversations supprim√©es pour: {user_id}")
        
        return {
            "status": "success",
            "message": "Toutes les conversations ont √©t√© supprim√©es avec succ√®s",
            "user_id": user_id,
            "deleted_count": deleted_count,
            "timestamp": datetime.now().isoformat()
        }
            
    except Exception as e:
        print(f"‚ùå [logging] Erreur suppression globale: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur suppression: {str(e)}")

# ============================================================================
# ENDPOINT DE DIAGNOSTIC POUR TESTER LA CONNECTIVIT√â
# ============================================================================

@router.get("/test")
async def test_logging_system():
    """Test de connectivit√© du syst√®me de logging"""
    try:
        # Test de base de donn√©es
        with sqlite3.connect(logger_instance.db_path) as conn:
            count = conn.execute("SELECT COUNT(*) FROM conversations").fetchone()[0]
            
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "database": {
                "status": "connected",
                "conversations_count": count,
                "path": logger_instance.db_path
            },
            "endpoints": [
                "/logging/conversation [POST]",
                "/logging/conversation/{id}/feedback [PATCH]", 
                "/logging/user/{id}/conversations [GET]",
                "/logging/conversation/{id} [DELETE]",
                "/logging/user/{id}/conversations [DELETE]"
            ],
            "message": "Syst√®me de logging op√©rationnel avec tous les endpoints"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur syst√®me de logging"
        }


# ============================================================================
# ENDPOINTS EXISTANTS (gard√©s pour compatibilit√©)
# ============================================================================

@router.post("/conversations", response_model=ConversationResponse)
async def create_conversation(conversation: ConversationCreate):
    """Cr√©er une nouvelle conversation"""
    try:
        record_id = logger_instance.save_conversation(conversation)
        
        return ConversationResponse(
            conversation_id=conversation.conversation_id,
            timestamp=datetime.now(),
            message="Conversation enregistr√©e avec succ√®s"
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.patch("/conversations/{conversation_id}/feedback")
async def update_conversation_feedback(conversation_id: str, feedback: FeedbackUpdate):
    """Mettre √† jour le feedback d'une conversation"""
    try:
        success = logger_instance.update_feedback(conversation_id, feedback.feedback)
        
        if success:
            return {"message": "Feedback mis √† jour avec succ√®s", "conversation_id": conversation_id}
        else:
            raise HTTPException(status_code=404, detail="Conversation non trouv√©e")
            
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/conversations/{user_id}/history")
async def get_user_history(user_id: str, limit: int = 10):
    """R√©cup√©rer l'historique des conversations d'un utilisateur"""
    try:
        conversations = logger_instance.get_user_conversations(user_id, limit)
        return {
            "user_id": user_id,
            "conversations": conversations,
            "count": len(conversations)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/analytics/{days}", response_model=AnalyticsResponse)
async def get_analytics_period(days: int = 7):
    """R√©cup√©rer les analytics pour une p√©riode donn√©e"""
    try:
        analytics = logger_instance.get_analytics(days)
        return AnalyticsResponse(**analytics)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/conversations/{conversation_id}")
async def delete_conversation(conversation_id: str):
    """Supprimer une conversation (RGPD)"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            cursor = conn.execute("DELETE FROM conversations WHERE conversation_id = ?", (conversation_id,))
            
            if cursor.rowcount > 0:
                return DeleteResponse(
                    message="Conversation supprim√©e avec succ√®s",
                    conversation_id=conversation_id,
                    deleted_count=cursor.rowcount,
                    timestamp=datetime.now()
                )
            else:
                raise HTTPException(status_code=404, detail="Conversation non trouv√©e")
                
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/users/{user_id}")
async def delete_user_data(user_id: str):
    """Supprimer toutes les donn√©es d'un utilisateur (RGPD)"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            cursor = conn.execute("DELETE FROM conversations WHERE user_id = ?", (user_id,))
            
            return DeleteResponse(
                message="Donn√©es utilisateur supprim√©es avec succ√®s",
                user_id=user_id,
                deleted_count=cursor.rowcount,
                timestamp=datetime.now()
            )
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ============================================================================
# CONFIGURATION AU D√âMARRAGE
# ============================================================================

print("‚úÖ Module logging avec router complet initialis√©")
print(f"üóÑÔ∏è Base de donn√©es: {DB_PATH}")
print("üîß Tous les endpoints manquants ajout√©s pour corriger les erreurs 404")