"""
Module de logging pour Intelia Expert - CORRECTION ROUTER 404
Gestion des conversations et feedback utilisateurs
CORRECTION: Router avec endpoints manquants ajoutés
"""
import sqlite3
import uuid
from datetime import datetime
from typing import Optional, List, Dict, Any
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, validator, ConfigDict
import json
import os

# Configuration
DB_PATH = "conversations.db"

# =============================================================================
# MODÈLES PYDANTIC AVEC VALIDATION ASSOUPLIE
# =============================================================================

class ConversationCreate(BaseModel):
    """Request model avec validation ultra-assouplie"""
    user_id: str
    question: str
    response: str
    conversation_id: str
    confidence_score: Optional[float] = None
    response_time_ms: Optional[int] = None
    language: str = "fr"
    rag_used: Optional[bool] = True

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
        extra="ignore"  # Ignore extra fields
    )

    @validator('user_id', pre=True, always=True)
    def validate_user_id(cls, v):
        if not v:
            return f"anonymous_{uuid.uuid4().hex[:8]}"
        return str(v).strip()

    @validator('question', 'response', pre=True, always=True)
    def validate_text_fields(cls, v):
        if not v:
            return ""
        try:
            return str(v).strip()
        except:
            return ""

    @validator('conversation_id', pre=True, always=True)
    def validate_conversation_id(cls, v):
        if not v:
            return str(uuid.uuid4())
        return str(v).strip()

    @validator('language', pre=True, always=True)
    def validate_language(cls, v):
        if not v:
            return "fr"
        lang = str(v).lower().strip()[:2]
        return lang if lang in ["fr", "en", "es"] else "fr"

    @validator('confidence_score', pre=True, always=True)
    def validate_confidence_score(cls, v):
        if v is None or v == "":
            return None
        try:
            score = float(v)
            return max(0.0, min(1.0, score))
        except (ValueError, TypeError):
            return None

    @validator('response_time_ms', pre=True, always=True)
    def validate_response_time(cls, v):
        if v is None or v == "":
            return None
        try:
            time_ms = int(float(v))
            return max(0, time_ms)
        except (ValueError, TypeError):
            return None

class FeedbackUpdate(BaseModel):
    feedback: int

class ConversationResponse(BaseModel):
    conversation_id: str
    timestamp: datetime
    message: str

class DeleteResponse(BaseModel):
    message: str
    conversation_id: Optional[str] = None
    user_id: Optional[str] = None
    deleted_count: int
    timestamp: datetime

class AnalyticsResponse(BaseModel):
    total_conversations: int
    satisfaction_rate: Optional[float]
    avg_response_time: Optional[float]
    feedback_distribution: Dict[str, int]
    period_days: int

# ==================== CLASSE LOGGER PRINCIPAL ====================

class ConversationLogger:
    def __init__(self, db_path: str = DB_PATH):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialise la base de données SQLite"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS conversations (
                        id TEXT PRIMARY KEY,
                        conversation_id TEXT UNIQUE NOT NULL,
                        user_id TEXT NOT NULL,
                        question TEXT NOT NULL,
                        response TEXT NOT NULL,
                        feedback INTEGER,
                        confidence_score REAL,
                        response_time_ms INTEGER,
                        language TEXT DEFAULT 'fr',
                        rag_used BOOLEAN DEFAULT TRUE,
                        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Index pour les requêtes fréquentes
                conn.execute("CREATE INDEX IF NOT EXISTS idx_conversation_id ON conversations(conversation_id)")
                conn.execute("CREATE INDEX IF NOT EXISTS idx_user_id ON conversations(user_id)")
                conn.execute("CREATE INDEX IF NOT EXISTS idx_timestamp ON conversations(timestamp)")
                
                print("✅ Base de données conversations initialisée")
                
        except Exception as e:
            print(f"❌ Erreur initialisation base: {e}")
    
    def save_conversation(self, conversation: ConversationCreate) -> str:
        """Sauvegarde une conversation avec gestion d'erreurs"""
        try:
            record_id = str(uuid.uuid4())
            
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    INSERT OR REPLACE INTO conversations (
                        id, conversation_id, user_id, question, response, 
                        confidence_score, response_time_ms, language, rag_used
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    record_id,
                    conversation.conversation_id,
                    conversation.user_id,
                    conversation.question,
                    conversation.response,
                    conversation.confidence_score,
                    conversation.response_time_ms,
                    conversation.language,
                    conversation.rag_used
                ))
            
            return record_id
            
        except Exception as e:
            print(f"❌ Erreur sauvegarde: {e}")
            return str(uuid.uuid4())
    
    def update_feedback(self, conversation_id: str, feedback: int) -> bool:
        """Met à jour le feedback d'une conversation"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute("""
                    UPDATE conversations 
                    SET feedback = ?, updated_at = CURRENT_TIMESTAMP 
                    WHERE conversation_id = ?
                """, (feedback, conversation_id))
                
                return cursor.rowcount > 0
                
        except Exception as e:
            print(f"❌ Erreur mise à jour feedback: {e}")
            return False
    
    def get_user_conversations(self, user_id: str, limit: int = 10) -> List[Dict]:
        """Récupère les conversations d'un utilisateur"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute("""
                    SELECT conversation_id, question, timestamp, language, rag_used, feedback
                    FROM conversations 
                    WHERE user_id = ? 
                    ORDER BY timestamp DESC 
                    LIMIT ?
                """, (user_id, limit))
                
                return [dict(row) for row in cursor.fetchall()]
                
        except Exception as e:
            print(f"❌ Erreur récupération conversations: {e}")
            return []
    
    def get_analytics(self, days: int = 7) -> Dict[str, Any]:
        """Génère des analytics pour une période donnée"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                # Total conversations
                total = conn.execute("""
                    SELECT COUNT(*) FROM conversations 
                    WHERE datetime(timestamp) >= datetime('now', '-{} days')
                """.format(days)).fetchone()[0]
                
                # Satisfaction rate
                satisfaction = conn.execute("""
                    SELECT 
                        COUNT(CASE WHEN feedback = 1 THEN 1 END) as positive,
                        COUNT(CASE WHEN feedback = -1 THEN 1 END) as negative,
                        COUNT(CASE WHEN feedback IS NOT NULL THEN 1 END) as total_feedback
                    FROM conversations 
                    WHERE datetime(timestamp) >= datetime('now', '-{} days')
                """.format(days)).fetchone()
                
                satisfaction_rate = None
                if satisfaction[2] > 0:
                    satisfaction_rate = round(satisfaction[0] / satisfaction[2], 3)
                
                # Temps de réponse moyen
                avg_response_time = conn.execute("""
                    SELECT AVG(response_time_ms) FROM conversations 
                    WHERE response_time_ms IS NOT NULL 
                    AND datetime(timestamp) >= datetime('now', '-{} days')
                """.format(days)).fetchone()[0]
                
                return {
                    "total_conversations": total,
                    "satisfaction_rate": satisfaction_rate,
                    "avg_response_time": round(avg_response_time, 2) if avg_response_time else None,
                    "feedback_distribution": {
                        "positive": satisfaction[0],
                        "negative": satisfaction[1],
                        "no_feedback": total - satisfaction[2]
                    },
                    "period_days": days
                }
                
        except Exception as e:
            print(f"❌ Erreur analytics: {e}")
            return {
                "total_conversations": 0,
                "satisfaction_rate": None,
                "avg_response_time": None,
                "feedback_distribution": {"positive": 0, "negative": 0, "no_feedback": 0},
                "period_days": days
            }

# Instance globale
logger_instance = ConversationLogger()

# =============================================================================
# ROUTER AVEC TOUS LES ENDPOINTS MANQUANTS
# =============================================================================

# CORRECTION CRITIQUE: Définir le router avec le bon préfixe
router = APIRouter(prefix="/logging", tags=["logging"])

# ============================================================================
# CORRECTION: AJOUT DE TOUS LES ENDPOINTS MANQUANTS (résout erreurs 404)
# ============================================================================

@router.get("/health")
async def logging_health_check():
    """Health check du système de logging - ENDPOINT MANQUANT AJOUTÉ"""
    try:
        # Vérifier la base de données
        with sqlite3.connect(logger_instance.db_path) as conn:
            # Test simple
            count = conn.execute("SELECT COUNT(*) FROM conversations").fetchone()[0]
            
        return {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "database": {
                "status": "connected",
                "path": logger_instance.db_path,
                "conversations_count": count
            },
            "message": "Système de logging opérationnel"
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "timestamp": datetime.now().isoformat(),
            "database": {
                "status": "error",
                "error": str(e)
            },
            "message": "Erreur système de logging"
        }

@router.get("/analytics")
async def get_logging_analytics(days: int = 7):
    """Analytics du système de logging - ENDPOINT MANQUANT AJOUTÉ"""
    try:
        analytics = logger_instance.get_analytics(days)
        
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "analytics": analytics,
            "message": f"Analytics pour les {days} derniers jours"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur récupération analytics"
        }

@router.get("/admin/stats")
async def get_admin_stats():
    """Statistiques administrateur - ENDPOINT MANQUANT AJOUTÉ"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            # Statistiques générales
            stats = {
                "total_conversations": conn.execute("SELECT COUNT(*) FROM conversations").fetchone()[0],
                "total_users": conn.execute("SELECT COUNT(DISTINCT user_id) FROM conversations").fetchone()[0],
                "conversations_today": conn.execute("""
                    SELECT COUNT(*) FROM conversations 
                    WHERE date(timestamp) = date('now')
                """).fetchone()[0],
                "conversations_this_week": conn.execute("""
                    SELECT COUNT(*) FROM conversations 
                    WHERE datetime(timestamp) >= datetime('now', '-7 days')
                """).fetchone()[0]
            }
            
            # Langues les plus utilisées
            languages = conn.execute("""
                SELECT language, COUNT(*) as count 
                FROM conversations 
                GROUP BY language 
                ORDER BY count DESC
            """).fetchall()
            
            # Feedback distribution
            feedback_stats = conn.execute("""
                SELECT 
                    SUM(CASE WHEN feedback = 1 THEN 1 ELSE 0 END) as positive,
                    SUM(CASE WHEN feedback = -1 THEN 1 ELSE 0 END) as negative,
                    SUM(CASE WHEN feedback IS NULL THEN 1 ELSE 0 END) as no_feedback
                FROM conversations
            """).fetchone()
            
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "general_stats": stats,
            "language_distribution": [{"language": lang, "count": count} for lang, count in languages],
            "feedback_stats": {
                "positive": feedback_stats[0],
                "negative": feedback_stats[1],
                "no_feedback": feedback_stats[2]
            },
            "message": "Statistiques administrateur récupérées"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur récupération statistiques"
        }

@router.get("/database/info")
async def get_database_info():
    """Informations sur la base de données - ENDPOINT MANQUANT AJOUTÉ"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            # Informations sur la base
            tables_info = conn.execute("""
                SELECT name FROM sqlite_master WHERE type='table'
            """).fetchall()
            
            # Informations sur la table conversations
            conversations_info = conn.execute("""
                PRAGMA table_info(conversations)
            """).fetchall()
            
            # Taille approximative de la base
            file_size = os.path.getsize(logger_instance.db_path) if os.path.exists(logger_instance.db_path) else 0
            
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "database_info": {
                "path": logger_instance.db_path,
                "file_size_bytes": file_size,
                "file_size_mb": round(file_size / (1024 * 1024), 2),
                "tables": [table[0] for table in tables_info],
                "conversations_schema": [
                    {
                        "column": col[1],
                        "type": col[2],
                        "not_null": bool(col[3]),
                        "default": col[4],
                        "primary_key": bool(col[5])
                    } for col in conversations_info
                ]
            },
            "message": "Informations base de données récupérées"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur récupération informations base"
        }

@router.get("/conversations/{user_id}")
async def get_user_conversations_endpoint(user_id: str, limit: int = 10):
    """Conversations d'un utilisateur - ENDPOINT MANQUANT AJOUTÉ"""
    try:
        conversations = logger_instance.get_user_conversations(user_id, limit)
        
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "user_id": user_id,
            "conversations": conversations,
            "count": len(conversations),
            "message": f"{len(conversations)} conversations trouvées"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur récupération conversations utilisateur"
        }

@router.delete("/test-data")
async def cleanup_test_data():
    """Nettoyage des données de test - ENDPOINT MANQUANT AJOUTÉ"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            # Supprimer les conversations de test (avec user_id contenant "test" ou "anon")
            cursor = conn.execute("""
                DELETE FROM conversations 
                WHERE user_id LIKE '%test%' OR user_id LIKE '%anon%'
            """)
            deleted_count = cursor.rowcount
            
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "deleted_count": deleted_count,
            "message": f"{deleted_count} conversations de test supprimées"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur nettoyage données de test"
        }

# ============================================================================
# ENDPOINTS MANQUANTS À AJOUTER DANS logging.py
# Ajouter ces endpoints AVANT les "# ENDPOINTS EXISTANTS" (ligne 235)
# ============================================================================

@router.post("/conversation", response_model=ConversationResponse)
async def save_conversation_endpoint(conversation: ConversationCreate):
    """ENDPOINT MANQUANT: Sauvegarder une conversation (utilisé par le frontend)"""
    try:
        print(f"💾 [logging] Réception conversation: {conversation.conversation_id}")
        print(f"👤 [logging] User: {conversation.user_id}")
        print(f"📝 [logging] Question: {conversation.question[:50]}...")
        
        record_id = logger_instance.save_conversation(conversation)
        
        print(f"✅ [logging] Conversation sauvegardée avec ID: {record_id}")
        
        return ConversationResponse(
            conversation_id=conversation.conversation_id,
            timestamp=datetime.now(),
            message="Conversation enregistrée avec succès"
        )
    except Exception as e:
        print(f"❌ [logging] Erreur sauvegarde: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur sauvegarde: {str(e)}")

@router.patch("/conversation/{conversation_id}/feedback")
async def update_feedback_endpoint(conversation_id: str, feedback_data: dict):
    """ENDPOINT MANQUANT: Mettre à jour le feedback (utilisé par le frontend)"""
    try:
        print(f"📊 [logging] Réception feedback pour: {conversation_id}")
        print(f"📊 [logging] Feedback data: {feedback_data}")
        
        feedback_value = feedback_data.get("feedback", 0)
        
        success = logger_instance.update_feedback(conversation_id, feedback_value)
        
        if success:
            print(f"✅ [logging] Feedback mis à jour: {conversation_id} = {feedback_value}")
            return {
                "status": "success",
                "message": "Feedback mis à jour avec succès", 
                "conversation_id": conversation_id,
                "feedback": feedback_value,
                "timestamp": datetime.now().isoformat()
            }
        else:
            print(f"❌ [logging] Conversation non trouvée: {conversation_id}")
            raise HTTPException(status_code=404, detail="Conversation non trouvée")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"❌ [logging] Erreur feedback: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur feedback: {str(e)}")

@router.get("/user/{user_id}/conversations")
async def get_user_conversations_list(user_id: str, limit: int = 50):
    """ENDPOINT MANQUANT: Récupérer les conversations d'un utilisateur (utilisé par le frontend)"""
    try:
        print(f"🔍 [logging] Récupération conversations pour: {user_id}")
        print(f"🔍 [logging] Limite: {limit}")
        
        conversations = logger_instance.get_user_conversations(user_id, limit)
        
        # Enrichir les données pour le frontend
        enriched_conversations = []
        for conv in conversations:
            enriched_conversations.append({
                "conversation_id": conv["conversation_id"],
                "question": conv["question"],
                "response": "Réponse disponible",  # On ne stocke pas la réponse complète
                "timestamp": conv["timestamp"],
                "language": conv.get("language", "fr"),
                "rag_used": conv.get("rag_used", True),
                "feedback": conv.get("feedback"),
                "created_at": conv["timestamp"],
                "updated_at": conv["timestamp"]
            })
        
        print(f"✅ [logging] {len(enriched_conversations)} conversations récupérées")
        
        return {
            "status": "success",
            "user_id": user_id,
            "conversations": enriched_conversations,
            "count": len(enriched_conversations),
            "timestamp": datetime.now().isoformat(),
            "message": f"{len(enriched_conversations)} conversations trouvées"
        }
        
    except Exception as e:
        print(f"❌ [logging] Erreur récupération: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur récupération: {str(e)}")

@router.delete("/conversation/{conversation_id}")
async def delete_single_conversation(conversation_id: str):
    """ENDPOINT MANQUANT: Supprimer une conversation spécifique (utilisé par le frontend)"""
    try:
        print(f"🗑️ [logging] Suppression conversation: {conversation_id}")
        
        with sqlite3.connect(logger_instance.db_path) as conn:
            cursor = conn.execute("DELETE FROM conversations WHERE conversation_id = ?", (conversation_id,))
            
            if cursor.rowcount > 0:
                print(f"✅ [logging] Conversation supprimée: {conversation_id}")
                return {
                    "status": "success",
                    "message": "Conversation supprimée avec succès",
                    "conversation_id": conversation_id,
                    "deleted_count": cursor.rowcount,
                    "timestamp": datetime.now().isoformat()
                }
            else:
                print(f"❌ [logging] Conversation non trouvée: {conversation_id}")
                raise HTTPException(status_code=404, detail="Conversation non trouvée")
                
    except HTTPException:
        raise
    except Exception as e:
        print(f"❌ [logging] Erreur suppression: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur suppression: {str(e)}")

@router.delete("/user/{user_id}/conversations")
async def delete_all_user_conversations(user_id: str):
    """ENDPOINT MANQUANT: Supprimer toutes les conversations d'un utilisateur (utilisé par le frontend)"""
    try:
        print(f"🗑️ [logging] Suppression toutes conversations pour: {user_id}")
        
        with sqlite3.connect(logger_instance.db_path) as conn:
            cursor = conn.execute("DELETE FROM conversations WHERE user_id = ?", (user_id,))
            deleted_count = cursor.rowcount
            
        print(f"✅ [logging] {deleted_count} conversations supprimées pour: {user_id}")
        
        return {
            "status": "success",
            "message": "Toutes les conversations ont été supprimées avec succès",
            "user_id": user_id,
            "deleted_count": deleted_count,
            "timestamp": datetime.now().isoformat()
        }
            
    except Exception as e:
        print(f"❌ [logging] Erreur suppression globale: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur suppression: {str(e)}")

# ============================================================================
# ENDPOINT DE DIAGNOSTIC POUR TESTER LA CONNECTIVITÉ
# ============================================================================

@router.get("/test")
async def test_logging_system():
    """Test de connectivité du système de logging"""
    try:
        # Test de base de données
        with sqlite3.connect(logger_instance.db_path) as conn:
            count = conn.execute("SELECT COUNT(*) FROM conversations").fetchone()[0]
            
        return {
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "database": {
                "status": "connected",
                "conversations_count": count,
                "path": logger_instance.db_path
            },
            "endpoints": [
                "/logging/conversation [POST]",
                "/logging/conversation/{id}/feedback [PATCH]", 
                "/logging/user/{id}/conversations [GET]",
                "/logging/conversation/{id} [DELETE]",
                "/logging/user/{id}/conversations [DELETE]"
            ],
            "message": "Système de logging opérationnel avec tous les endpoints"
        }
    except Exception as e:
        return {
            "status": "error",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
            "message": "Erreur système de logging"
        }


# ============================================================================
# ENDPOINTS EXISTANTS (gardés pour compatibilité)
# ============================================================================

@router.post("/conversations", response_model=ConversationResponse)
async def create_conversation(conversation: ConversationCreate):
    """Créer une nouvelle conversation"""
    try:
        record_id = logger_instance.save_conversation(conversation)
        
        return ConversationResponse(
            conversation_id=conversation.conversation_id,
            timestamp=datetime.now(),
            message="Conversation enregistrée avec succès"
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.patch("/conversations/{conversation_id}/feedback")
async def update_conversation_feedback(conversation_id: str, feedback: FeedbackUpdate):
    """Mettre à jour le feedback d'une conversation"""
    try:
        success = logger_instance.update_feedback(conversation_id, feedback.feedback)
        
        if success:
            return {"message": "Feedback mis à jour avec succès", "conversation_id": conversation_id}
        else:
            raise HTTPException(status_code=404, detail="Conversation non trouvée")
            
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/conversations/{user_id}/history")
async def get_user_history(user_id: str, limit: int = 10):
    """Récupérer l'historique des conversations d'un utilisateur"""
    try:
        conversations = logger_instance.get_user_conversations(user_id, limit)
        return {
            "user_id": user_id,
            "conversations": conversations,
            "count": len(conversations)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/analytics/{days}", response_model=AnalyticsResponse)
async def get_analytics_period(days: int = 7):
    """Récupérer les analytics pour une période donnée"""
    try:
        analytics = logger_instance.get_analytics(days)
        return AnalyticsResponse(**analytics)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/conversations/{conversation_id}")
async def delete_conversation(conversation_id: str):
    """Supprimer une conversation (RGPD)"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            cursor = conn.execute("DELETE FROM conversations WHERE conversation_id = ?", (conversation_id,))
            
            if cursor.rowcount > 0:
                return DeleteResponse(
                    message="Conversation supprimée avec succès",
                    conversation_id=conversation_id,
                    deleted_count=cursor.rowcount,
                    timestamp=datetime.now()
                )
            else:
                raise HTTPException(status_code=404, detail="Conversation non trouvée")
                
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/users/{user_id}")
async def delete_user_data(user_id: str):
    """Supprimer toutes les données d'un utilisateur (RGPD)"""
    try:
        with sqlite3.connect(logger_instance.db_path) as conn:
            cursor = conn.execute("DELETE FROM conversations WHERE user_id = ?", (user_id,))
            
            return DeleteResponse(
                message="Données utilisateur supprimées avec succès",
                user_id=user_id,
                deleted_count=cursor.rowcount,
                timestamp=datetime.now()
            )
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ============================================================================
# CONFIGURATION AU DÉMARRAGE
# ============================================================================

print("✅ Module logging avec router complet initialisé")
print(f"🗄️ Base de données: {DB_PATH}")
print("🔧 Tous les endpoints manquants ajoutés pour corriger les erreurs 404")