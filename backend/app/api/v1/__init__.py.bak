"""
API v1 - Intelia Expert
Module d'initialisation pour les endpoints de l'API v1

Expert System - Architecture Modulaire

Vue d'ensemble:
Le système expert a été refactorisé pour être modulaire, maintenable et extensible,
tout en conservant une compatibilité 100% avec le frontend existant.

Structure des Fichiers:
- expert.py                      : FICHIER PRINCIPAL (nom conservé)
- expert_models.py              : Modèles Pydantic
- expert_services.py            : Logique métier
- expert_utils.py               : Fonctions utilitaires
- expert_integrations.py        : Gestionnaire intégrations
- expert_debug.py               : Endpoints de debugging
- __init__.py                   : Imports simplifiés (ce fichier)

Avantages de la Refactorisation:
✅ Maintenabilité - Séparation des préoccupations
✅ Compatibilité - Mêmes endpoints et imports
✅ Extensibilité - Ajout facile de nouvelles fonctionnalités
"""

# Le frontend continue à utiliser les mêmes imports
# from app.api.v1.expert import router  ✅ Fonctionne toujours
# from app.api.v1 import expert_router   ✅ Fonctionne toujours

# Les endpoints restent identiques:
# POST /api/v1/expert/ask
# POST /api/v1/expert/ask-public
# POST /api/v1/expert/ask-enhanced
# POST /api/v1/expert/ask-enhanced-public
# POST /api/v1/expert/feedback
# GET /api/v1/expert/topics

# Import du routeur principal expert
try:
    from .expert import router as expert_router
    from .expert import router  # Pour compatibilité with "from .expert import router"
except ImportError as e:
    print(f"Warning: Could not import expert router: {e}")
    expert_router = None
    router = None

# Imports optionnels des autres modules
try:
    from .auth import router as auth_router
except ImportError:
    auth_router = None

try:
    from .admin import router as admin_router
except ImportError:
    admin_router = None

try:
    from .logging import router as logging_router
except ImportError:
    logging_router = None

# Import des modules expert refactorisés (optionnels)
try:
    from .expert_models import *
except ImportError:
    pass

try:
    from .expert_services import ExpertService
except ImportError:
    ExpertService = None

try:
    from .expert_utils import *
except ImportError:
    pass

try:
    from .expert_integrations import IntegrationsManager
except ImportError:
    IntegrationsManager = None

try:
    from .expert_debug import router as debug_router
except ImportError:
    debug_router = None

# Liste des modules/routeurs disponibles pour debugging
available_modules = {
    "expert_router": expert_router is not None,
    "auth_router": auth_router is not None,
    "admin_router": admin_router is not None,
    "logging_router": logging_router is not None,
    "debug_router": debug_router is not None,
    "expert_service": ExpertService is not None,
    "integrations_manager": IntegrationsManager is not None,
}

# Routeurs actifs
active_routers = []
if expert_router:
    active_routers.append(("expert", expert_router))
if auth_router:
    active_routers.append(("auth", auth_router))
if admin_router:
    active_routers.append(("admin", admin_router))
if logging_router:
    active_routers.append(("logging", logging_router))
if debug_router:
    active_routers.append(("debug", debug_router))

# Export public - maintient la compatibilité
__all__ = [
    # Routeurs principaux
    "expert_router",
    "router",  # Alias pour expert_router
    "auth_router", 
    "admin_router",
    "logging_router",
    "debug_router",
    
    # Services
    "ExpertService",
    "IntegrationsManager",
    
    # Informations système
    "available_modules",
    "active_routers"
]

# Message de debug au démarrage (optionnel)
def get_module_status():
    """Retourne le statut des modules chargés"""
    return {
        "loaded_modules": sum(available_modules.values()),
        "total_modules": len(available_modules),
        "details": available_modules,
        "active_routers_count": len(active_routers)
    }