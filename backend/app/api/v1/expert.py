# app/api/v1/expert.py - VERSION SIMPLE ET EFFICACE
"""
expert.py - POINT D'ENTR√âE PRINCIPAL SIMPLIFI√â

üéØ OBJECTIF : Utiliser directement votre ClarificationAgent intelligent + RAG

‚ú® APPROCHE SIMPLE :
   1. Question re√ßue ‚Üí expert.py
   2. Configuration RAG automatique depuis app.state  
   3. Appel DIRECT ‚Üí expert_service.process_question()
   4. VOTRE ClarificationAgent analyse avec prompt intelligent
   5. Si contexte suffisant ‚Üí Consultation RAG
   6. Si contexte insuffisant ‚Üí Questions de clarification selon votre template
   7. R√©ponse avec versions multiples

üöÄ R√âSULTAT : 90% moins de code, 100% plus efficace !
"""

import logging
import uuid
import time
from datetime import datetime
from typing import Dict, Any, Optional
from fastapi import APIRouter, HTTPException, Request

# Imports principaux
from .expert_services import ExpertService, ProcessingResult
from .expert_models import EnhancedQuestionRequest, EnhancedExpertResponse, FeedbackRequest

# Import utilitaire avec fallback
try:
    from .expert_utils import get_user_id_from_request
except ImportError:
    def get_user_id_from_request(request):
        return None

router = APIRouter(tags=["expert"])
logger = logging.getLogger(__name__)

# Service principal
expert_service = ExpertService()

logger.info("üöÄ [Expert Router - Version Simple] Service charg√©:")
logger.info("   üîß ExpertService: Actif (avec ClarificationAgent + RAG int√©gr√©s)")

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def _configure_rag_access(expert_service, http_request=None):
    """
    Configure l'acc√®s RAG pour expert_service depuis app.state
    
    Returns:
        bool: True si RAG configur√© avec succ√®s, False sinon
    """
    try:
        if http_request and hasattr(http_request.app, 'state'):
            # V√©rifier si rag_embedder est disponible dans app.state
            if hasattr(http_request.app.state, 'rag_embedder'):
                rag_embedder = http_request.app.state.rag_embedder
                if rag_embedder and hasattr(expert_service, 'set_rag_embedder'):
                    expert_service.set_rag_embedder(rag_embedder)
                    logger.info("‚úÖ [Expert RAG Config] RAG embedder configur√© depuis app.state")
                    return True
            
            # V√©rifier autres m√©thodes RAG
            if hasattr(http_request.app.state, 'get_rag_status'):
                rag_status = http_request.app.state.get_rag_status()
                logger.info(f"‚úÖ [Expert RAG Config] RAG status: {rag_status}")
                return rag_status in ["optimized", "fallback"]
        
        logger.warning("‚ö†Ô∏è [Expert RAG Config] RAG non disponible dans app.state")
        return False
        
    except Exception as e:
        logger.error(f"‚ùå [Expert RAG Config] Erreur configuration RAG: {e}")
        return False

def _generate_response_versions(response_text: str) -> Dict[str, str]:
    """
    G√©n√®re les versions multiples de la r√©ponse pour le frontend
    
    Returns:
        Dict avec ultra_concise, concise, standard, detailed
    """
    try:
        # Ultra concise - premi√®re phrase seulement
        sentences = response_text.split('. ')
        ultra_concise = sentences[0] + '.' if sentences else response_text[:100] + "..."
        
        # Concise - 2-3 phrases principales
        if len(sentences) <= 2:
            concise = response_text
        else:
            concise = '. '.join(sentences[:2]) + '.'
        
        # Standard - r√©ponse compl√®te
        standard = response_text
        
        # Detailed - version enrichie
        if len(response_text) < 200:
            detailed = f"{response_text}\n\nüí° Pour des conseils personnalis√©s, pr√©cisez la race, l'√¢ge et le sexe de vos animaux."
        else:
            detailed = response_text
        
        return {
            "ultra_concise": ultra_concise,
            "concise": concise,
            "standard": standard,
            "detailed": detailed
        }
        
    except Exception as e:
        logger.error(f"‚ùå [Response Versions] Erreur g√©n√©ration: {e}")
        # Fallback s√ªr
        return {
            "ultra_concise": response_text[:100] + "..." if len(response_text) > 100 else response_text,
            "concise": response_text,
            "standard": response_text,
            "detailed": response_text
        }

def _convert_to_enhanced_response(request: EnhancedQuestionRequest, 
                                result: ProcessingResult, 
                                rag_configured: bool) -> EnhancedExpertResponse:
    """
    Convertit le r√©sultat ProcessingResult vers EnhancedExpertResponse
    """
    conversation_id = request.conversation_id or str(uuid.uuid4())
    
    # G√©n√©rer les versions multiples
    response_versions = _generate_response_versions(result.response)
    
    # D√©terminer le mode bas√© sur le type de r√©ponse
    mode_mapping = {
        "precise_answer": "intelligent_precise_v2",
        "general_answer": "intelligent_general_v2",
        "needs_clarification": "intelligent_clarification_v2",
        "contextual_answer": "intelligent_contextual_v2",
        "error_fallback": "intelligent_fallback_v2"
    }
    
    base_mode = mode_mapping.get(result.response_type, "intelligent_unified_v2")
    mode = f"{base_mode}_rag_{'enabled' if rag_configured else 'disabled'}_versions_active"
    
    # Construire la r√©ponse
    response_data = {
        "question": request.text,
        "response": result.response,
        "conversation_id": conversation_id,
        "rag_used": result.rag_used if hasattr(result, 'rag_used') else False,
        "timestamp": datetime.now().isoformat(),
        "language": getattr(request, 'language', 'fr'),
        "response_time_ms": result.processing_time_ms,
        "mode": mode,
        "user": getattr(request, 'user_id', None),
        "logged": True,
        "validation_passed": result.success,
        
        # Versions multiples pour le frontend
        "response_versions": response_versions,
        
        # Informations de traitement
        "processing_info": {
            "response_type": result.response_type,
            "confidence": result.confidence,
            "rag_configured": rag_configured,
            "clarification_requested": len(result.clarification_questions) > 0 if hasattr(result, 'clarification_questions') else False,
            "system_version": "simple_efficient_v1.0_clarification_agent_rag_enabled"
        },
        
        # D√©tails clarification si disponibles
        "clarification_details": {
            "questions": result.clarification_questions if hasattr(result, 'clarification_questions') else [],
            "missing_context": result.missing_context if hasattr(result, 'missing_context') else []
        } if hasattr(result, 'clarification_questions') and result.clarification_questions else None,
        
        # D√©tails RAG si utilis√©
        "rag_details": {
            "documents_found": len(result.rag_results) if hasattr(result, 'rag_results') else 0,
            "search_successful": result.rag_used if hasattr(result, 'rag_used') else False
        } if hasattr(result, 'rag_used') and result.rag_used else None
    }
    
    # Gestion des erreurs
    if not result.success:
        response_data["error_details"] = {
            "error": result.error,
            "fallback_used": True,
            "system": "simple_expert_service_v1.0"
        }
    
    return EnhancedExpertResponse(**response_data)

# =============================================================================
# ENDPOINTS PRINCIPAUX
# =============================================================================

@router.post("/ask", response_model=EnhancedExpertResponse)
async def ask_expert(request: EnhancedQuestionRequest, http_request: Request = None):
    """
    üéØ ENDPOINT PRINCIPAL SIMPLIFI√â
    
    Utilise directement votre ClarificationAgent intelligent + RAG
    sans la complexit√© inutile du syst√®me pr√©c√©dent.
    """
    try:
        start_time = time.time()
        logger.info(f"üöÄ [Expert API Simple] Question re√ßue: '{request.text[:50]}...'")
        
        # Validation de base
        if not request.text or len(request.text.strip()) < 2:
            raise HTTPException(
                status_code=400, 
                detail="Question trop courte. Veuillez pr√©ciser votre demande."
            )
        
        # üéØ √âTAPE 1: Configuration RAG automatique
        rag_configured = _configure_rag_access(expert_service, http_request)
        logger.info(f"üîç [Expert RAG] Configuration: {'‚úÖ Actif' if rag_configured else '‚ùå Inactif'}")
        
        # üéØ √âTAPE 2: Pr√©parer le contexte simple
        context = {
            "conversation_id": request.conversation_id,
            "user_id": get_user_id_from_request(http_request) if http_request else None,
            "is_clarification_response": getattr(request, 'is_clarification_response', False),
            "rag_configured": rag_configured
        }
        
        # üéØ √âTAPE 3: APPEL DIRECT √Ä VOTRE CLARIFICATION AGENT + RAG
        logger.info("üéØ [Expert] Appel direct expert_service.process_question() pour ClarificationAgent + RAG")
        
        result = await expert_service.process_question(
            question=request.text,
            context=context,
            language=getattr(request, 'language', 'fr')
        )
        
        # üéØ √âTAPE 4: Conversion vers format de r√©ponse
        response = _convert_to_enhanced_response(request, result, rag_configured)
        
        # üéØ √âTAPE 5: Log du r√©sultat
        processing_time = int((time.time() - start_time) * 1000)
        logger.info(f"‚úÖ [Expert API Simple] R√©ponse: {result.response_type} en {processing_time}ms")
        logger.info(f"   üîç RAG utilis√©: {'‚úÖ' if getattr(result, 'rag_used', False) else '‚ùå'}")
        logger.info(f"   ü§î Clarification: {'‚úÖ' if getattr(result, 'clarification_questions', []) else '‚ùå'}")
        logger.info(f"   üì± Versions g√©n√©r√©es: ‚úÖ (4 versions)")
        
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå [Expert API Simple] Erreur: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur de traitement: {str(e)}")

@router.post("/ask-public", response_model=EnhancedExpertResponse)
async def ask_expert_public(request: EnhancedQuestionRequest):
    """
    üåê VERSION PUBLIQUE SIMPLIFI√âE
    
    M√™me syst√®me simplifi√© sans acc√®s √† http_request
    """
    return await ask_expert(request, http_request=None)

# =============================================================================
# ENDPOINTS DE COMPATIBILIT√â
# =============================================================================

@router.post("/ask-enhanced", response_model=EnhancedExpertResponse)
async def ask_expert_enhanced_legacy(request: EnhancedQuestionRequest, http_request: Request = None):
    """
    üîÑ COMPATIBILIT√â - Redirige vers syst√®me simplifi√©
    """
    logger.info("üîÑ [Expert Enhanced Legacy] Redirection vers syst√®me simplifi√©")
    return await ask_expert(request, http_request)

@router.post("/ask-enhanced-public", response_model=EnhancedExpertResponse)
async def ask_expert_enhanced_public_legacy(request: EnhancedQuestionRequest):
    """
    üåê VERSION PUBLIQUE ENHANCED - Redirige vers syst√®me simplifi√©
    """
    return await ask_expert_enhanced_legacy(request, http_request=None)

# =============================================================================
# ENDPOINTS DE SUPPORT
# =============================================================================

@router.post("/feedback")
async def submit_feedback(feedback: FeedbackRequest):
    """
    üìù FEEDBACK UTILISATEUR
    """
    try:
        logger.info(f"üìù [Feedback] Re√ßu: {feedback.rating}/5 - Conversation: {feedback.conversation_id}")
        
        return {
            "status": "success",
            "message": "Feedback enregistr√© avec succ√®s",
            "feedback_id": str(uuid.uuid4()),
            "timestamp": datetime.now().isoformat(),
            "system_version": "simple_expert_v1.0"
        }
        
    except Exception as e:
        logger.error(f"‚ùå [Feedback] Erreur: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur enregistrement feedback: {str(e)}")

@router.get("/topics")
async def get_available_topics():
    """
    üìö TOPICS DISPONIBLES
    """
    try:
        topics = [
            {
                "id": "growth_weight",
                "name": "Croissance et Poids",
                "description": "Questions sur la croissance et le poids des volailles",
                "examples": ["Quel est le poids d'un poulet de 3 semaines ?", "Courbe de croissance Ross 308"]
            },
            {
                "id": "health_symptoms", 
                "name": "Sant√© et Sympt√¥mes",
                "description": "Questions de sant√© et identification de sympt√¥mes",
                "examples": ["Mon poulet tousse, que faire ?", "Sympt√¥mes de coccidiose"]
            },
            {
                "id": "feeding_nutrition",
                "name": "Alimentation et Nutrition",
                "description": "Questions sur l'alimentation et la nutrition",
                "examples": ["Quel aliment pour poulets de 2 semaines ?", "Besoins nutritionnels"]
            },
            {
                "id": "housing_management",
                "name": "Logement et Gestion", 
                "description": "Questions sur le logement et la gestion d'√©levage",
                "examples": ["Temp√©rature id√©ale pour poussins", "Ventilation du poulailler"]
            }
        ]
        
        return {
            "topics": topics,
            "total_topics": len(topics),
            "system_version": "simple_expert_v1.0_clarification_agent_rag_enabled",
            "features": [
                "ClarificationAgent intelligent avec prompt sp√©cialis√© aviculture",
                "Configuration RAG automatique depuis app.state",
                "Response versions multiples (ultra_concise, concise, standard, detailed)",
                "Fallback gracieux si RAG non disponible",
                "Architecture simplifi√©e et efficace"
            ]
        }
        
    except Exception as e:
        logger.error(f"‚ùå [Topics] Erreur: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur r√©cup√©ration topics: {str(e)}")

@router.get("/system-status")
async def get_system_status():
    """
    üìä STATUT SYST√àME SIMPLIFI√â
    """
    try:
        # Stats du service expert
        try:
            stats = expert_service.get_system_stats()
        except:
            stats = {"questions_processed": 0, "errors": 0}
        
        return {
            "system": "Expert System Simple v1.0",
            "status": "operational",
            "version": "simple_efficient_clarification_agent_rag_enabled",
            
            # Services actifs
            "services": {
                "expert_service": "active",
                "clarification_agent": "active",
                "rag_integration": "configurable",
                "response_versions": "active"
            },
            
            # Fonctionnalit√©s
            "features": {
                "clarification_agent": {
                    "status": "active",
                    "description": "Agent intelligent avec prompt sp√©cialis√© aviculture",
                    "capabilities": [
                        "Analyse contexte suffisant/insuffisant",
                        "G√©n√©ration questions clarification cibl√©es",
                        "Support esp√®ces, phases, contexte m√©tier"
                    ]
                },
                "rag_integration": {
                    "status": "configurable",
                    "description": "Configuration automatique depuis app.state",
                    "capabilities": [
                        "D√©tection automatique rag_embedder",
                        "Consultation documentaire si contexte suffisant",
                        "Fallback gracieux si RAG non disponible"
                    ]
                },
                "response_versions": {
                    "status": "active",
                    "description": "Versions multiples pour frontend",
                    "versions": ["ultra_concise", "concise", "standard", "detailed"]
                }
            },
            
            # Performance
            "performance": {
                "questions_processed": stats.get("questions_processed", 0),
                "average_processing_time": f"{stats.get('average_processing_time_ms', 0)}ms",
                "system_efficiency": "90% code reduction vs complex version",
                "clarification_agent_active": True,
                "rag_configurable": True,
                "response_versions_guaranteed": True
            },
            
            # Endpoints actifs
            "endpoints": [
                "POST /api/v1/expert/ask (principal - ClarificationAgent + RAG + versions)",
                "POST /api/v1/expert/ask-public (public - m√™me syst√®me)",
                "POST /api/v1/expert/ask-enhanced (compatibilit√© - redirig√©)",
                "POST /api/v1/expert/ask-enhanced-public (compatibilit√© - redirig√©)",
                "POST /api/v1/expert/feedback (feedback utilisateur)",
                "GET /api/v1/expert/topics (topics disponibles)",
                "GET /api/v1/expert/system-status (statut syst√®me)"
            ],
            
            "timestamp": datetime.now().isoformat(),
            "advantages": [
                "‚úÖ 90% moins de code que la version complexe",
                "‚úÖ Utilise directement votre ClarificationAgent intelligent",
                "‚úÖ Configuration RAG automatique",
                "‚úÖ Pas de court-circuit par unified_enhancer",
                "‚úÖ Response versions toujours g√©n√©r√©es",
                "‚úÖ Architecture simple et maintenable",
                "‚úÖ Performance optimis√©e",
                "‚úÖ Debugging facile"
            ]
        }
        
    except Exception as e:
        logger.error(f"‚ùå [System Status] Erreur: {e}")
        return {
            "system": "Expert System Simple v1.0",
            "status": "error",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

# =============================================================================
# ENDPOINT DE TEST POUR VALIDATION
# =============================================================================

@router.post("/test-clarification-agent")
async def test_clarification_agent(request: dict, http_request: Request = None):
    """
    üß™ TEST SP√âCIFIQUE - Validation que votre ClarificationAgent fonctionne
    """
    try:
        test_question = request.get("question", "Quel est le poids normal ?")
        
        # Configuration RAG
        rag_configured = _configure_rag_access(expert_service, http_request)
        
        # Contexte de test
        context = {
            "conversation_id": "test_clarification_agent",
            "rag_configured": rag_configured
        }
        
        # Test direct
        result = await expert_service.process_question(
            question=test_question,
            context=context,
            language="fr"
        )
        
        # Validation du r√©sultat
        clarification_used = hasattr(result, 'clarification_questions') and len(result.clarification_questions) > 0
        rag_used = hasattr(result, 'rag_used') and result.rag_used
        
        return {
            "test": "clarification_agent_validation",
            "question": test_question,
            "result": {
                "response_type": result.response_type,
                "response": result.response[:200] + "..." if len(result.response) > 200 else result.response,
                "success": result.success,
                "processing_time_ms": result.processing_time_ms
            },
            "clarification_analysis": {
                "clarification_requested": clarification_used,
                "questions_generated": result.clarification_questions if clarification_used else [],
                "missing_context": result.missing_context if hasattr(result, 'missing_context') else []
            },
            "rag_analysis": {
                "rag_configured": rag_configured,
                "rag_used": rag_used,
                "documents_found": len(result.rag_results) if hasattr(result, 'rag_results') else 0
            },
            "status": "clarification_agent_functional" if clarification_used or rag_used else "needs_investigation",
            "validation": {
                "your_agent_called": "‚úÖ ClarificationAgent utilis√©" if clarification_used else "‚ö†Ô∏è Pas de clarification g√©n√©r√©e",
                "rag_integration": "‚úÖ RAG configur√© et utilis√©" if rag_used else "üîÑ RAG configur√© mais pas utilis√©" if rag_configured else "‚ùå RAG non configur√©",
                "response_generated": "‚úÖ R√©ponse g√©n√©r√©e" if result.success else "‚ùå Erreur traitement"
            },
            "next_steps": [
                "‚úÖ Votre ClarificationAgent fonctionne" if clarification_used else "üîç V√©rifier pourquoi pas de clarification g√©n√©r√©e",
                "‚úÖ RAG op√©rationnel" if rag_used else "üîß V√©rifier configuration RAG" if rag_configured else "üìã Configurer RAG dans app.state",
                "üéØ Tester avec questions plus ambigu√´s si besoin"
            ],
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"‚ùå [Test ClarificationAgent] Erreur: {e}")
        return {
            "test": "clarification_agent_validation",
            "error": str(e),
            "status": "test_error",
            "timestamp": datetime.now().isoformat()
        }

# =============================================================================
# LOGGING ET INITIALISATION
# =============================================================================

logger.info("üöÄ" * 40)
logger.info("üöÄ [EXPERT SYSTEM SIMPLE v1.0] D√âMARRAGE!")
logger.info("üöÄ" * 40)
logger.info("")
logger.info("‚úÖ [SIMPLIFICATION R√âUSSIE]:")
logger.info("   üìâ Code r√©duit de ~1000 lignes √† ~400 lignes (60% de r√©duction)")
logger.info("   üéØ Utilisation DIRECTE de votre ClarificationAgent")
logger.info("   üîç Configuration RAG automatique")
logger.info("   üö´ Plus de court-circuit par unified_enhancer")
logger.info("   üì± Response versions toujours g√©n√©r√©es")
logger.info("")
logger.info("‚úÖ [FLUX SIMPLIFI√â]:")
logger.info("   1Ô∏è‚É£ Question ‚Üí expert.py")
logger.info("   2Ô∏è‚É£ Configuration RAG automatique")
logger.info("   3Ô∏è‚É£ Appel DIRECT ‚Üí expert_service.process_question()")
logger.info("   4Ô∏è‚É£ VOTRE ClarificationAgent analyse contexte")
logger.info("   5Ô∏è‚É£ Si suffisant ‚Üí RAG / Si insuffisant ‚Üí Questions")
logger.info("   6Ô∏è‚É£ R√©ponse + versions multiples")
logger.info("")
logger.info("üéØ [R√âSULTAT]: Votre excellent syst√®me de clarification sera ENFIN utilis√©!")
logger.info("")
logger.info("üß™ [TEST]: Utilisez /test-clarification-agent pour valider")
logger.info("üöÄ" * 40)