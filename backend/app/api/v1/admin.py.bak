from fastapi import APIRouter, HTTPException
import logging
import os
from datetime import datetime
from typing import Dict, Any, List
from pathlib import Path
import sqlite3

router = APIRouter(prefix="/admin")
logger = logging.getLogger(__name__)

RAG_INDEX_ROOT = Path(os.getenv("RAG_INDEX_ROOT", "rag_index"))

def _rag_index_status() -> Dict[str, Any]:
    species = ["global", "broiler", "layer"]
    status = {}
    for sp in species:
        p = RAG_INDEX_ROOT / sp
        status[sp] = {
            "path": str(p),
            "exists": p.exists(),
            "has_faiss": (p / "index.faiss").exists(),
            "has_meta": (p / "meta.json").exists(),
        }
    status["total_present"] = sum(1 for sp in species if status[sp]["exists"])
    return status

@router.get("/dashboard")
async def get_dashboard() -> Dict[str, Any]:
    """
    Global health/diagnostics without external vector store assumptions.
    """
    try:
        openai_configured = bool(os.getenv("OPENAI_API_KEY"))
        rag_status = _rag_index_status()
        diagnostics = {
            "openai_configured": openai_configured,
            "rag_indexes": rag_status,
            "timestamp": datetime.utcnow().isoformat()
        }
        return {"status": "success", "diagnostics": diagnostics}
    except Exception as e:
        logger.exception("Dashboard error")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve dashboard status: {e}")

@router.get("/users")
async def get_users() -> Dict[str, Any]:
    """
    Lightweight user overview based on the logging SQLite store.
    """
    try:
        db_path = os.getenv("CONV_DB_PATH", "conversations.db")
        users: List[str] = []
        with sqlite3.connect(db_path) as conn:
            conn.row_factory = sqlite3.Row
            rows = conn.execute("""
                SELECT DISTINCT user_id FROM conversations
                ORDER BY user_id
            """).fetchall()
            users = [r["user_id"] for r in rows]

            # top recent sessions (last 20)
            sessions = conn.execute("""
                SELECT conversation_id, user_id, timestamp
                FROM conversations
                ORDER BY datetime(timestamp) DESC
                LIMIT 20
            """).fetchall()

        return {
            "status": "success",
            "total_users": len(users),
            "users": users,
            "recent_sessions": [
                {"conversation_id": r["conversation_id"], "user_id": r["user_id"], "timestamp": r["timestamp"]}
                for r in sessions
            ],
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.exception("Get users error")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve users list: {e}")

@router.get("/rag/diagnostics")
async def get_rag_diagnostics() -> Dict[str, Any]:
    try:
        return {
            "status": "success",
            "openai_configured": bool(os.getenv("OPENAI_API_KEY")),
            "rag_indexes": _rag_index_status(),
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.exception("RAG diagnostics error")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve RAG diagnostics: {e}")

@router.get("/rag/test")
async def test_rag_end_to_end() -> Dict[str, Any]:
    """
    Smoke test du RAG end-to-end.
    """
    try:
        from .pipeline.rag_engine import RAGEngine
        rag = RAGEngine()
        test_question = "Température optimale en démarrage pour Ross 308 ?"
        answer = rag.generate_answer(test_question, {})
        return {
            "status": "success",
            "test_question": test_question,
            "test_answer": answer,
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.exception("RAG test error")
        raise HTTPException(status_code=500, detail=f"RAG end-to-end test failed: {e}")

@router.get("/analytics")
async def get_analytics() -> Dict[str, Any]:
    return {"status": "not_implemented"}
